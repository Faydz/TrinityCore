diff --git a/LuaScripts/CreatureHooks.lua b/LuaScripts/CreatureHooks.lua
new file mode 100644
index 0000000..18e805b
+++ /dev/null
+++ b/LuaScripts/CreatureHooks.lua
@@ -0,0 +1,46 @@
+local CREA_ENTRIES =
+{
+    16520,
+    16517,
+    963,
+    29212,
+    416,
+}
+
+for _, CREA_ENTRY in ipairs(CREA_ENTRIES) do
+RegisterCreatureEvent(CREA_ENTRY,   1,    function(...) print("CREATURE_EVENT_ON_ENTER_COMBAT",                 1,    ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   2,    function(...) print("CREATURE_EVENT_ON_LEAVE_COMBAT",                 2,    ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   3,    function(...) print("CREATURE_EVENT_ON_TARGET_DIED",                  3,    ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   4,    function(...) print("CREATURE_EVENT_ON_DIED",                         4,    ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   5,    function(...) print("CREATURE_EVENT_ON_SPAWN",                        5,    ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   6,    function(...) print("CREATURE_EVENT_ON_REACH_WP",                     6,    ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   7,    function(...) print("CREATURE_EVENT_ON_AIUPDATE",                     7,    ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   8,    function(...) print("CREATURE_EVENT_ON_RECEIVE_EMOTE",                8,    ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   9,    function(...) print("CREATURE_EVENT_ON_DAMAGE_TAKEN",                 9,    ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   10,   function(...) print("CREATURE_EVENT_ON_PRE_COMBAT",                   10,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   11,   function(...) print("CREATURE_EVENT_ON_ATTACKED_AT",                  11,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   12,   function(...) print("CREATURE_EVENT_ON_OWNER_ATTACKED",               12,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   13,   function(...) print("CREATURE_EVENT_ON_OWNER_ATTACKED_AT",            13,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   14,   function(...) print("CREATURE_EVENT_ON_HIT_BY_SPELL",                 14,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   15,   function(...) print("CREATURE_EVENT_ON_SPELL_HIT_TARGET",             15,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   16,   function(...) print("CREATURE_EVENT_ON_SPELL_CLICK",                  16,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   17,   function(...) print("CREATURE_EVENT_ON_CHARMED",                      17,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   18,   function(...) print("CREATURE_EVENT_ON_POSSESS",                      18,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   19,   function(...) print("CREATURE_EVENT_ON_JUST_SUMMONED_CREATURE",       19,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   20,   function(...) print("CREATURE_EVENT_ON_SUMMONED_CREATURE_DESPAWN",    20,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   21,   function(...) print("CREATURE_EVENT_ON_SUMMONED_CREATURE_DIED",       21,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   22,   function(...) print("CREATURE_EVENT_ON_SUMMONED",                     22,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   23,   function(...) print("CREATURE_EVENT_ON_RESET",                        23,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   24,   function(...) print("CREATURE_EVENT_ON_REACH_HOME",                   24,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   25,   function(...) print("CREATURE_EVENT_ON_CAN_RESPAWN",                  25,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   26,   function(...) print("CREATURE_EVENT_ON_CORPSE_REMOVED",               26,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   27,   function(...) print("CREATURE_EVENT_ON_MOVE_IN_LOS",                  27,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   28,   function(...) print("CREATURE_EVENT_ON_VISIBLE_MOVE_IN_LOS",          28,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   29,   function(...) print("CREATURE_EVENT_ON_PASSANGER_BOARDED",            29,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   30,   function(...) print("CREATURE_EVENT_ON_DUMMY_EFFECT",                 30,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   31,   function(...) print("CREATURE_EVENT_ON_QUEST_ACCEPT",                 31,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   32,   function(...) print("CREATURE_EVENT_ON_QUEST_SELECT",                 32,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   33,   function(...) print("CREATURE_EVENT_ON_QUEST_COMPLETE",               33,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   34,   function(...) print("CREATURE_EVENT_ON_QUEST_REWARD",                 34,   ...) end )
+RegisterCreatureEvent(CREA_ENTRY,   35,   function(...) print("CREATURE_EVENT_ON_DIALOG_STATUS",                35,   ...) end )
+end
diff --git a/LuaScripts/GameObjectHooks.lua b/LuaScripts/GameObjectHooks.lua
new file mode 100644
index 0000000..2dca87a
--- /dev/null
+++ b/LuaScripts/GameObjectHooks.lua
@@ -0,0 +1,17 @@
+local GO_ENTRIES =
+{
+    68,
+}
+
+for _, GO_ENTRY in ipairs(GO_ENTRIES) do
+--RegisterGameObjectEvent(GO_ENTRY, 1,  function(...) print("GAMEOBJECT_EVENT_ON_AIUPDATE",            1,  ...) end )
+RegisterGameObjectEvent(GO_ENTRY, 2,  function(...) print("GAMEOBJECT_EVENT_ON_RESET",               2,  ...) end )
+RegisterGameObjectEvent(GO_ENTRY, 3,  function(...) print("GAMEOBJECT_EVENT_ON_DUMMY_EFFECT",        3,  ...) end )
+RegisterGameObjectEvent(GO_ENTRY, 4,  function(...) print("GAMEOBJECT_EVENT_ON_QUEST_ACCEPT",        4,  ...) end )
+RegisterGameObjectEvent(GO_ENTRY, 5,  function(...) print("GAMEOBJECT_EVENT_ON_QUEST_REWARD",        5,  ...) end )
+RegisterGameObjectEvent(GO_ENTRY, 6,  function(...) print("GAMEOBJECT_EVENT_ON_DIALOG_STATUS",       6,  ...) end )
+RegisterGameObjectEvent(GO_ENTRY, 7,  function(...) print("GAMEOBJECT_EVENT_ON_DESTROYED",           7,  ...) end )
+RegisterGameObjectEvent(GO_ENTRY, 8,  function(...) print("GAMEOBJECT_EVENT_ON_DAMAGED",             8,  ...) end )
+RegisterGameObjectEvent(GO_ENTRY, 9,  function(...) print("GAMEOBJECT_EVENT_ON_LOOT_STATE_CHANGE",   9,  ...) end )
+RegisterGameObjectEvent(GO_ENTRY, 10, function(...) print("GAMEOBJECT_EVENT_ON_GO_STATE_CHANGED",    10, ...) end )
+end
diff --git a/LuaScripts/Gossip/Creature/npc_teleport.lua b/LuaScripts/Gossip/Creature/npc_teleport.lua
new file mode 100644
index 0000000..423874b
--- /dev/null
+++ b/LuaScripts/Gossip/Creature/npc_teleport.lua
@@ -0,0 +1,111 @@
+local NPC_ID = NPCID
+
+local T = 
+	{
+		-- Horde Cities
+	
+		{1, 1503, -4415.5, 22, 0},		-- Orgrimmar		intid 1
+		{0, 1831, 238.5, 61.6, 0},		-- Undercity		intid 2
+		{1, -1278, 122, 132, 0},		-- Thunderbluff		intid 3
+		{530, 9484, -7294, 15, 0},		-- Silvermoon		intid 4
+
+		-- Ally Cities
+
+		{0, -8905, 560, 94, 0.62},		-- Stormwind		intid 5
+		{0, -4795, -1117, 499, 0},		-- Ironforge		intid 6
+		{1, 9952, 2280.5, 1342, 1.6},		-- Darnassus		intid 7
+		{530, -3863, -11736, -106, 2},		-- The Exodar		intid 8
+		
+		-- Outlands Locations
+		
+		{530, 1481, 6829, 107, 6},		-- Blade's Edge		intid 9
+		{530, -249, 947, 85, 2},		-- Hellfire		intid 10
+		{530, -1769, 7150, -9, 2},		-- Nagrand		intid 11
+		{530, 3043, 3645, 143, 2},		-- Netherstorm		intid 12
+		{530, -3034, 2937, 87, 5},		-- Shadowmoon		intid 13
+		{530, -1942, 4689, -2, 5},		-- Terokkar		intid 14
+		{530, -217, 5488, 23, 2},		-- Zangarmarsh		intid 15
+		{530, -1822, 5417, 1, 3},		-- Shattrath		intid 16
+		
+		-- Northrend Locations
+		
+		{571, 3230, 5279, 47, 3},		-- Borean Tundra	intid 17
+		{571, 5732, 1016, 175, 3.6},		-- Crystalsong		intid 18
+		{571, 3547, 274, 46, 1.6},		-- Dragonblight		intid 19
+		{571, 3759, -2672, 177, 3},		-- Grizzly Hills	intid 20
+		{571, 772, -2905, 7, 5},		-- Howling Fjord	intid 21
+		{571, 8517, 676, 559, 4.7},		-- Icecrown		intid 22
+		{571, 5571, 5739, -75, 2},		-- Sholazar		intid 23
+		{571, 6121, -1025, 409, 4.7},		-- Storm Peaks		intid 24
+		{571, 5135, 2840, 408, 3},		-- Wintergrasp		intid 25
+		{571, 5761, -3547, 387, 5},		-- Zul'Drak		intid 26
+		{571, 5826, 470, 659, 1.4},		-- Dalaran		intid 27
+		
+		-- PvP Locations
+		
+		{0, -13229, 226, 33, 1},		-- Gurubashi		intid 28
+		{1, -3669, 1094, 160, 3},		-- Dire Maul		intid 29
+		{530, -1983, 6562, 12, 2},		-- Nagrand		intid 30
+		{530, 2910, 5976, 2, 4},		-- Blade's Edge		intid 31
+	}
+
+function Teleporter_Gossip(event, plr, unit)
+	plr:GossipMenuAddItem(0, "Main Cities", 0, 1001, 0)
+	plr:GossipMenuAddItem(0, "Outlands Locations", 0, 1002, 0)
+	plr:GossipMenuAddItem(0, "Northrend Locations", 0, 1003, 0)
+	plr:GossipMenuAddItem(0, "PvP Locations", 0, 1004, 0)
+	plr:GossipSendMenu(1, unit)
+end
+
+function Teleporter_Event(event, plr, unit, arg2, intid)
+	if(intid >= 1) and (intid <= 100) then
+		plr:Teleport(T[intid][1], T[intid][2], T[intid][3], T[intid][4], T[intid][5])
+	elseif(intid == 1000) then
+		Teleporter_Gossip(event, plr, unit)
+	elseif(intid >= 1001) and (intid <= 1004) then
+		if(intid == 1001) then
+			if(plr:GetTeam() == 1) then
+				plr:GossipMenuAddItem(2, "Orgrimmar", 0, 1)
+				plr:GossipMenuAddItem(2, "Undercity", 0, 2)
+				plr:GossipMenuAddItem(2, "Thunderbluff", 0, 3)
+				plr:GossipMenuAddItem(2, "Silvermoon", 0, 4)
+			else
+				plr:GossipMenuAddItem(2, "Stormwind", 0, 5)
+				plr:GossipMenuAddItem(2, "Ironforge", 0, 6)
+				plr:GossipMenuAddItem(2, "Darnassus", 0, 7)
+				plr:GossipMenuAddItem(2, "The Exodar", 0, 8)
+			end
+		elseif(intid == 1002) then
+			plr:GossipMenuAddItem(2, "Blade's Edge Mountains", 0, 9)
+			plr:GossipMenuAddItem(2, "Hellfire Peninsula", 0, 10)
+			plr:GossipMenuAddItem(2, "Nagrand", 0, 11)
+			plr:GossipMenuAddItem(2, "Netherstorm", 0, 12)
+			plr:GossipMenuAddItem(2, "Shadowmoon Valley", 0, 13)
+			plr:GossipMenuAddItem(2, "Terokkar Forest", 0, 14)
+			plr:GossipMenuAddItem(2, "Zangramarsh", 0, 15)
+			plr:GossipMenuAddItem(2, "Shattrath", 0, 16)
+		elseif(intid == 1003) then
+			plr:GossipMenuAddItem(2, "Borean Tundra", 0, 17)
+			plr:GossipMenuAddItem(2, "Crystalsong Forest", 0, 18)
+			plr:GossipMenuAddItem(2, "Dragonblight", 0, 19)
+			plr:GossipMenuAddItem(2, "Grizzly Hills", 0, 20)
+			plr:GossipMenuAddItem(2, "Howling Fjords", 0, 21)
+			plr:GossipMenuAddItem(2, "Icecrown Glaicer", 0, 22)
+			plr:GossipMenuAddItem(2, "Sholazar Basin", 0, 23)
+			plr:GossipMenuAddItem(2, "Storm Peaks", 0, 24)
+			plr:GossipMenuAddItem(2, "Wintergrasp", 0, 25)
+			plr:GossipMenuAddItem(2, "Zul'Drak", 0, 26)
+			plr:GossipMenuAddItem(2, "Dalaran", 0, 27)
+		elseif(intid == 1004) then
+			plr:GossipMenuAddItem(9, "Gurubashi Arena", 0, 28)
+			plr:GossipMenuAddItem(9, "Dire Maul Arena", 0, 29)
+			plr:GossipMenuAddItem(9, "Nagrand Arena", 0, 30)
+			plr:GossipMenuAddItem(9, "Blade's Edge Arena", 0, 31)
+		end
+		plr:GossipMenuAddItem(0, "Back", 0, 1000)
+		plr:GossipSendMenu(1, unit)
+	end
+end
+
+RegisterCreatureGossipEvent(NPC_ID, 1, Teleporter_Gossip)
+RegisterCreatureGossipEvent(NPC_ID, 2, Teleporter_Event)
\ No newline at end of file
diff --git a/LuaScripts/ServerHooks.lua b/LuaScripts/ServerHooks.lua
new file mode 100644
index 0000000..fff870b
--- /dev/null
+++ b/LuaScripts/ServerHooks.lua
@@ -0,0 +1,74 @@
+
+RegisterServerHook(1,   function(...) print("PLAYER_EVENT_ON_CHARACTER_CREATE",            1,   ...) end )
+RegisterServerHook(2,   function(...) print("PLAYER_EVENT_ON_CHARACTER_DELETE",            2,   ...) end )
+RegisterServerHook(3,   function(...) print("PLAYER_EVENT_ON_LOGIN",                       3,   ...) end )
+RegisterServerHook(4,   function(...) print("PLAYER_EVENT_ON_LOGOUT",                      4,   ...) end )
+RegisterServerHook(5,   function(...) print("PLAYER_EVENT_ON_SPELL_CAST",                  5,   ...) end )
+RegisterServerHook(6,   function(...) print("PLAYER_EVENT_ON_KILL_PLAYER",                 6,   ...) end )
+RegisterServerHook(7,   function(...) print("PLAYER_EVENT_ON_KILL_CREATURE",               7,   ...) end )
+RegisterServerHook(8,   function(...) print("PLAYER_EVENT_ON_KILLED_BY_CREATURE",          8,   ...) end )
+RegisterServerHook(9,   function(...) print("PLAYER_EVENT_ON_DUEL_REQUEST",                9,   ...) end )
+RegisterServerHook(10,  function(...) print("PLAYER_EVENT_ON_DUEL_START",                  10,  ...) end )
+RegisterServerHook(11,  function(...) print("PLAYER_EVENT_ON_DUEL_END",                    11,  ...) end )
+RegisterServerHook(12,  function(...) print("PLAYER_EVENT_ON_GIVE_XP",                     12,  ...) end )
+RegisterServerHook(13,  function(...) print("PLAYER_EVENT_ON_LEVEL_CHANGE",                13,  ...) end )
+RegisterServerHook(14,  function(...) print("PLAYER_EVENT_ON_MONEY_CHANGE",                14,  ...) end )
+RegisterServerHook(15,  function(...) print("PLAYER_EVENT_ON_REPUTATION_CHANGE",           15,  ...) end )
+RegisterServerHook(16,  function(...) print("PLAYER_EVENT_ON_TALENTS_CHANGE",              16,  ...) end )
+RegisterServerHook(17,  function(...) print("PLAYER_EVENT_ON_TALENTS_RESET",               17,  ...) end )
+RegisterServerHook(18,  function(...) print("PLAYER_EVENT_ON_CHAT",                        18,  ...) end )
+RegisterServerHook(19,  function(...) print("PLAYER_EVENT_ON_WHISPER",                     19,  ...) end )
+RegisterServerHook(20,  function(...) print("PLAYER_EVENT_ON_GROUP_CHAT",                  20,  ...) end )
+RegisterServerHook(21,  function(...) print("PLAYER_EVENT_ON_GUILD_CHAT",                  21,  ...) end )
+RegisterServerHook(22,  function(...) print("PLAYER_EVENT_ON_CHANNEL_CHAT",                22,  ...) end )
+RegisterServerHook(23,  function(...) print("PLAYER_EVENT_ON_EMOTE",                       23,  ...) end )
+RegisterServerHook(24,  function(...) print("PLAYER_EVENT_ON_TEXT_EMOTE",                  24,  ...) end )
+RegisterServerHook(25,  function(...) print("PLAYER_EVENT_ON_SAVE",                        25,  ...) end )
+RegisterServerHook(26,  function(...) print("PLAYER_EVENT_ON_BIND_TO_INSTANCE",            26,  ...) end )
+RegisterServerHook(27,  function(...) print("PLAYER_EVENT_ON_UPDATE_ZONE",                 27,  ...) end )
+RegisterServerHook(28,  function(...) print("PLAYER_EVENT_ON_MAP_CHANGE",                  28,  ...) end )
+RegisterServerHook(29,  function(...) print("GUILD_EVENT_ON_ADD_MEMBER",                   29,  ...) end )
+RegisterServerHook(30,  function(...) print("GUILD_EVENT_ON_REMOVE_MEMBER",                30,  ...) end )
+RegisterServerHook(31,  function(...) print("GUILD_EVENT_ON_MOTD_CHANGE",                  31,  ...) end )
+RegisterServerHook(32,  function(...) print("GUILD_EVENT_ON_INFO_CHANGE",                  32,  ...) end )
+RegisterServerHook(33,  function(...) print("GUILD_EVENT_ON_CREATE",                       33,  ...) end )
+RegisterServerHook(34,  function(...) print("GUILD_EVENT_ON_DISBAND",                      34,  ...) end )
+RegisterServerHook(35,  function(...) print("GUILD_EVENT_ON_MONEY_WITHDRAW",               35,  ...) end )
+RegisterServerHook(36,  function(...) print("GUILD_EVENT_ON_MONEY_DEPOSIT",                36,  ...) end )
+RegisterServerHook(37,  function(...) print("GUILD_EVENT_ON_ITEM_MOVE",                    37,  ...) end )
+RegisterServerHook(38,  function(...) print("GUILD_EVENT_ON_EVENT",                        38,  ...) end )
+RegisterServerHook(39,  function(...) print("GUILD_EVENT_ON_BANK_EVENT",                   39,  ...) end )
+RegisterServerHook(40,  function(...) print("SERVER_EVENT_ON_NETWORK_START",               40,  ...) end )
+RegisterServerHook(41,  function(...) print("SERVER_EVENT_ON_NETWORK_STOP",                41,  ...) end )
+RegisterServerHook(42,  function(...) print("SERVER_EVENT_ON_SOCKET_OPEN",                 42,  ...) end )
+RegisterServerHook(43,  function(...) print("SERVER_EVENT_ON_SOCKET_CLOSE",                43,  ...) end )
+RegisterServerHook(44,  function(...) print("SERVER_EVENT_ON_PACKET_RECEIVE",              44,  ...) end )
+RegisterServerHook(45,  function(...) print("SERVER_EVENT_ON_PACKET_RECEIVE_UNKNOWN",      45,  ...) end )
+RegisterServerHook(46,  function(...) print("SERVER_EVENT_ON_PACKET_SEND",                 46,  ...) end )
+RegisterServerHook(47,  function(...) print("WORLD_EVENT_ON_OPEN_STATE_CHANGE",            47,  ...) end )
+RegisterServerHook(48,  function(...) print("WORLD_EVENT_ON_CONFIG_LOAD",                  48,  ...) end )
+RegisterServerHook(49,  function(...) print("WORLD_EVENT_ON_MOTD_CHANGE",                  49,  ...) end )
+RegisterServerHook(50,  function(...) print("WORLD_EVENT_ON_SHUTDOWN_INIT",                50,  ...) end )
+RegisterServerHook(51,  function(...) print("WORLD_EVENT_ON_SHUTDOWN_CANCEL",              51,  ...) end )
+--RegisterServerHook(52,  function(...) print("WORLD_EVENT_ON_UPDATE",                       52,  ...) end )
+RegisterServerHook(53,  function(...) print("WORLD_EVENT_ON_STARTUP",                      53,  ...) end )
+RegisterServerHook(54,  function(...) print("WORLD_EVENT_ON_SHUTDOWN",                     54,  ...) end )
+RegisterServerHook(55,  function(...) print("ELUNA_EVENT_ON_RESTART",                      55,  ...) end )
+RegisterServerHook(56,  function(...) print("MAP_EVENT_ON_CREATE",                         56,  ...) end )
+RegisterServerHook(57,  function(...) print("MAP_EVENT_ON_DESTROY",                        57,  ...) end )
+RegisterServerHook(58,  function(...) print("MAP_EVENT_ON_LOAD",                           58,  ...) end )
+RegisterServerHook(59,  function(...) print("MAP_EVENT_ON_UNLOAD",                         59,  ...) end )
+RegisterServerHook(60,  function(...) print("MAP_EVENT_ON_PLAYER_ENTER",                   60,  ...) end )
+RegisterServerHook(61,  function(...) print("MAP_EVENT_ON_PLAYER_LEAVE",                   61,  ...) end )
+RegisterServerHook(62,  function(...) print("MAP_EVENT_ON_UPDATE",                         62,  ...) end )
+RegisterServerHook(63,  function(...) print("TRIGGER_EVENT_ON_TRIGGER",                    63,  ...) end )
+RegisterServerHook(64,  function(...) print("WEATHER_EVENT_ON_CHANGE",                     64,  ...) end )
+RegisterServerHook(65,  function(...) print("AUCTION_EVENT_ON_ADD",                        65,  ...) end )
+RegisterServerHook(66,  function(...) print("AUCTION_EVENT_ON_REMOVE",                     66,  ...) end )
+RegisterServerHook(67,  function(...) print("AUCTION_EVENT_ON_SUCCESFUL",                  67,  ...) end )
+RegisterServerHook(68,  function(...) print("AUCTION_EVENT_ON_EXPIRE",                     68,  ...) end )
+RegisterServerHook(69,  function(...) print("GROUP_EVENT_ON_MEMBER_ADD",                   69,  ...) end )
+RegisterServerHook(70,  function(...) print("GROUP_EVENT_ON_MEMBER_INVITE",                70,  ...) end )
+RegisterServerHook(71,  function(...) print("GROUP_EVENT_ON_MEMBER_REMOVE",                71,  ...) end )
+RegisterServerHook(72,  function(...) print("GROUP_EVENT_ON_LEADER_CHANGE",                72,  ...) end )
+RegisterServerHook(73,  function(...) print("GROUP_EVENT_ON_DISBAND",                      73,  ...) end )
\ No newline at end of file
diff --git a/LuaScripts/ServerHooks/server_hooks.lua b/LuaScripts/ServerHooks/server_hooks.lua
new file mode 100644
index 0000000..464a4c1
--- /dev/null
+++ b/LuaScripts/ServerHooks/server_hooks.lua
@@ -0,0 +1,20 @@
+function OnEvents(evt, plr, arg1, _, msg) -- Works
+    if (evt == 2) then
+		print(plr:GetName().." killed "..arg1:GetName())
+    elseif (evt == 16) then
+	    if(msg == "test") then
+			print("FUCKING CHAT")
+		end
+	elseif(evt == 27) then
+		print("I FUCKING LEVELED BROH!")
+	elseif (evt == 34) then
+		print("TALENTS FUCKING CHANGED")
+	end
+end
+
+--RegisterPlayerEvent(5, chat_test)
+
+RegisterServerHook(2, OnEvents)
+RegisterServerHook(16, OnEvents)
+RegisterServerHook(27, OnEvents)
+RegisterServerHook(34, OnEvents)
\ No newline at end of file
diff --git a/dep/CMakeLists.txt b/dep/CMakeLists.txt
index ad5e04c..6629e57 100644
--- a/dep/CMakeLists.txt
+++ b/dep/CMakeLists.txt
@@ -33,6 +33,7 @@ endif()
 
 add_subdirectory(g3dlite)
 add_subdirectory(recastnavigation)
+add_subdirectory(lualib)
 
 if(SERVERS)
   add_subdirectory(gsoap)
diff --git a/dep/lualib/CMakeLists.txt b/dep/lualib/CMakeLists.txt
new file mode 100644
index 0000000..f8ab5f2
--- /dev/null
+++ b/dep/lualib/CMakeLists.txt
@@ -0,0 +1,20 @@
+# Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+file(GLOB sources *.c)
+
+set(lua_STAT_SRCS
+  ${sources}
+)
+
+include_directories(
+  ${CMAKE_CURRENT_SOURCE_DIR}
+)
+
+add_library(lua STATIC ${lua_STAT_SRCS})
\ No newline at end of file
diff --git a/dep/lualib/lapi.c b/dep/lualib/lapi.c
new file mode 100644
index 0000000..1854fe6
--- /dev/null
+++ b/dep/lualib/lapi.c
@@ -0,0 +1,1281 @@
+/*
+** $Id: lapi.c,v 2.164 2012/06/08 15:14:04 roberto Exp $
+** Lua API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <string.h>
+
+#define lapi_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+
+
+
+const char lua_ident[] =
+  "$LuaVersion: " LUA_COPYRIGHT " $"
+  "$LuaAuthors: " LUA_AUTHORS " $";
+
+
+/* value at a non-valid index */
+#define NONVALIDVALUE		cast(TValue *, luaO_nilobject)
+
+/* corresponding test */
+#define isvalid(o)	((o) != luaO_nilobject)
+
+#define api_checkvalidindex(L, i)  api_check(L, isvalid(i), "invalid index")
+
+
+static TValue *index2addr (lua_State *L, int idx) {
+  CallInfo *ci = L->ci;
+  if (idx > 0) {
+    TValue *o = ci->func + idx;
+    api_check(L, idx <= ci->top - (ci->func + 1), "unacceptable index");
+    if (o >= L->top) return NONVALIDVALUE;
+    else return o;
+  }
+  else if (idx > LUA_REGISTRYINDEX) {
+    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
+    return L->top + idx;
+  }
+  else if (idx == LUA_REGISTRYINDEX)
+    return &G(L)->l_registry;
+  else {  /* upvalues */
+    idx = LUA_REGISTRYINDEX - idx;
+    api_check(L, idx <= MAXUPVAL + 1, "upvalue index too large");
+    if (ttislcf(ci->func))  /* light C function? */
+      return NONVALIDVALUE;  /* it has no upvalues */
+    else {
+      CClosure *func = clCvalue(ci->func);
+      return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;
+    }
+  }
+}
+
+
+/*
+** to be called by 'lua_checkstack' in protected mode, to grow stack
+** capturing memory errors
+*/
+static void growstack (lua_State *L, void *ud) {
+  int size = *(int *)ud;
+  luaD_growstack(L, size);
+}
+
+
+LUA_API int lua_checkstack (lua_State *L, int size) {
+  int res;
+  CallInfo *ci = L->ci;
+  lua_lock(L);
+  if (L->stack_last - L->top > size)  /* stack large enough? */
+    res = 1;  /* yes; check is OK */
+  else {  /* no; need to grow stack */
+    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;
+    if (inuse > LUAI_MAXSTACK - size)  /* can grow without overflow? */
+      res = 0;  /* no */
+    else  /* try to grow stack */
+      res = (luaD_rawrunprotected(L, &growstack, &size) == LUA_OK);
+  }
+  if (res && ci->top < L->top + size)
+    ci->top = L->top + size;  /* adjust frame top */
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
+  int i;
+  if (from == to) return;
+  lua_lock(to);
+  api_checknelems(from, n);
+  api_check(from, G(from) == G(to), "moving among independent states");
+  api_check(from, to->ci->top - to->top >= n, "not enough elements to move");
+  from->top -= n;
+  for (i = 0; i < n; i++) {
+    setobj2s(to, to->top++, from->top + i);
+  }
+  lua_unlock(to);
+}
+
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
+  lua_CFunction old;
+  lua_lock(L);
+  old = G(L)->panic;
+  G(L)->panic = panicf;
+  lua_unlock(L);
+  return old;
+}
+
+
+LUA_API const lua_Number *lua_version (lua_State *L) {
+  static const lua_Number version = LUA_VERSION_NUM;
+  if (L == NULL) return &version;
+  else return G(L)->version;
+}
+
+
+
+/*
+** basic stack manipulation
+*/
+
+
+/*
+** convert an acceptable stack index into an absolute index
+*/
+LUA_API int lua_absindex (lua_State *L, int idx) {
+  return (idx > 0 || idx <= LUA_REGISTRYINDEX)
+         ? idx
+         : cast_int(L->top - L->ci->func + idx);
+}
+
+
+LUA_API int lua_gettop (lua_State *L) {
+  return cast_int(L->top - (L->ci->func + 1));
+}
+
+
+LUA_API void lua_settop (lua_State *L, int idx) {
+  StkId func = L->ci->func;
+  lua_lock(L);
+  if (idx >= 0) {
+    api_check(L, idx <= L->stack_last - (func + 1), "new top too large");
+    while (L->top < (func + 1) + idx)
+      setnilvalue(L->top++);
+    L->top = (func + 1) + idx;
+  }
+  else {
+    api_check(L, -(idx+1) <= (L->top - (func + 1)), "invalid new top");
+    L->top += idx+1;  /* `subtract' index (index is negative) */
+  }
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_remove (lua_State *L, int idx) {
+  StkId p;
+  lua_lock(L);
+  p = index2addr(L, idx);
+  api_checkvalidindex(L, p);
+  while (++p < L->top) setobjs2s(L, p-1, p);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_insert (lua_State *L, int idx) {
+  StkId p;
+  StkId q;
+  lua_lock(L);
+  p = index2addr(L, idx);
+  api_checkvalidindex(L, p);
+  for (q = L->top; q>p; q--) setobjs2s(L, q, q-1);
+  setobjs2s(L, p, L->top);
+  lua_unlock(L);
+}
+
+
+static void moveto (lua_State *L, TValue *fr, int idx) {
+  TValue *to = index2addr(L, idx);
+  api_checkvalidindex(L, to);
+  setobj(L, to, fr);
+  if (idx < LUA_REGISTRYINDEX)  /* function upvalue? */
+    luaC_barrier(L, clCvalue(L->ci->func), fr);
+  /* LUA_REGISTRYINDEX does not need gc barrier
+     (collector revisits it before finishing collection) */
+}
+
+
+LUA_API void lua_replace (lua_State *L, int idx) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  moveto(L, L->top - 1, idx);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
+  TValue *fr;
+  lua_lock(L);
+  fr = index2addr(L, fromidx);
+  api_checkvalidindex(L, fr);
+  moveto(L, fr, toidx);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushvalue (lua_State *L, int idx) {
+  lua_lock(L);
+  setobj2s(L, L->top, index2addr(L, idx));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API int lua_type (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (isvalid(o) ? ttypenv(o) : LUA_TNONE);
+}
+
+
+LUA_API const char *lua_typename (lua_State *L, int t) {
+  UNUSED(L);
+  return ttypename(t);
+}
+
+
+LUA_API int lua_iscfunction (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (ttislcf(o) || (ttisCclosure(o)));
+}
+
+
+LUA_API int lua_isnumber (lua_State *L, int idx) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  return tonumber(o, &n);
+}
+
+
+LUA_API int lua_isstring (lua_State *L, int idx) {
+  int t = lua_type(L, idx);
+  return (t == LUA_TSTRING || t == LUA_TNUMBER);
+}
+
+
+LUA_API int lua_isuserdata (lua_State *L, int idx) {
+  const TValue *o = index2addr(L, idx);
+  return (ttisuserdata(o) || ttislightuserdata(o));
+}
+
+
+LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
+  StkId o1 = index2addr(L, index1);
+  StkId o2 = index2addr(L, index2);
+  return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;
+}
+
+
+LUA_API void  lua_arith (lua_State *L, int op) {
+  StkId o1;  /* 1st operand */
+  StkId o2;  /* 2nd operand */
+  lua_lock(L);
+  if (op != LUA_OPUNM) /* all other operations expect two operands */
+    api_checknelems(L, 2);
+  else {  /* for unary minus, add fake 2nd operand */
+    api_checknelems(L, 1);
+    setobjs2s(L, L->top, L->top - 1);
+    L->top++;
+  }
+  o1 = L->top - 2;
+  o2 = L->top - 1;
+  if (ttisnumber(o1) && ttisnumber(o2)) {
+    changenvalue(o1, luaO_arith(op, nvalue(o1), nvalue(o2)));
+  }
+  else
+    luaV_arith(L, o1, o1, o2, cast(TMS, op - LUA_OPADD + TM_ADD));
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {
+  StkId o1, o2;
+  int i = 0;
+  lua_lock(L);  /* may call tag method */
+  o1 = index2addr(L, index1);
+  o2 = index2addr(L, index2);
+  if (isvalid(o1) && isvalid(o2)) {
+    switch (op) {
+      case LUA_OPEQ: i = equalobj(L, o1, o2); break;
+      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;
+      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;
+      default: api_check(L, 0, "invalid option");
+    }
+  }
+  lua_unlock(L);
+  return i;
+}
+
+
+LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    if (isnum) *isnum = 1;
+    return nvalue(o);
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    lua_Integer res;
+    lua_Number num = nvalue(o);
+    lua_number2integer(res, num);
+    if (isnum) *isnum = 1;
+    return res;
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API lua_Unsigned lua_tounsignedx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    lua_Unsigned res;
+    lua_Number num = nvalue(o);
+    lua_number2unsigned(res, num);
+    if (isnum) *isnum = 1;
+    return res;
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API int lua_toboolean (lua_State *L, int idx) {
+  const TValue *o = index2addr(L, idx);
+  return !l_isfalse(o);
+}
+
+
+LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
+  StkId o = index2addr(L, idx);
+  if (!ttisstring(o)) {
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    if (!luaV_tostring(L, o)) {  /* conversion failed? */
+      if (len != NULL) *len = 0;
+      lua_unlock(L);
+      return NULL;
+    }
+    luaC_checkGC(L);
+    o = index2addr(L, idx);  /* previous call may reallocate the stack */
+    lua_unlock(L);
+  }
+  if (len != NULL) *len = tsvalue(o)->len;
+  return svalue(o);
+}
+
+
+LUA_API size_t lua_rawlen (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttypenv(o)) {
+    case LUA_TSTRING: return tsvalue(o)->len;
+    case LUA_TUSERDATA: return uvalue(o)->len;
+    case LUA_TTABLE: return luaH_getn(hvalue(o));
+    default: return 0;
+  }
+}
+
+
+LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  if (ttislcf(o)) return fvalue(o);
+  else if (ttisCclosure(o))
+    return clCvalue(o)->f;
+  else return NULL;  /* not a C function */
+}
+
+
+LUA_API void *lua_touserdata (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttypenv(o)) {
+    case LUA_TUSERDATA: return (rawuvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: return pvalue(o);
+    default: return NULL;
+  }
+}
+
+
+LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (!ttisthread(o)) ? NULL : thvalue(o);
+}
+
+
+LUA_API const void *lua_topointer (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttype(o)) {
+    case LUA_TTABLE: return hvalue(o);
+    case LUA_TLCL: return clLvalue(o);
+    case LUA_TCCL: return clCvalue(o);
+    case LUA_TLCF: return cast(void *, cast(size_t, fvalue(o)));
+    case LUA_TTHREAD: return thvalue(o);
+    case LUA_TUSERDATA:
+    case LUA_TLIGHTUSERDATA:
+      return lua_touserdata(L, idx);
+    default: return NULL;
+  }
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushnil (lua_State *L) {
+  lua_lock(L);
+  setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
+  lua_lock(L);
+  setnvalue(L->top, n);
+  luai_checknum(L, L->top,
+    luaG_runerror(L, "C API - attempt to push a signaling NaN"));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
+  lua_lock(L);
+  setnvalue(L->top, cast_num(n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushunsigned (lua_State *L, lua_Unsigned u) {
+  lua_Number n;
+  lua_lock(L);
+  n = lua_unsigned2number(u);
+  setnvalue(L->top, n);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {
+  TString *ts;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ts = luaS_newlstr(L, s, len);
+  setsvalue2s(L, L->top, ts);
+  api_incr_top(L);
+  lua_unlock(L);
+  return getstr(ts);
+}
+
+
+LUA_API const char *lua_pushstring (lua_State *L, const char *s) {
+  if (s == NULL) {
+    lua_pushnil(L);
+    return NULL;
+  }
+  else {
+    TString *ts;
+    lua_lock(L);
+    luaC_checkGC(L);
+    ts = luaS_new(L, s);
+    setsvalue2s(L, L->top, ts);
+    api_incr_top(L);
+    lua_unlock(L);
+    return getstr(ts);
+  }
+}
+
+
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                      va_list argp) {
+  const char *ret;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *ret;
+  va_list argp;
+  lua_lock(L);
+  luaC_checkGC(L);
+  va_start(argp, fmt);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
+  lua_lock(L);
+  if (n == 0) {
+    setfvalue(L->top, fn);
+  }
+  else {
+    Closure *cl;
+    api_checknelems(L, n);
+    api_check(L, n <= MAXUPVAL, "upvalue index too large");
+    luaC_checkGC(L);
+    cl = luaF_newCclosure(L, n);
+    cl->c.f = fn;
+    L->top -= n;
+    while (n--)
+      setobj2n(L, &cl->c.upvalue[n], L->top + n);
+    setclCvalue(L, L->top, cl);
+  }
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushboolean (lua_State *L, int b) {
+  lua_lock(L);
+  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
+  lua_lock(L);
+  setpvalue(L->top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_pushthread (lua_State *L) {
+  lua_lock(L);
+  setthvalue(L, L->top, L);
+  api_incr_top(L);
+  lua_unlock(L);
+  return (G(L)->mainthread == L);
+}
+
+
+
+/*
+** get functions (Lua -> stack)
+*/
+
+
+LUA_API void lua_getglobal (lua_State *L, const char *var) {
+  Table *reg = hvalue(&G(L)->l_registry);
+  const TValue *gt;  /* global table */
+  lua_lock(L);
+  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+  setsvalue2s(L, L->top++, luaS_new(L, var));
+  luaV_gettable(L, gt, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_gettable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_checkvalidindex(L, t);
+  luaV_gettable(L, t, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_checkvalidindex(L, t);
+  setsvalue2s(L, L->top, luaS_new(L, k));
+  api_incr_top(L);
+  luaV_gettable(L, t, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawget (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2s(L, L->top, luaH_getint(hvalue(t), n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgetp (lua_State *L, int idx, const void *p) {
+  StkId t;
+  TValue k;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setpvalue(&k, cast(void *, p));
+  setobj2s(L, L->top, luaH_get(hvalue(t), &k));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
+  Table *t;
+  lua_lock(L);
+  luaC_checkGC(L);
+  t = luaH_new(L);
+  sethvalue(L, L->top, t);
+  api_incr_top(L);
+  if (narray > 0 || nrec > 0)
+    luaH_resize(L, t, narray, nrec);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_getmetatable (lua_State *L, int objindex) {
+  const TValue *obj;
+  Table *mt = NULL;
+  int res;
+  lua_lock(L);
+  obj = index2addr(L, objindex);
+  switch (ttypenv(obj)) {
+    case LUA_TTABLE:
+      mt = hvalue(obj)->metatable;
+      break;
+    case LUA_TUSERDATA:
+      mt = uvalue(obj)->metatable;
+      break;
+    default:
+      mt = G(L)->mt[ttypenv(obj)];
+      break;
+  }
+  if (mt == NULL)
+    res = 0;
+  else {
+    sethvalue(L, L->top, mt);
+    api_incr_top(L);
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_getuservalue (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  o = index2addr(L, idx);
+  api_checkvalidindex(L, o);
+  api_check(L, ttisuserdata(o), "userdata expected");
+  if (uvalue(o)->env) {
+    sethvalue(L, L->top, uvalue(o)->env);
+  } else
+    setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+/*
+** set functions (stack -> Lua)
+*/
+
+
+LUA_API void lua_setglobal (lua_State *L, const char *var) {
+  Table *reg = hvalue(&G(L)->l_registry);
+  const TValue *gt;  /* global table */
+  lua_lock(L);
+  api_checknelems(L, 1);
+  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+  setsvalue2s(L, L->top++, luaS_new(L, var));
+  luaV_settable(L, gt, L->top - 1, L->top - 2);
+  L->top -= 2;  /* pop value and key */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_settable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = index2addr(L, idx);
+  api_checkvalidindex(L, t);
+  luaV_settable(L, t, L->top - 2, L->top - 1);
+  L->top -= 2;  /* pop index and value */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_checkvalidindex(L, t);
+  setsvalue2s(L, L->top++, luaS_new(L, k));
+  luaV_settable(L, t, L->top - 1, L->top - 2);
+  L->top -= 2;  /* pop value and key */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawset (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2t(L, luaH_set(L, hvalue(t), L->top-2), L->top-1);
+  invalidateTMcache(hvalue(t));
+  luaC_barrierback(L, gcvalue(t), L->top-1);
+  L->top -= 2;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  luaH_setint(L, hvalue(t), n, L->top - 1);
+  luaC_barrierback(L, gcvalue(t), L->top-1);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {
+  StkId t;
+  TValue k;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setpvalue(&k, cast(void *, p));
+  setobj2t(L, luaH_set(L, hvalue(t), &k), L->top - 1);
+  luaC_barrierback(L, gcvalue(t), L->top - 1);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_setmetatable (lua_State *L, int objindex) {
+  TValue *obj;
+  Table *mt;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  obj = index2addr(L, objindex);
+  api_checkvalidindex(L, obj);
+  if (ttisnil(L->top - 1))
+    mt = NULL;
+  else {
+    api_check(L, ttistable(L->top - 1), "table expected");
+    mt = hvalue(L->top - 1);
+  }
+  switch (ttypenv(obj)) {
+    case LUA_TTABLE: {
+      hvalue(obj)->metatable = mt;
+      if (mt)
+        luaC_objbarrierback(L, gcvalue(obj), mt);
+        luaC_checkfinalizer(L, gcvalue(obj), mt);
+      break;
+    }
+    case LUA_TUSERDATA: {
+      uvalue(obj)->metatable = mt;
+      if (mt) {
+        luaC_objbarrier(L, rawuvalue(obj), mt);
+        luaC_checkfinalizer(L, gcvalue(obj), mt);
+      }
+      break;
+    }
+    default: {
+      G(L)->mt[ttypenv(obj)] = mt;
+      break;
+    }
+  }
+  L->top--;
+  lua_unlock(L);
+  return 1;
+}
+
+
+LUA_API void lua_setuservalue (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = index2addr(L, idx);
+  api_checkvalidindex(L, o);
+  api_check(L, ttisuserdata(o), "userdata expected");
+  if (ttisnil(L->top - 1))
+    uvalue(o)->env = NULL;
+  else {
+    api_check(L, ttistable(L->top - 1), "table expected");
+    uvalue(o)->env = hvalue(L->top - 1);
+    luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));
+  }
+  L->top--;
+  lua_unlock(L);
+}
+
+
+/*
+** `load' and `call' functions (run Lua code)
+*/
+
+
+#define checkresults(L,na,nr) \
+     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \
+	"results from function overflow current stack size")
+
+
+LUA_API int lua_getctx (lua_State *L, int *ctx) {
+  if (L->ci->callstatus & CIST_YIELDED) {
+    if (ctx) *ctx = L->ci->u.c.ctx;
+    return L->ci->u.c.status;
+  }
+  else return LUA_OK;
+}
+
+
+LUA_API void lua_callk (lua_State *L, int nargs, int nresults, int ctx,
+                        lua_CFunction k) {
+  StkId func;
+  lua_lock(L);
+  api_check(L, k == NULL || !isLua(L->ci),
+    "cannot use continuations inside hooks");
+  api_checknelems(L, nargs+1);
+  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  checkresults(L, nargs, nresults);
+  func = L->top - (nargs+1);
+  if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */
+    L->ci->u.c.k = k;  /* save continuation */
+    L->ci->u.c.ctx = ctx;  /* save context */
+    luaD_call(L, func, nresults, 1);  /* do the call */
+  }
+  else  /* no continuation or no yieldable */
+    luaD_call(L, func, nresults, 0);  /* just do the call */
+  adjustresults(L, nresults);
+  lua_unlock(L);
+}
+
+
+
+/*
+** Execute a protected call.
+*/
+struct CallS {  /* data to `f_call' */
+  StkId func;
+  int nresults;
+};
+
+
+static void f_call (lua_State *L, void *ud) {
+  struct CallS *c = cast(struct CallS *, ud);
+  luaD_call(L, c->func, c->nresults, 0);
+}
+
+
+
+LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,
+                        int ctx, lua_CFunction k) {
+  struct CallS c;
+  int status;
+  ptrdiff_t func;
+  lua_lock(L);
+  api_check(L, k == NULL || !isLua(L->ci),
+    "cannot use continuations inside hooks");
+  api_checknelems(L, nargs+1);
+  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  checkresults(L, nargs, nresults);
+  if (errfunc == 0)
+    func = 0;
+  else {
+    StkId o = index2addr(L, errfunc);
+    api_checkvalidindex(L, o);
+    func = savestack(L, o);
+  }
+  c.func = L->top - (nargs+1);  /* function to be called */
+  if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */
+    c.nresults = nresults;  /* do a 'conventional' protected call */
+    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
+  }
+  else {  /* prepare continuation (call is already protected by 'resume') */
+    CallInfo *ci = L->ci;
+    ci->u.c.k = k;  /* save continuation */
+    ci->u.c.ctx = ctx;  /* save context */
+    /* save information for error recovery */
+    ci->extra = savestack(L, c.func);
+    ci->u.c.old_allowhook = L->allowhook;
+    ci->u.c.old_errfunc = L->errfunc;
+    L->errfunc = func;
+    /* mark that function may do error recovery */
+    ci->callstatus |= CIST_YPCALL;
+    luaD_call(L, c.func, nresults, 1);  /* do the call */
+    ci->callstatus &= ~CIST_YPCALL;
+    L->errfunc = ci->u.c.old_errfunc;
+    status = LUA_OK;  /* if it is here, there were no errors */
+  }
+  adjustresults(L, nresults);
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
+                      const char *chunkname, const char *mode) {
+  ZIO z;
+  int status;
+  lua_lock(L);
+  if (!chunkname) chunkname = "?";
+  luaZ_init(L, &z, reader, data);
+  status = luaD_protectedparser(L, &z, chunkname, mode);
+  if (status == LUA_OK) {  /* no errors? */
+    LClosure *f = clLvalue(L->top - 1);  /* get newly created function */
+    if (f->nupvalues == 1) {  /* does it have one upvalue? */
+      /* get global table from registry */
+      Table *reg = hvalue(&G(L)->l_registry);
+      const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
+      setobj(L, f->upvals[0]->v, gt);
+      luaC_barrier(L, f->upvals[0], gt);
+    }
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {
+  int status;
+  TValue *o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = L->top - 1;
+  if (isLfunction(o))
+    status = luaU_dump(L, getproto(o), writer, data, 0);
+  else
+    status = 1;
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int  lua_status (lua_State *L) {
+  return L->status;
+}
+
+
+/*
+** Garbage-collection function
+*/
+
+LUA_API int lua_gc (lua_State *L, int what, int data) {
+  int res = 0;
+  global_State *g;
+  lua_lock(L);
+  g = G(L);
+  switch (what) {
+    case LUA_GCSTOP: {
+      g->gcrunning = 0;
+      break;
+    }
+    case LUA_GCRESTART: {
+      luaE_setdebt(g, 0);
+      g->gcrunning = 1;
+      break;
+    }
+    case LUA_GCCOLLECT: {
+      luaC_fullgc(L, 0);
+      break;
+    }
+    case LUA_GCCOUNT: {
+      /* GC values are expressed in Kbytes: #bytes/2^10 */
+      res = cast_int(gettotalbytes(g) >> 10);
+      break;
+    }
+    case LUA_GCCOUNTB: {
+      res = cast_int(gettotalbytes(g) & 0x3ff);
+      break;
+    }
+    case LUA_GCSTEP: {
+      if (g->gckind == KGC_GEN) {  /* generational mode? */
+        res = (g->GCestimate == 0);  /* true if it will do major collection */
+        luaC_forcestep(L);  /* do a single step */
+      }
+      else {
+       lu_mem debt = cast(lu_mem, data) * 1024 - GCSTEPSIZE;
+       if (g->gcrunning)
+         debt += g->GCdebt;  /* include current debt */
+       luaE_setdebt(g, debt);
+       luaC_forcestep(L);
+       if (g->gcstate == GCSpause)  /* end of cycle? */
+         res = 1;  /* signal it */
+      }
+      break;
+    }
+    case LUA_GCSETPAUSE: {
+      res = g->gcpause;
+      g->gcpause = data;
+      break;
+    }
+    case LUA_GCSETMAJORINC: {
+      res = g->gcmajorinc;
+      g->gcmajorinc = data;
+      break;
+    }
+    case LUA_GCSETSTEPMUL: {
+      res = g->gcstepmul;
+      g->gcstepmul = data;
+      break;
+    }
+    case LUA_GCISRUNNING: {
+      res = g->gcrunning;
+      break;
+    }
+    case LUA_GCGEN: {  /* change collector to generational mode */
+      luaC_changemode(L, KGC_GEN);
+      break;
+    }
+    case LUA_GCINC: {  /* change collector to incremental mode */
+      luaC_changemode(L, KGC_NORMAL);
+      break;
+    }
+    default: res = -1;  /* invalid option */
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+
+/*
+** miscellaneous functions
+*/
+
+
+LUA_API int lua_error (lua_State *L) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  luaG_errormsg(L);
+  lua_unlock(L);
+  return 0;  /* to avoid warnings */
+}
+
+
+LUA_API int lua_next (lua_State *L, int idx) {
+  StkId t;
+  int more;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  more = luaH_next(L, hvalue(t), L->top - 1);
+  if (more) {
+    api_incr_top(L);
+  }
+  else  /* no more elements */
+    L->top -= 1;  /* remove key */
+  lua_unlock(L);
+  return more;
+}
+
+
+LUA_API void lua_concat (lua_State *L, int n) {
+  lua_lock(L);
+  api_checknelems(L, n);
+  if (n >= 2) {
+    luaC_checkGC(L);
+    luaV_concat(L, n);
+  }
+  else if (n == 0) {  /* push empty string */
+    setsvalue2s(L, L->top, luaS_newlstr(L, "", 0));
+    api_incr_top(L);
+  }
+  /* else n == 1; nothing to do */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_len (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  luaV_objlen(L, L->top, t);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
+  lua_Alloc f;
+  lua_lock(L);
+  if (ud) *ud = G(L)->ud;
+  f = G(L)->frealloc;
+  lua_unlock(L);
+  return f;
+}
+
+
+LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
+  lua_lock(L);
+  G(L)->ud = ud;
+  G(L)->frealloc = f;
+  lua_unlock(L);
+}
+
+
+LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
+  Udata *u;
+  lua_lock(L);
+  luaC_checkGC(L);
+  u = luaS_newudata(L, size, NULL);
+  setuvalue(L, L->top, u);
+  api_incr_top(L);
+  lua_unlock(L);
+  return u + 1;
+}
+
+
+
+static const char *aux_upvalue (StkId fi, int n, TValue **val,
+                                GCObject **owner) {
+  switch (ttype(fi)) {
+    case LUA_TCCL: {  /* C closure */
+      CClosure *f = clCvalue(fi);
+      if (!(1 <= n && n <= f->nupvalues)) return NULL;
+      *val = &f->upvalue[n-1];
+      if (owner) *owner = obj2gco(f);
+      return "";
+    }
+    case LUA_TLCL: {  /* Lua closure */
+      LClosure *f = clLvalue(fi);
+      TString *name;
+      Proto *p = f->p;
+      if (!(1 <= n && n <= p->sizeupvalues)) return NULL;
+      *val = f->upvals[n-1]->v;
+      if (owner) *owner = obj2gco(f->upvals[n - 1]);
+      name = p->upvalues[n-1].name;
+      return (name == NULL) ? "" : getstr(name);
+    }
+    default: return NULL;  /* not a closure */
+  }
+}
+
+
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TValue *val = NULL;  /* to avoid warnings */
+  lua_lock(L);
+  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL);
+  if (name) {
+    setobj2s(L, L->top, val);
+    api_incr_top(L);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TValue *val = NULL;  /* to avoid warnings */
+  GCObject *owner = NULL;  /* to avoid warnings */
+  StkId fi;
+  lua_lock(L);
+  fi = index2addr(L, funcindex);
+  api_checknelems(L, 1);
+  name = aux_upvalue(fi, n, &val, &owner);
+  if (name) {
+    L->top--;
+    setobj(L, val, L->top);
+    luaC_barrier(L, owner, L->top);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
+  LClosure *f;
+  StkId fi = index2addr(L, fidx);
+  api_check(L, ttisLclosure(fi), "Lua function expected");
+  f = clLvalue(fi);
+  api_check(L, (1 <= n && n <= f->p->sizeupvalues), "invalid upvalue index");
+  if (pf) *pf = f;
+  return &f->upvals[n - 1];  /* get its upvalue pointer */
+}
+
+
+LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {
+  StkId fi = index2addr(L, fidx);
+  switch (ttype(fi)) {
+    case LUA_TLCL: {  /* lua closure */
+      return *getupvalref(L, fidx, n, NULL);
+    }
+    case LUA_TCCL: {  /* C closure */
+      CClosure *f = clCvalue(fi);
+      api_check(L, 1 <= n && n <= f->nupvalues, "invalid upvalue index");
+      return &f->upvalue[n - 1];
+    }
+    default: {
+      api_check(L, 0, "closure expected");
+      return NULL;
+    }
+  }
+}
+
+
+LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
+                                            int fidx2, int n2) {
+  LClosure *f1;
+  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
+  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
+  *up1 = *up2;
+  luaC_objbarrier(L, f1, *up2);
+}
+
diff --git a/dep/lualib/lapi.h b/dep/lualib/lapi.h
new file mode 100644
index 0000000..0909a39
--- /dev/null
+++ b/dep/lualib/lapi.h
@@ -0,0 +1,24 @@
+/*
+** $Id: lapi.h,v 2.7 2009/11/27 15:37:59 roberto Exp $
+** Auxiliary functions from Lua API
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lapi_h
+#define lapi_h
+
+
+#include "llimits.h"
+#include "lstate.h"
+
+#define api_incr_top(L)   {L->top++; api_check(L, L->top <= L->ci->top, \
+				"stack overflow");}
+
+#define adjustresults(L,nres) \
+    { if ((nres) == LUA_MULTRET && L->ci->top < L->top) L->ci->top = L->top; }
+
+#define api_checknelems(L,n)	api_check(L, (n) < (L->top - L->ci->func), \
+				  "not enough elements in the stack")
+
+
+#endif
diff --git a/dep/lualib/lauxlib.c b/dep/lualib/lauxlib.c
new file mode 100644
index 0000000..36ae7e6
--- /dev/null
+++ b/dep/lualib/lauxlib.c
@@ -0,0 +1,958 @@
+/*
+** $Id: lauxlib.c,v 1.244 2012/05/31 20:28:45 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+/* This file uses only the official API of Lua.
+** Any function declared here could be written as an application function.
+*/
+
+#define lauxlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+
+
+/*
+** {======================================================
+** Traceback
+** =======================================================
+*/
+
+
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+
+
+
+/*
+** search for 'objidx' in table at index -1.
+** return 1 + string at top if find a good name.
+*/
+static int findfield (lua_State *L, int objidx, int level) {
+  if (level == 0 || !lua_istable(L, -1))
+    return 0;  /* not found */
+  lua_pushnil(L);  /* start 'next' loop */
+  while (lua_next(L, -2)) {  /* for each pair in table */
+    if (lua_type(L, -2) == LUA_TSTRING) {  /* ignore non-string keys */
+      if (lua_rawequal(L, objidx, -1)) {  /* found object? */
+        lua_pop(L, 1);  /* remove value (but keep name) */
+        return 1;
+      }
+      else if (findfield(L, objidx, level - 1)) {  /* try recursively */
+        lua_remove(L, -2);  /* remove table (but keep name) */
+        lua_pushliteral(L, ".");
+        lua_insert(L, -2);  /* place '.' between the two names */
+        lua_concat(L, 3);
+        return 1;
+      }
+    }
+    lua_pop(L, 1);  /* remove value */
+  }
+  return 0;  /* not found */
+}
+
+
+static int pushglobalfuncname (lua_State *L, lua_Debug *ar) {
+  int top = lua_gettop(L);
+  lua_getinfo(L, "f", ar);  /* push function */
+  lua_pushglobaltable(L);
+  if (findfield(L, top + 1, 2)) {
+    lua_copy(L, -1, top + 1);  /* move name to proper place */
+    lua_pop(L, 2);  /* remove pushed values */
+    return 1;
+  }
+  else {
+    lua_settop(L, top);  /* remove function and global table */
+    return 0;
+  }
+}
+
+
+static void pushfuncname (lua_State *L, lua_Debug *ar) {
+  if (*ar->namewhat != '\0')  /* is there a name? */
+    lua_pushfstring(L, "function " LUA_QS, ar->name);
+  else if (*ar->what == 'm')  /* main? */
+      lua_pushfstring(L, "main chunk");
+  else if (*ar->what == 'C') {
+    if (pushglobalfuncname(L, ar)) {
+      lua_pushfstring(L, "function " LUA_QS, lua_tostring(L, -1));
+      lua_remove(L, -2);  /* remove name */
+    }
+    else
+      lua_pushliteral(L, "?");
+  }
+  else
+    lua_pushfstring(L, "function <%s:%d>", ar->short_src, ar->linedefined);
+}
+
+
+static int countlevels (lua_State *L) {
+  lua_Debug ar;
+  int li = 1, le = 1;
+  /* find an upper bound */
+  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }
+  /* do a binary search */
+  while (li < le) {
+    int m = (li + le)/2;
+    if (lua_getstack(L, m, &ar)) li = m + 1;
+    else le = m;
+  }
+  return le - 1;
+}
+
+
+LUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,
+                                const char *msg, int level) {
+  lua_Debug ar;
+  int top = lua_gettop(L);
+  int numlevels = countlevels(L1);
+  int mark = (numlevels > LEVELS1 + LEVELS2) ? LEVELS1 : 0;
+  if (msg) lua_pushfstring(L, "%s\n", msg);
+  lua_pushliteral(L, "stack traceback:");
+  while (lua_getstack(L1, level++, &ar)) {
+    if (level == mark) {  /* too many levels? */
+      lua_pushliteral(L, "\n\t...");  /* add a '...' */
+      level = numlevels - LEVELS2;  /* and skip to last ones */
+    }
+    else {
+      lua_getinfo(L1, "Slnt", &ar);
+      lua_pushfstring(L, "\n\t%s:", ar.short_src);
+      if (ar.currentline > 0)
+        lua_pushfstring(L, "%d:", ar.currentline);
+      lua_pushliteral(L, " in ");
+      pushfuncname(L, &ar);
+      if (ar.istailcall)
+        lua_pushliteral(L, "\n\t(...tail calls...)");
+      lua_concat(L, lua_gettop(L) - top);
+    }
+  }
+  lua_concat(L, lua_gettop(L) - top);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Error-report functions
+** =======================================================
+*/
+
+LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+  lua_Debug ar;
+  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
+    return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
+  lua_getinfo(L, "n", &ar);
+  if (strcmp(ar.namewhat, "method") == 0) {
+    narg--;  /* do not count `self' */
+    if (narg == 0)  /* error is in the self argument itself? */
+      return luaL_error(L, "calling " LUA_QS " on bad self", ar.name);
+  }
+  if (ar.name == NULL)
+    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : "?";
+  return luaL_error(L, "bad argument #%d to " LUA_QS " (%s)",
+                        narg, ar.name, extramsg);
+}
+
+
+static int typeerror (lua_State *L, int narg, const char *tname) {
+  const char *msg = lua_pushfstring(L, "%s expected, got %s",
+                                    tname, luaL_typename(L, narg));
+  return luaL_argerror(L, narg, msg);
+}
+
+
+static void tag_error (lua_State *L, int narg, int tag) {
+  typeerror(L, narg, lua_typename(L, tag));
+}
+
+
+LUALIB_API void luaL_where (lua_State *L, int level) {
+  lua_Debug ar;
+  if (lua_getstack(L, level, &ar)) {  /* check function at level */
+    lua_getinfo(L, "Sl", &ar);  /* get info about it */
+    if (ar.currentline > 0) {  /* is there info? */
+      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
+      return;
+    }
+  }
+  lua_pushliteral(L, "");  /* else, no information available... */
+}
+
+
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  luaL_where(L, 1);
+  lua_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_concat(L, 2);
+  return lua_error(L);
+}
+
+
+LUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {
+  int en = errno;  /* calls to Lua API may change this value */
+  if (stat) {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+  else {
+    lua_pushnil(L);
+    if (fname)
+      lua_pushfstring(L, "%s: %s", fname, strerror(en));
+    else
+      lua_pushfstring(L, "%s", strerror(en));
+    lua_pushinteger(L, en);
+    return 3;
+  }
+}
+
+
+#if !defined(inspectstat)	/* { */
+
+#if defined(LUA_USE_POSIX)
+
+#include <sys/wait.h>
+
+/*
+** use appropriate macros to interpret 'pclose' return status
+*/
+#define inspectstat(stat,what)  \
+   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \
+   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = "signal"; }
+
+#else
+
+#define inspectstat(stat,what)  /* no op */
+
+#endif
+
+#endif				/* } */
+
+
+LUALIB_API int luaL_execresult (lua_State *L, int stat) {
+  const char *what = "exit";  /* type of termination */
+  if (stat == -1)  /* error? */
+    return luaL_fileresult(L, 0, NULL);
+  else {
+    inspectstat(stat, what);  /* interpret result */
+    if (*what == 'e' && stat == 0)  /* successful termination? */
+      lua_pushboolean(L, 1);
+    else
+      lua_pushnil(L);
+    lua_pushstring(L, what);
+    lua_pushinteger(L, stat);
+    return 3;  /* return true/nil,what,code */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Userdata's metatable manipulation
+** =======================================================
+*/
+
+LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
+  luaL_getmetatable(L, tname);  /* try to get metatable */
+  if (!lua_isnil(L, -1))  /* name already in use? */
+    return 0;  /* leave previous value on top, but return 0 */
+  lua_pop(L, 1);
+  lua_newtable(L);  /* create metatable */
+  lua_pushvalue(L, -1);
+  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
+  return 1;
+}
+
+
+LUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {
+  luaL_getmetatable(L, tname);
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {
+  void *p = lua_touserdata(L, ud);
+  if (p != NULL) {  /* value is a userdata? */
+    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
+      luaL_getmetatable(L, tname);  /* get correct metatable */
+      if (!lua_rawequal(L, -1, -2))  /* not the same? */
+        p = NULL;  /* value is a userdata with wrong metatable */
+      lua_pop(L, 2);  /* remove both metatables */
+      return p;
+    }
+  }
+  return NULL;  /* value is not a userdata with a metatable */
+}
+
+
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
+  void *p = luaL_testudata(L, ud, tname);
+  if (p == NULL) typeerror(L, ud, tname);
+  return p;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Argument check functions
+** =======================================================
+*/
+
+LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
+                                 const char *const lst[]) {
+  const char *name = (def) ? luaL_optstring(L, narg, def) :
+                             luaL_checkstring(L, narg);
+  int i;
+  for (i=0; lst[i]; i++)
+    if (strcmp(lst[i], name) == 0)
+      return i;
+  return luaL_argerror(L, narg,
+                       lua_pushfstring(L, "invalid option " LUA_QS, name));
+}
+
+
+LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {
+  /* keep some extra space to run error routines, if needed */
+  const int extra = LUA_MINSTACK;
+  if (!lua_checkstack(L, space + extra)) {
+    if (msg)
+      luaL_error(L, "stack overflow (%s)", msg);
+    else
+      luaL_error(L, "stack overflow");
+  }
+}
+
+
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
+  if (lua_type(L, narg) != t)
+    tag_error(L, narg, t);
+}
+
+
+LUALIB_API void luaL_checkany (lua_State *L, int narg) {
+  if (lua_type(L, narg) == LUA_TNONE)
+    luaL_argerror(L, narg, "value expected");
+}
+
+
+LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
+  const char *s = lua_tolstring(L, narg, len);
+  if (!s) tag_error(L, narg, LUA_TSTRING);
+  return s;
+}
+
+
+LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
+                                        const char *def, size_t *len) {
+  if (lua_isnoneornil(L, narg)) {
+    if (len)
+      *len = (def ? strlen(def) : 0);
+    return def;
+  }
+  else return luaL_checklstring(L, narg, len);
+}
+
+
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+  int isnum;
+  lua_Number d = lua_tonumberx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  return luaL_opt(L, luaL_checknumber, narg, def);
+}
+
+
+LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
+  int isnum;
+  lua_Integer d = lua_tointegerx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Unsigned luaL_checkunsigned (lua_State *L, int narg) {
+  int isnum;
+  lua_Unsigned d = lua_tounsignedx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,
+                                                      lua_Integer def) {
+  return luaL_opt(L, luaL_checkinteger, narg, def);
+}
+
+
+LUALIB_API lua_Unsigned luaL_optunsigned (lua_State *L, int narg,
+                                                        lua_Unsigned def) {
+  return luaL_opt(L, luaL_checkunsigned, narg, def);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+/*
+** check whether buffer is using a userdata on the stack as a temporary
+** buffer
+*/
+#define buffonstack(B)	((B)->b != (B)->initb)
+
+
+/*
+** returns a pointer to a free area with at least 'sz' bytes
+*/
+LUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {
+  lua_State *L = B->L;
+  if (B->size - B->n < sz) {  /* not enough space? */
+    char *newbuff;
+    size_t newsize = B->size * 2;  /* double buffer size */
+    if (newsize - B->n < sz)  /* not bit enough? */
+      newsize = B->n + sz;
+    if (newsize < B->n || newsize - B->n < sz)
+      luaL_error(L, "buffer too large");
+    /* create larger buffer */
+    newbuff = (char *)lua_newuserdata(L, newsize * sizeof(char));
+    /* move content to new buffer */
+    memcpy(newbuff, B->b, B->n * sizeof(char));
+    if (buffonstack(B))
+      lua_remove(L, -2);  /* remove old buffer */
+    B->b = newbuff;
+    B->size = newsize;
+  }
+  return &B->b[B->n];
+}
+
+
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
+  char *b = luaL_prepbuffsize(B, l);
+  memcpy(b, s, l * sizeof(char));
+  luaL_addsize(B, l);
+}
+
+
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
+  luaL_addlstring(B, s, strlen(s));
+}
+
+
+LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  lua_pushlstring(L, B->b, B->n);
+  if (buffonstack(B))
+    lua_remove(L, -2);  /* remove old buffer */
+}
+
+
+LUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {
+  luaL_addsize(B, sz);
+  luaL_pushresult(B);
+}
+
+
+LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  size_t l;
+  const char *s = lua_tolstring(L, -1, &l);
+  if (buffonstack(B))
+    lua_insert(L, -2);  /* put value below buffer */
+  luaL_addlstring(B, s, l);
+  lua_remove(L, (buffonstack(B)) ? -2 : -1);  /* remove value */
+}
+
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
+  B->L = L;
+  B->b = B->initb;
+  B->n = 0;
+  B->size = LUAL_BUFFERSIZE;
+}
+
+
+LUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {
+  luaL_buffinit(L, B);
+  return luaL_prepbuffsize(B, sz);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Reference system
+** =======================================================
+*/
+
+/* index of free-list header */
+#define freelist	0
+
+
+LUALIB_API int luaL_ref (lua_State *L, int t) {
+  int ref;
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* remove from stack */
+    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
+  }
+  t = lua_absindex(L, t);
+  lua_rawgeti(L, t, freelist);  /* get first free element */
+  ref = (int)lua_tointeger(L, -1);  /* ref = t[freelist] */
+  lua_pop(L, 1);  /* remove it from stack */
+  if (ref != 0) {  /* any free element? */
+    lua_rawgeti(L, t, ref);  /* remove it from list */
+    lua_rawseti(L, t, freelist);  /* (t[freelist] = t[ref]) */
+  }
+  else  /* no free elements */
+    ref = (int)lua_rawlen(L, t) + 1;  /* get a new reference */
+  lua_rawseti(L, t, ref);
+  return ref;
+}
+
+
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
+  if (ref >= 0) {
+    t = lua_absindex(L, t);
+    lua_rawgeti(L, t, freelist);
+    lua_rawseti(L, t, ref);  /* t[ref] = t[freelist] */
+    lua_pushinteger(L, ref);
+    lua_rawseti(L, t, freelist);  /* t[freelist] = ref */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Load functions
+** =======================================================
+*/
+
+typedef struct LoadF {
+  int n;  /* number of pre-read characters */
+  FILE *f;  /* file being read */
+  char buff[LUAL_BUFFERSIZE];  /* area for reading file */
+} LoadF;
+
+
+static const char *getF (lua_State *L, void *ud, size_t *size) {
+  LoadF *lf = (LoadF *)ud;
+  (void)L;  /* not used */
+  if (lf->n > 0) {  /* are there pre-read characters to be read? */
+    *size = lf->n;  /* return them (chars already in buffer) */
+    lf->n = 0;  /* no more pre-read characters */
+  }
+  else {  /* read a block from file */
+    /* 'fread' can return > 0 *and* set the EOF flag. If next call to
+       'getF' called 'fread', it might still wait for user input.
+       The next check avoids this problem. */
+    if (feof(lf->f)) return NULL;
+    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */
+  }
+  return lf->buff;
+}
+
+
+static int errfile (lua_State *L, const char *what, int fnameindex) {
+  const char *serr = strerror(errno);
+  const char *filename = lua_tostring(L, fnameindex) + 1;
+  lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
+  lua_remove(L, fnameindex);
+  return LUA_ERRFILE;
+}
+
+
+static int skipBOM (LoadF *lf) {
+  const char *p = "\xEF\xBB\xBF";  /* Utf8 BOM mark */
+  int c;
+  lf->n = 0;
+  do {
+    c = getc(lf->f);
+    if (c == EOF || c != *(unsigned char *)p++) return c;
+    lf->buff[lf->n++] = c;  /* to be read by the parser */
+  } while (*p != '\0');
+  lf->n = 0;  /* prefix matched; discard it */
+  return getc(lf->f);  /* return next character */
+}
+
+
+/*
+** reads the first character of file 'f' and skips an optional BOM mark
+** in its beginning plus its first line if it starts with '#'. Returns
+** true if it skipped the first line.  In any case, '*cp' has the
+** first "valid" character of the file (after the optional BOM and
+** a first-line comment).
+*/
+static int skipcomment (LoadF *lf, int *cp) {
+  int c = *cp = skipBOM(lf);
+  if (c == '#') {  /* first line is a comment (Unix exec. file)? */
+    do {  /* skip first line */
+      c = getc(lf->f);
+    } while (c != EOF && c != '\n') ;
+    *cp = getc(lf->f);  /* skip end-of-line, if present */
+    return 1;  /* there was a comment */
+  }
+  else return 0;  /* no comment */
+}
+
+
+LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,
+                                             const char *mode) {
+  LoadF lf;
+  int status, readstatus;
+  int c;
+  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
+  if (filename == NULL) {
+    lua_pushliteral(L, "=stdin");
+    lf.f = stdin;
+  }
+  else {
+    lua_pushfstring(L, "@%s", filename);
+    lf.f = fopen(filename, "r");
+    if (lf.f == NULL) return errfile(L, "open", fnameindex);
+  }
+  if (skipcomment(&lf, &c))  /* read initial portion */
+    lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
+  if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
+    lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
+    if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
+    skipcomment(&lf, &c);  /* re-read initial portion */
+  }
+  if (c != EOF)
+    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
+  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
+  readstatus = ferror(lf.f);
+  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
+  if (readstatus) {
+    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
+    return errfile(L, "read", fnameindex);
+  }
+  lua_remove(L, fnameindex);
+  return status;
+}
+
+
+typedef struct LoadS {
+  const char *s;
+  size_t size;
+} LoadS;
+
+
+static const char *getS (lua_State *L, void *ud, size_t *size) {
+  LoadS *ls = (LoadS *)ud;
+  (void)L;  /* not used */
+  if (ls->size == 0) return NULL;
+  *size = ls->size;
+  ls->size = 0;
+  return ls->s;
+}
+
+
+LUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,
+                                 const char *name, const char *mode) {
+  LoadS ls;
+  ls.s = buff;
+  ls.size = size;
+  return lua_load(L, getS, &ls, name, mode);
+}
+
+
+LUALIB_API int luaL_loadstring (lua_State *L, const char *s) {
+  return luaL_loadbuffer(L, s, strlen(s), s);
+}
+
+/* }====================================================== */
+
+
+
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
+  if (!lua_getmetatable(L, obj))  /* no metatable? */
+    return 0;
+  lua_pushstring(L, event);
+  lua_rawget(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);  /* remove metatable and metafield */
+    return 0;
+  }
+  else {
+    lua_remove(L, -2);  /* remove only metatable */
+    return 1;
+  }
+}
+
+
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
+  obj = lua_absindex(L, obj);
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+    return 0;
+  lua_pushvalue(L, obj);
+  lua_call(L, 1, 1);
+  return 1;
+}
+
+
+LUALIB_API int luaL_len (lua_State *L, int idx) {
+  int l;
+  int isnum;
+  lua_len(L, idx);
+  l = (int)lua_tointegerx(L, -1, &isnum);
+  if (!isnum)
+    luaL_error(L, "object length is not a number");
+  lua_pop(L, 1);  /* remove object */
+  return l;
+}
+
+
+LUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {
+  if (!luaL_callmeta(L, idx, "__tostring")) {  /* no metafield? */
+    switch (lua_type(L, idx)) {
+      case LUA_TNUMBER:
+      case LUA_TSTRING:
+        lua_pushvalue(L, idx);
+        break;
+      case LUA_TBOOLEAN:
+        lua_pushstring(L, (lua_toboolean(L, idx) ? "true" : "false"));
+        break;
+      case LUA_TNIL:
+        lua_pushliteral(L, "nil");
+        break;
+      default:
+        lua_pushfstring(L, "%s: %p", luaL_typename(L, idx),
+                                            lua_topointer(L, idx));
+        break;
+    }
+  }
+  return lua_tolstring(L, -1, len);
+}
+
+
+/*
+** {======================================================
+** Compatibility with 5.1 module functions
+** =======================================================
+*/
+#if defined(LUA_COMPAT_MODULE)
+
+static const char *luaL_findtable (lua_State *L, int idx,
+                                   const char *fname, int szhint) {
+  const char *e;
+  if (idx) lua_pushvalue(L, idx);
+  do {
+    e = strchr(fname, '.');
+    if (e == NULL) e = fname + strlen(fname);
+    lua_pushlstring(L, fname, e - fname);
+    lua_rawget(L, -2);
+    if (lua_isnil(L, -1)) {  /* no such field? */
+      lua_pop(L, 1);  /* remove this nil */
+      lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */
+      lua_pushlstring(L, fname, e - fname);
+      lua_pushvalue(L, -2);
+      lua_settable(L, -4);  /* set new table into field */
+    }
+    else if (!lua_istable(L, -1)) {  /* field has a non-table value? */
+      lua_pop(L, 2);  /* remove table and value */
+      return fname;  /* return problematic part of the name */
+    }
+    lua_remove(L, -2);  /* remove previous table */
+    fname = e + 1;
+  } while (*e == '.');
+  return NULL;
+}
+
+
+/*
+** Count number of elements in a luaL_Reg list.
+*/
+static int libsize (const luaL_Reg *l) {
+  int size = 0;
+  for (; l && l->name; l++) size++;
+  return size;
+}
+
+
+/*
+** Find or create a module table with a given name. The function
+** first looks at the _LOADED table and, if that fails, try a
+** global variable with that name. In any case, leaves on the stack
+** the module table.
+*/
+LUALIB_API void luaL_pushmodule (lua_State *L, const char *modname,
+                                 int sizehint) {
+  luaL_findtable(L, LUA_REGISTRYINDEX, "_LOADED", 1);  /* get _LOADED table */
+  lua_getfield(L, -1, modname);  /* get _LOADED[modname] */
+  if (!lua_istable(L, -1)) {  /* not found? */
+    lua_pop(L, 1);  /* remove previous result */
+    /* try global variable (and create one if it does not exist) */
+    lua_pushglobaltable(L);
+    if (luaL_findtable(L, 0, modname, sizehint) != NULL)
+      luaL_error(L, "name conflict for module " LUA_QS, modname);
+    lua_pushvalue(L, -1);
+    lua_setfield(L, -3, modname);  /* _LOADED[modname] = new table */
+  }
+  lua_remove(L, -2);  /* remove _LOADED table */
+}
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                               const luaL_Reg *l, int nup) {
+  luaL_checkversion(L);
+  if (libname) {
+    luaL_pushmodule(L, libname, libsize(l));  /* get/create library table */
+    lua_insert(L, -(nup + 1));  /* move library table to below upvalues */
+  }
+  if (l)
+    luaL_setfuncs(L, l, nup);
+  else
+    lua_pop(L, nup);  /* remove upvalues */
+}
+
+#endif
+/* }====================================================== */
+
+/*
+** set functions from list 'l' into table at top - 'nup'; each
+** function gets the 'nup' elements at the top as upvalues.
+** Returns with only the table at the stack.
+*/
+LUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {
+  luaL_checkversion(L);
+  luaL_checkstack(L, nup, "too many upvalues");
+  for (; l->name != NULL; l++) {  /* fill the table with given functions */
+    int i;
+    for (i = 0; i < nup; i++)  /* copy upvalues to the top */
+      lua_pushvalue(L, -nup);
+    lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */
+    lua_setfield(L, -(nup + 2), l->name);
+  }
+  lua_pop(L, nup);  /* remove upvalues */
+}
+
+
+/*
+** ensure that stack[idx][fname] has a table and push that table
+** into the stack
+*/
+LUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {
+  lua_getfield(L, idx, fname);
+  if (lua_istable(L, -1)) return 1;  /* table already there */
+  else {
+    lua_pop(L, 1);  /* remove previous result */
+    idx = lua_absindex(L, idx);
+    lua_newtable(L);
+    lua_pushvalue(L, -1);  /* copy to be left at top */
+    lua_setfield(L, idx, fname);  /* assign new table to field */
+    return 0;  /* false, because did not find table there */
+  }
+}
+
+
+/*
+** stripped-down 'require'. Calls 'openf' to open a module,
+** registers the result in 'package.loaded' table and, if 'glb'
+** is true, also registers the result in the global table.
+** Leaves resulting module on the top.
+*/
+LUALIB_API void luaL_requiref (lua_State *L, const char *modname,
+                               lua_CFunction openf, int glb) {
+  lua_pushcfunction(L, openf);
+  lua_pushstring(L, modname);  /* argument to open function */
+  lua_call(L, 1, 1);  /* open module */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_pushvalue(L, -2);  /* make copy of module (call result) */
+  lua_setfield(L, -2, modname);  /* _LOADED[modname] = module */
+  lua_pop(L, 1);  /* remove _LOADED table */
+  if (glb) {
+    lua_pushvalue(L, -1);  /* copy of 'mod' */
+    lua_setglobal(L, modname);  /* _G[modname] = module */
+  }
+}
+
+
+LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
+                                                               const char *r) {
+  const char *wild;
+  size_t l = strlen(p);
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while ((wild = strstr(s, p)) != NULL) {
+    luaL_addlstring(&b, s, wild - s);  /* push prefix */
+    luaL_addstring(&b, r);  /* push replacement in place of pattern */
+    s = wild + l;  /* continue after `p' */
+  }
+  luaL_addstring(&b, s);  /* push last suffix */
+  luaL_pushresult(&b);
+  return lua_tostring(L, -1);
+}
+
+
+static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
+  (void)ud; (void)osize;  /* not used */
+  if (nsize == 0) {
+    free(ptr);
+    return NULL;
+  }
+  else
+    return realloc(ptr, nsize);
+}
+
+
+static int panic (lua_State *L) {
+  luai_writestringerror("PANIC: unprotected error in call to Lua API (%s)\n",
+                   lua_tostring(L, -1));
+  return 0;  /* return to Lua to abort */
+}
+
+
+LUALIB_API lua_State *luaL_newstate (void) {
+  lua_State *L = lua_newstate(l_alloc, NULL);
+  if (L) lua_atpanic(L, &panic);
+  return L;
+}
+
+
+LUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver) {
+  const lua_Number *v = lua_version(L);
+  if (v != lua_version(NULL))
+    luaL_error(L, "multiple Lua VMs detected");
+  else if (*v != ver)
+    luaL_error(L, "version mismatch: app. needs %f, Lua core provides %f",
+                  ver, *v);
+  /* check conversions number -> integer types */
+  lua_pushnumber(L, -(lua_Number)0x1234);
+  if (lua_tointeger(L, -1) != -0x1234 ||
+      lua_tounsigned(L, -1) != (lua_Unsigned)-0x1234)
+    luaL_error(L, "bad conversion number->int;"
+                  " must recompile Lua with proper settings");
+  lua_pop(L, 1);
+}
+
diff --git a/dep/lualib/lauxlib.h b/dep/lualib/lauxlib.h
new file mode 100644
index 0000000..7aba289
--- /dev/null
+++ b/dep/lualib/lauxlib.h
@@ -0,0 +1,214 @@
+/*
+** $Id: lauxlib.h,v 1.120 2011/11/29 15:55:08 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lauxlib_h
+#define lauxlib_h
+
+
+#include <stddef.h>
+#include <stdio.h>
+
+#include "lua.h"
+
+
+
+/* extra error code for `luaL_load' */
+#define LUA_ERRFILE     (LUA_ERRERR+1)
+
+
+typedef struct luaL_Reg {
+  const char *name;
+  lua_CFunction func;
+} luaL_Reg;
+
+
+LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver);
+#define luaL_checkversion(L)	luaL_checkversion_(L, LUA_VERSION_NUM)
+
+LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
+LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
+LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
+LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
+LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
+                                                          size_t *l);
+LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
+                                          const char *def, size_t *l);
+LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
+LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);
+
+LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
+LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
+                                          lua_Integer def);
+LUALIB_API lua_Unsigned (luaL_checkunsigned) (lua_State *L, int numArg);
+LUALIB_API lua_Unsigned (luaL_optunsigned) (lua_State *L, int numArg,
+                                            lua_Unsigned def);
+
+LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
+LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
+LUALIB_API void (luaL_checkany) (lua_State *L, int narg);
+
+LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
+LUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);
+LUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
+LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);
+
+LUALIB_API void (luaL_where) (lua_State *L, int lvl);
+LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);
+
+LUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,
+                                   const char *const lst[]);
+
+LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
+LUALIB_API int (luaL_execresult) (lua_State *L, int stat);
+
+/* pre-defined references */
+#define LUA_NOREF       (-2)
+#define LUA_REFNIL      (-1)
+
+LUALIB_API int (luaL_ref) (lua_State *L, int t);
+LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);
+
+LUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,
+                                               const char *mode);
+
+#define luaL_loadfile(L,f)	luaL_loadfilex(L,f,NULL)
+
+LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
+                                   const char *name, const char *mode);
+LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);
+
+LUALIB_API lua_State *(luaL_newstate) (void);
+
+LUALIB_API int (luaL_len) (lua_State *L, int idx);
+
+LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
+                                                  const char *r);
+
+LUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);
+
+LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);
+
+LUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,
+                                  const char *msg, int level);
+
+LUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,
+                                 lua_CFunction openf, int glb);
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+
+#define luaL_newlibtable(L,l)	\
+  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)
+
+#define luaL_newlib(L,l)	(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
+
+#define luaL_argcheck(L, cond,numarg,extramsg)	\
+		((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
+#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
+#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
+#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
+#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
+#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
+#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))
+#define luaL_optbool(L, n, d) ( lua_isboolean( L, n ) ? lua_toboolean( L, n ) : (bool)luaL_optint( L, n, d ) )
+#define luaL_checkbool(L, n) ( lua_isboolean( L, n ) ? lua_toboolean( L, n ) : (bool)luaL_optint( L, n, false) )
+
+#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))
+
+#define luaL_dofile(L, fn) \
+	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
+
+#define luaL_dostring(L, s) \
+	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
+
+#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))
+
+#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
+
+#define luaL_loadbuffer(L,s,sz,n)	luaL_loadbufferx(L,s,sz,n,NULL)
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+typedef struct luaL_Buffer {
+  char *b;  /* buffer address */
+  size_t size;  /* buffer size */
+  size_t n;  /* number of characters in buffer */
+  lua_State *L;
+  char initb[LUAL_BUFFERSIZE];  /* initial buffer */
+} luaL_Buffer;
+
+
+#define luaL_addchar(B,c) \
+  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \
+   ((B)->b[(B)->n++] = (c)))
+
+#define luaL_addsize(B,s)	((B)->n += (s))
+
+LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
+LUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);
+LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
+LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
+LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
+LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);
+LUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);
+LUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);
+
+#define luaL_prepbuffer(B)	luaL_prepbuffsize(B, LUAL_BUFFERSIZE)
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** File handles for IO library
+** =======================================================
+*/
+
+/*
+** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and
+** initial structure 'luaL_Stream' (it may contain other fields
+** after that initial structure).
+*/
+
+#define LUA_FILEHANDLE          "FILE*"
+
+
+typedef struct luaL_Stream {
+  FILE *f;  /* stream (NULL for incompletely created streams) */
+  lua_CFunction closef;  /* to close stream (NULL for closed streams) */
+} luaL_Stream;
+
+/* }====================================================== */
+
+
+
+/* compatibility with old module system */
+#if defined(LUA_COMPAT_MODULE)
+
+LUALIB_API void (luaL_pushmodule) (lua_State *L, const char *modname,
+                                   int sizehint);
+LUALIB_API void (luaL_openlib) (lua_State *L, const char *libname,
+                                const luaL_Reg *l, int nup);
+
+#define luaL_register(L,n,l)	(luaL_openlib(L,(n),(l),0))
+
+#endif
+
+
+#endif
+
+
diff --git a/dep/lualib/lbaselib.c b/dep/lualib/lbaselib.c
new file mode 100644
index 0000000..dbfcb02
--- /dev/null
+++ b/dep/lualib/lbaselib.c
@@ -0,0 +1,459 @@
+/*
+** $Id: lbaselib.c,v 1.274 2012/04/27 14:13:19 roberto Exp $
+** Basic library
+** See Copyright Notice in lua.h
+*/
+
+
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lbaselib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+static int luaB_print (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  lua_getglobal(L, "tostring");
+  for (i=1; i<=n; i++) {
+    const char *s;
+    size_t l;
+    lua_pushvalue(L, -1);  /* function to be called */
+    lua_pushvalue(L, i);   /* value to print */
+    lua_call(L, 1, 1);
+    s = lua_tolstring(L, -1, &l);  /* get result */
+    if (s == NULL)
+      return luaL_error(L,
+         LUA_QL("tostring") " must return a string to " LUA_QL("print"));
+    if (i>1) luai_writestring("\t", 1);
+    luai_writestring(s, l);
+    lua_pop(L, 1);  /* pop result */
+  }
+  luai_writeline();
+  return 0;
+}
+
+
+#define SPACECHARS	" \f\n\r\t\v"
+
+static int luaB_tonumber (lua_State *L) {
+  if (lua_isnoneornil(L, 2)) {  /* standard conversion */
+    int isnum;
+    lua_Number n = lua_tonumberx(L, 1, &isnum);
+    if (isnum) {
+      lua_pushnumber(L, n);
+      return 1;
+    }  /* else not a number; must be something */
+    luaL_checkany(L, 1);
+  }
+  else {
+    size_t l;
+    const char *s = luaL_checklstring(L, 1, &l);
+    const char *e = s + l;  /* end point for 's' */
+    int base = luaL_checkint(L, 2);
+    int neg = 0;
+    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
+    s += strspn(s, SPACECHARS);  /* skip initial spaces */
+    if (*s == '-') { s++; neg = 1; }  /* handle signal */
+    else if (*s == '+') s++;
+    if (isalnum((unsigned char)*s)) {
+      lua_Number n = 0;
+      do {
+        int digit = (isdigit((unsigned char)*s)) ? *s - '0'
+                       : toupper((unsigned char)*s) - 'A' + 10;
+        if (digit >= base) break;  /* invalid numeral; force a fail */
+        n = n * (lua_Number)base + (lua_Number)digit;
+        s++;
+      } while (isalnum((unsigned char)*s));
+      s += strspn(s, SPACECHARS);  /* skip trailing spaces */
+      if (s == e) {  /* no invalid trailing characters? */
+        lua_pushnumber(L, (neg) ? -n : n);
+        return 1;
+      }  /* else not a number */
+    }  /* else not a number */
+  }
+  lua_pushnil(L);  /* not a number */
+  return 1;
+}
+
+
+static int luaB_error (lua_State *L) {
+  int level = luaL_optint(L, 2, 1);
+  lua_settop(L, 1);
+  if (lua_isstring(L, 1) && level > 0) {  /* add extra information? */
+    luaL_where(L, level);
+    lua_pushvalue(L, 1);
+    lua_concat(L, 2);
+  }
+  return lua_error(L);
+}
+
+
+static int luaB_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);
+    return 1;  /* no metatable */
+  }
+  luaL_getmetafield(L, 1, "__metatable");
+  return 1;  /* returns either __metatable field (if present) or metatable */
+}
+
+
+static int luaB_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  if (luaL_getmetafield(L, 1, "__metatable"))
+    return luaL_error(L, "cannot change a protected metatable");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;
+}
+
+
+static int luaB_rawequal (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_checkany(L, 2);
+  lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  return 1;
+}
+
+
+static int luaB_rawlen (lua_State *L) {
+  int t = lua_type(L, 1);
+  luaL_argcheck(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,
+                   "table or string expected");
+  lua_pushinteger(L, lua_rawlen(L, 1));
+  return 1;
+}
+
+
+static int luaB_rawget (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  lua_settop(L, 2);
+  lua_rawget(L, 1);
+  return 1;
+}
+
+static int luaB_rawset (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  luaL_checkany(L, 3);
+  lua_settop(L, 3);
+  lua_rawset(L, 1);
+  return 1;
+}
+
+
+static int luaB_collectgarbage (lua_State *L) {
+  static const char *const opts[] = {"stop", "restart", "collect",
+    "count", "step", "setpause", "setstepmul",
+    "setmajorinc", "isrunning", "generational", "incremental", NULL};
+  static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
+    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,
+    LUA_GCSETMAJORINC, LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC};
+  int o = optsnum[luaL_checkoption(L, 1, "collect", opts)];
+  int ex = luaL_optint(L, 2, 0);
+  int res = lua_gc(L, o, ex);
+  switch (o) {
+    case LUA_GCCOUNT: {
+      int b = lua_gc(L, LUA_GCCOUNTB, 0);
+      lua_pushnumber(L, res + ((lua_Number)b/1024));
+      lua_pushinteger(L, b);
+      return 2;
+    }
+    case LUA_GCSTEP: case LUA_GCISRUNNING: {
+      lua_pushboolean(L, res);
+      return 1;
+    }
+    default: {
+      lua_pushinteger(L, res);
+      return 1;
+    }
+  }
+}
+
+
+static int luaB_type (lua_State *L) {
+  luaL_checkany(L, 1);
+  lua_pushstring(L, luaL_typename(L, 1));
+  return 1;
+}
+
+
+static int pairsmeta (lua_State *L, const char *method, int iszero,
+                      lua_CFunction iter) {
+  if (!luaL_getmetafield(L, 1, method)) {  /* no metamethod? */
+    luaL_checktype(L, 1, LUA_TTABLE);  /* argument must be a table */
+    lua_pushcfunction(L, iter);  /* will return generator, */
+    lua_pushvalue(L, 1);  /* state, */
+    if (iszero) lua_pushinteger(L, 0);  /* and initial value */
+    else lua_pushnil(L);
+  }
+  else {
+    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */
+    lua_call(L, 1, 3);  /* get 3 values from metamethod */
+  }
+  return 3;
+}
+
+
+static int luaB_next (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
+  if (lua_next(L, 1))
+    return 2;
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int luaB_pairs (lua_State *L) {
+  return pairsmeta(L, "__pairs", 0, luaB_next);
+}
+
+
+static int ipairsaux (lua_State *L) {
+  int i = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i++;  /* next value */
+  lua_pushinteger(L, i);
+  lua_rawgeti(L, 1, i);
+  return (lua_isnil(L, -1)) ? 1 : 2;
+}
+
+
+static int luaB_ipairs (lua_State *L) {
+  return pairsmeta(L, "__ipairs", 1, ipairsaux);
+}
+
+
+static int load_aux (lua_State *L, int status) {
+  if (status == LUA_OK)
+    return 1;
+  else {
+    lua_pushnil(L);
+    lua_insert(L, -2);  /* put before error message */
+    return 2;  /* return nil plus error message */
+  }
+}
+
+
+static int luaB_loadfile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  const char *mode = luaL_optstring(L, 2, NULL);
+  int env = !lua_isnone(L, 3);  /* 'env' parameter? */
+  int status = luaL_loadfilex(L, fname, mode);
+  if (status == LUA_OK && env) {  /* 'env' parameter? */
+    lua_pushvalue(L, 3);
+    lua_setupvalue(L, -2, 1);  /* set it as 1st upvalue of loaded chunk */
+  }
+  return load_aux(L, status);
+}
+
+
+/*
+** {======================================================
+** Generic Read function
+** =======================================================
+*/
+
+
+/*
+** reserved slot, above all arguments, to hold a copy of the returned
+** string to avoid it being collected while parsed. 'load' has four
+** optional arguments (chunk, source name, mode, and environment).
+*/
+#define RESERVEDSLOT	5
+
+
+/*
+** Reader for generic `load' function: `lua_load' uses the
+** stack for internal stuff, so the reader cannot change the
+** stack top. Instead, it keeps its resulting string in a
+** reserved slot inside the stack.
+*/
+static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
+  (void)(ud);  /* not used */
+  luaL_checkstack(L, 2, "too many nested functions");
+  lua_pushvalue(L, 1);  /* get function */
+  lua_call(L, 0, 1);  /* call it */
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* pop result */
+    *size = 0;
+    return NULL;
+  }
+  else if (!lua_isstring(L, -1))
+    luaL_error(L, "reader function must return a string");
+  lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */
+  return lua_tolstring(L, RESERVEDSLOT, size);
+}
+
+
+static int luaB_load (lua_State *L) {
+  int status;
+  size_t l;
+  int top = lua_gettop(L);
+  const char *s = lua_tolstring(L, 1, &l);
+  const char *mode = luaL_optstring(L, 3, "bt");
+  if (s != NULL) {  /* loading a string? */
+    const char *chunkname = luaL_optstring(L, 2, s);
+    status = luaL_loadbufferx(L, s, l, chunkname, mode);
+  }
+  else {  /* loading from a reader function */
+    const char *chunkname = luaL_optstring(L, 2, "=(load)");
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    lua_settop(L, RESERVEDSLOT);  /* create reserved slot */
+    status = lua_load(L, generic_reader, NULL, chunkname, mode);
+  }
+  if (status == LUA_OK && top >= 4) {  /* is there an 'env' argument */
+    lua_pushvalue(L, 4);  /* environment for loaded function */
+    lua_setupvalue(L, -2, 1);  /* set it as 1st upvalue */
+  }
+  return load_aux(L, status);
+}
+
+/* }====================================================== */
+
+
+static int dofilecont (lua_State *L) {
+  return lua_gettop(L) - 1;
+}
+
+
+static int luaB_dofile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  lua_settop(L, 1);
+  if (luaL_loadfile(L, fname) != LUA_OK) lua_error(L);
+  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
+  return dofilecont(L);
+}
+
+
+static int luaB_assert (lua_State *L) {
+  if (!lua_toboolean(L, 1))
+    return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
+  return lua_gettop(L);
+}
+
+
+static int luaB_select (lua_State *L) {
+  int n = lua_gettop(L);
+  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
+    lua_pushinteger(L, n-1);
+    return 1;
+  }
+  else {
+    int i = luaL_checkint(L, 1);
+    if (i < 0) i = n + i;
+    else if (i > n) i = n;
+    luaL_argcheck(L, 1 <= i, 1, "index out of range");
+    return n - i;
+  }
+}
+
+
+static int finishpcall (lua_State *L, int status) {
+  if (!lua_checkstack(L, 1)) {  /* no space for extra boolean? */
+    lua_settop(L, 0);  /* create space for return values */
+    lua_pushboolean(L, 0);
+    lua_pushstring(L, "stack overflow");
+    return 2;  /* return false, msg */
+  }
+  lua_pushboolean(L, status);  /* first result (status) */
+  lua_replace(L, 1);  /* put first result in first slot */
+  return lua_gettop(L);
+}
+
+
+static int pcallcont (lua_State *L) {
+  int status = lua_getctx(L, NULL);
+  return finishpcall(L, (status == LUA_YIELD));
+}
+
+
+static int luaB_pcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 1);
+  lua_pushnil(L);
+  lua_insert(L, 1);  /* create space for status result */
+  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, pcallcont);
+  return finishpcall(L, (status == LUA_OK));
+}
+
+
+static int luaB_xpcall (lua_State *L) {
+  int status;
+  int n = lua_gettop(L);
+  luaL_argcheck(L, n >= 2, 2, "value expected");
+  lua_pushvalue(L, 1);  /* exchange function... */
+  lua_copy(L, 2, 1);  /* ...and error handler */
+  lua_replace(L, 2);
+  status = lua_pcallk(L, n - 2, LUA_MULTRET, 1, 0, pcallcont);
+  return finishpcall(L, (status == LUA_OK));
+}
+
+
+static int luaB_tostring (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_tolstring(L, 1, NULL);
+  return 1;
+}
+
+
+static const luaL_Reg base_funcs[] = {
+  {"assert", luaB_assert},
+  {"collectgarbage", luaB_collectgarbage},
+  {"dofile", luaB_dofile},
+  {"error", luaB_error},
+  {"getmetatable", luaB_getmetatable},
+  {"ipairs", luaB_ipairs},
+  {"loadfile", luaB_loadfile},
+  {"load", luaB_load},
+#if defined(LUA_COMPAT_LOADSTRING)
+  {"loadstring", luaB_load},
+#endif
+  {"next", luaB_next},
+  {"pairs", luaB_pairs},
+  {"pcall", luaB_pcall},
+  {"print", luaB_print},
+  {"rawequal", luaB_rawequal},
+  {"rawlen", luaB_rawlen},
+  {"rawget", luaB_rawget},
+  {"rawset", luaB_rawset},
+  {"select", luaB_select},
+  {"setmetatable", luaB_setmetatable},
+  {"tonumber", luaB_tonumber},
+  {"tostring", luaB_tostring},
+  {"type", luaB_type},
+  {"xpcall", luaB_xpcall},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_base (lua_State *L) {
+  /* set global _G */
+  lua_pushglobaltable(L);
+  lua_pushglobaltable(L);
+  lua_setfield(L, -2, "_G");
+  /* open lib into global table */
+  luaL_setfuncs(L, base_funcs, 0);
+  lua_pushliteral(L, LUA_VERSION);
+  lua_setfield(L, -2, "_VERSION");  /* set global _VERSION */
+  return 1;
+}
+
diff --git a/dep/lualib/lbitlib.c b/dep/lualib/lbitlib.c
new file mode 100644
index 0000000..7533b85
--- /dev/null
+++ b/dep/lualib/lbitlib.c
@@ -0,0 +1,209 @@
+/*
+** $Id: lbitlib.c,v 1.16 2011/06/20 16:35:23 roberto Exp $
+** Standard library for bitwise operations
+** See Copyright Notice in lua.h
+*/
+
+#define lbitlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/* number of bits to consider in a number */
+#if !defined(LUA_NBITS)
+#define LUA_NBITS	32
+#endif
+
+
+#define ALLONES		(~(((~(lua_Unsigned)0) << (LUA_NBITS - 1)) << 1))
+
+/* macro to trim extra bits */
+#define trim(x)		((x) & ALLONES)
+
+
+/* builds a number with 'n' ones (1 <= n <= LUA_NBITS) */
+#define mask(n)		(~((ALLONES << 1) << ((n) - 1)))
+
+
+typedef lua_Unsigned b_uint;
+
+
+
+static b_uint andaux (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = ~(b_uint)0;
+  for (i = 1; i <= n; i++)
+    r &= luaL_checkunsigned(L, i);
+  return trim(r);
+}
+
+
+static int b_and (lua_State *L) {
+  b_uint r = andaux(L);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_test (lua_State *L) {
+  b_uint r = andaux(L);
+  lua_pushboolean(L, r != 0);
+  return 1;
+}
+
+
+static int b_or (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = 0;
+  for (i = 1; i <= n; i++)
+    r |= luaL_checkunsigned(L, i);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_xor (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = 0;
+  for (i = 1; i <= n; i++)
+    r ^= luaL_checkunsigned(L, i);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_not (lua_State *L) {
+  b_uint r = ~luaL_checkunsigned(L, 1);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_shift (lua_State *L, b_uint r, int i) {
+  if (i < 0) {  /* shift right? */
+    i = -i;
+    r = trim(r);
+    if (i >= LUA_NBITS) r = 0;
+    else r >>= i;
+  }
+  else {  /* shift left */
+    if (i >= LUA_NBITS) r = 0;
+    else r <<= i;
+    r = trim(r);
+  }
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_lshift (lua_State *L) {
+  return b_shift(L, luaL_checkunsigned(L, 1), luaL_checkint(L, 2));
+}
+
+
+static int b_rshift (lua_State *L) {
+  return b_shift(L, luaL_checkunsigned(L, 1), -luaL_checkint(L, 2));
+}
+
+
+static int b_arshift (lua_State *L) {
+  b_uint r = luaL_checkunsigned(L, 1);
+  int i = luaL_checkint(L, 2);
+  if (i < 0 || !(r & ((b_uint)1 << (LUA_NBITS - 1))))
+    return b_shift(L, r, -i);
+  else {  /* arithmetic shift for 'negative' number */
+    if (i >= LUA_NBITS) r = ALLONES;
+    else
+      r = trim((r >> i) | ~(~(b_uint)0 >> i));  /* add signal bit */
+    lua_pushunsigned(L, r);
+    return 1;
+  }
+}
+
+
+static int b_rot (lua_State *L, int i) {
+  b_uint r = luaL_checkunsigned(L, 1);
+  i &= (LUA_NBITS - 1);  /* i = i % NBITS */
+  r = trim(r);
+  r = (r << i) | (r >> (LUA_NBITS - i));
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_lrot (lua_State *L) {
+  return b_rot(L, luaL_checkint(L, 2));
+}
+
+
+static int b_rrot (lua_State *L) {
+  return b_rot(L, -luaL_checkint(L, 2));
+}
+
+
+/*
+** get field and width arguments for field-manipulation functions,
+** checking whether they are valid
+*/
+static int fieldargs (lua_State *L, int farg, int *width) {
+  int f = luaL_checkint(L, farg);
+  int w = luaL_optint(L, farg + 1, 1);
+  luaL_argcheck(L, 0 <= f, farg, "field cannot be negative");
+  luaL_argcheck(L, 0 < w, farg + 1, "width must be positive");
+  if (f + w > LUA_NBITS)
+    luaL_error(L, "trying to access non-existent bits");
+  *width = w;
+  return f;
+}
+
+
+static int b_extract (lua_State *L) {
+  int w;
+  b_uint r = luaL_checkunsigned(L, 1);
+  int f = fieldargs(L, 2, &w);
+  r = (r >> f) & mask(w);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_replace (lua_State *L) {
+  int w;
+  b_uint r = luaL_checkunsigned(L, 1);
+  b_uint v = luaL_checkunsigned(L, 2);
+  int f = fieldargs(L, 3, &w);
+  int m = mask(w);
+  v &= m;  /* erase bits outside given width */
+  r = (r & ~(m << f)) | (v << f);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static const luaL_Reg bitlib[] = {
+  {"arshift", b_arshift},
+  {"band", b_and},
+  {"bnot", b_not},
+  {"bor", b_or},
+  {"bxor", b_xor},
+  {"btest", b_test},
+  {"extract", b_extract},
+  {"lrotate", b_lrot},
+  {"lshift", b_lshift},
+  {"replace", b_replace},
+  {"rrotate", b_rrot},
+  {"rshift", b_rshift},
+  {NULL, NULL}
+};
+
+
+
+LUAMOD_API int luaopen_bit32 (lua_State *L) {
+  luaL_newlib(L, bitlib);
+  return 1;
+}
+
diff --git a/dep/lualib/lcode.c b/dep/lualib/lcode.c
new file mode 100644
index 0000000..614e452
--- /dev/null
+++ b/dep/lualib/lcode.c
@@ -0,0 +1,882 @@
+/*
+** $Id: lcode.c,v 2.60 2011/08/30 16:26:41 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lcode_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lvm.h"
+
+
+#define hasjumps(e)	((e)->t != (e)->f)
+
+
+static int isnumeral(expdesc *e) {
+  return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);
+}
+
+
+void luaK_nil (FuncState *fs, int from, int n) {
+  Instruction *previous;
+  int l = from + n - 1;  /* last register to set nil */
+  if (fs->pc > fs->lasttarget) {  /* no jumps to current position? */
+    previous = &fs->f->code[fs->pc-1];
+    if (GET_OPCODE(*previous) == OP_LOADNIL) {
+      int pfrom = GETARG_A(*previous);
+      int pl = pfrom + GETARG_B(*previous);
+      if ((pfrom <= from && from <= pl + 1) ||
+          (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */
+        if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */
+        if (pl > l) l = pl;  /* l = max(l, pl) */
+        SETARG_A(*previous, from);
+        SETARG_B(*previous, l - from);
+        return;
+      }
+    }  /* else go through */
+  }
+  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */
+}
+
+
+int luaK_jump (FuncState *fs) {
+  int jpc = fs->jpc;  /* save list of jumps to here */
+  int j;
+  fs->jpc = NO_JUMP;
+  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
+  luaK_concat(fs, &j, jpc);  /* keep them on hold */
+  return j;
+}
+
+
+void luaK_ret (FuncState *fs, int first, int nret) {
+  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+}
+
+
+static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {
+  luaK_codeABC(fs, op, A, B, C);
+  return luaK_jump(fs);
+}
+
+
+static void fixjump (FuncState *fs, int pc, int dest) {
+  Instruction *jmp = &fs->f->code[pc];
+  int offset = dest-(pc+1);
+  lua_assert(dest != NO_JUMP);
+  if (abs(offset) > MAXARG_sBx)
+    luaX_syntaxerror(fs->ls, "control structure too long");
+  SETARG_sBx(*jmp, offset);
+}
+
+
+/*
+** returns current `pc' and marks it as a jump target (to avoid wrong
+** optimizations with consecutive instructions not in the same basic block).
+*/
+int luaK_getlabel (FuncState *fs) {
+  fs->lasttarget = fs->pc;
+  return fs->pc;
+}
+
+
+static int getjump (FuncState *fs, int pc) {
+  int offset = GETARG_sBx(fs->f->code[pc]);
+  if (offset == NO_JUMP)  /* point to itself represents end of list */
+    return NO_JUMP;  /* end of list */
+  else
+    return (pc+1)+offset;  /* turn offset into absolute position */
+}
+
+
+static Instruction *getjumpcontrol (FuncState *fs, int pc) {
+  Instruction *pi = &fs->f->code[pc];
+  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))
+    return pi-1;
+  else
+    return pi;
+}
+
+
+/*
+** check whether list has any jump that do not produce a value
+** (or produce an inverted value)
+*/
+static int need_value (FuncState *fs, int list) {
+  for (; list != NO_JUMP; list = getjump(fs, list)) {
+    Instruction i = *getjumpcontrol(fs, list);
+    if (GET_OPCODE(i) != OP_TESTSET) return 1;
+  }
+  return 0;  /* not found */
+}
+
+
+static int patchtestreg (FuncState *fs, int node, int reg) {
+  Instruction *i = getjumpcontrol(fs, node);
+  if (GET_OPCODE(*i) != OP_TESTSET)
+    return 0;  /* cannot patch other instructions */
+  if (reg != NO_REG && reg != GETARG_B(*i))
+    SETARG_A(*i, reg);
+  else  /* no register to put value or register already has the value */
+    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
+
+  return 1;
+}
+
+
+static void removevalues (FuncState *fs, int list) {
+  for (; list != NO_JUMP; list = getjump(fs, list))
+      patchtestreg(fs, list, NO_REG);
+}
+
+
+static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
+                          int dtarget) {
+  while (list != NO_JUMP) {
+    int next = getjump(fs, list);
+    if (patchtestreg(fs, list, reg))
+      fixjump(fs, list, vtarget);
+    else
+      fixjump(fs, list, dtarget);  /* jump to default target */
+    list = next;
+  }
+}
+
+
+static void dischargejpc (FuncState *fs) {
+  patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc);
+  fs->jpc = NO_JUMP;
+}
+
+
+void luaK_patchlist (FuncState *fs, int list, int target) {
+  if (target == fs->pc)
+    luaK_patchtohere(fs, list);
+  else {
+    lua_assert(target < fs->pc);
+    patchlistaux(fs, list, target, NO_REG, target);
+  }
+}
+
+
+LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level) {
+  level++;  /* argument is +1 to reserve 0 as non-op */
+  while (list != NO_JUMP) {
+    int next = getjump(fs, list);
+    lua_assert(GET_OPCODE(fs->f->code[list]) == OP_JMP &&
+                (GETARG_A(fs->f->code[list]) == 0 ||
+                 GETARG_A(fs->f->code[list]) >= level));
+    SETARG_A(fs->f->code[list], level);
+    list = next;
+  }
+}
+
+
+void luaK_patchtohere (FuncState *fs, int list) {
+  luaK_getlabel(fs);
+  luaK_concat(fs, &fs->jpc, list);
+}
+
+
+void luaK_concat (FuncState *fs, int *l1, int l2) {
+  if (l2 == NO_JUMP) return;
+  else if (*l1 == NO_JUMP)
+    *l1 = l2;
+  else {
+    int list = *l1;
+    int next;
+    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */
+      list = next;
+    fixjump(fs, list, l2);
+  }
+}
+
+
+static int luaK_code (FuncState *fs, Instruction i) {
+  Proto *f = fs->f;
+  dischargejpc(fs);  /* `pc' will change */
+  /* put new instruction in code array */
+  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
+                  MAX_INT, "opcodes");
+  f->code[fs->pc] = i;
+  /* save corresponding line information */
+  luaM_growvector(fs->ls->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
+                  MAX_INT, "opcodes");
+  f->lineinfo[fs->pc] = fs->ls->lastline;
+  return fs->pc++;
+}
+
+
+int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
+  lua_assert(getOpMode(o) == iABC);
+  lua_assert(getBMode(o) != OpArgN || b == 0);
+  lua_assert(getCMode(o) != OpArgN || c == 0);
+  lua_assert(a <= MAXARG_A && b <= MAXARG_B && c <= MAXARG_C);
+  return luaK_code(fs, CREATE_ABC(o, a, b, c));
+}
+
+
+int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
+  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
+  lua_assert(getCMode(o) == OpArgN);
+  lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);
+  return luaK_code(fs, CREATE_ABx(o, a, bc));
+}
+
+
+static int codeextraarg (FuncState *fs, int a) {
+  lua_assert(a <= MAXARG_Ax);
+  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));
+}
+
+
+int luaK_codek (FuncState *fs, int reg, int k) {
+  if (k <= MAXARG_Bx)
+    return luaK_codeABx(fs, OP_LOADK, reg, k);
+  else {
+    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);
+    codeextraarg(fs, k);
+    return p;
+  }
+}
+
+
+void luaK_checkstack (FuncState *fs, int n) {
+  int newstack = fs->freereg + n;
+  if (newstack > fs->f->maxstacksize) {
+    if (newstack >= MAXSTACK)
+      luaX_syntaxerror(fs->ls, "function or expression too complex");
+    fs->f->maxstacksize = cast_byte(newstack);
+  }
+}
+
+
+void luaK_reserveregs (FuncState *fs, int n) {
+  luaK_checkstack(fs, n);
+  fs->freereg += n;
+}
+
+
+static void freereg (FuncState *fs, int reg) {
+  if (!ISK(reg) && reg >= fs->nactvar) {
+    fs->freereg--;
+    lua_assert(reg == fs->freereg);
+  }
+}
+
+
+static void freeexp (FuncState *fs, expdesc *e) {
+  if (e->k == VNONRELOC)
+    freereg(fs, e->u.info);
+}
+
+
+static int addk (FuncState *fs, TValue *key, TValue *v) {
+  lua_State *L = fs->ls->L;
+  TValue *idx = luaH_set(L, fs->h, key);
+  Proto *f = fs->f;
+  int k, oldsize;
+  if (ttisnumber(idx)) {
+    lua_Number n = nvalue(idx);
+    lua_number2int(k, n);
+    if (luaV_rawequalobj(&f->k[k], v))
+      return k;
+    /* else may be a collision (e.g., between 0.0 and "\0\0\0\0\0\0\0\0");
+       go through and create a new entry for this value */
+  }
+  /* constant not found; create a new entry */
+  oldsize = f->sizek;
+  k = fs->nk;
+  /* numerical value does not need GC barrier;
+     table has no metatable, so it does not need to invalidate cache */
+  setnvalue(idx, cast_num(k));
+  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
+  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
+  setobj(L, &f->k[k], v);
+  fs->nk++;
+  luaC_barrier(L, f, v);
+  return k;
+}
+
+
+int luaK_stringK (FuncState *fs, TString *s) {
+  TValue o;
+  setsvalue(fs->ls->L, &o, s);
+  return addk(fs, &o, &o);
+}
+
+
+int luaK_numberK (FuncState *fs, lua_Number r) {
+  int n;
+  lua_State *L = fs->ls->L;
+  TValue o;
+  setnvalue(&o, r);
+  if (r == 0 || luai_numisnan(NULL, r)) {  /* handle -0 and NaN */
+    /* use raw representation as key to avoid numeric problems */
+    setsvalue(L, L->top, luaS_newlstr(L, (char *)&r, sizeof(r)));
+     incr_top(L);
+     n = addk(fs, L->top - 1, &o);
+     L->top--;
+  }
+  else
+    n = addk(fs, &o, &o);  /* regular case */
+  return n;
+}
+
+
+static int boolK (FuncState *fs, int b) {
+  TValue o;
+  setbvalue(&o, b);
+  return addk(fs, &o, &o);
+}
+
+
+static int nilK (FuncState *fs) {
+  TValue k, v;
+  setnilvalue(&v);
+  /* cannot use nil as key; instead use table itself to represent nil */
+  sethvalue(fs->ls->L, &k, fs->h);
+  return addk(fs, &k, &v);
+}
+
+
+void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    SETARG_C(getcode(fs, e), nresults+1);
+  }
+  else if (e->k == VVARARG) {
+    SETARG_B(getcode(fs, e), nresults+1);
+    SETARG_A(getcode(fs, e), fs->freereg);
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+void luaK_setoneret (FuncState *fs, expdesc *e) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    e->k = VNONRELOC;
+    e->u.info = GETARG_A(getcode(fs, e));
+  }
+  else if (e->k == VVARARG) {
+    SETARG_B(getcode(fs, e), 2);
+    e->k = VRELOCABLE;  /* can relocate its simple result */
+  }
+}
+
+
+void luaK_dischargevars (FuncState *fs, expdesc *e) {
+  switch (e->k) {
+    case VLOCAL: {
+      e->k = VNONRELOC;
+      break;
+    }
+    case VUPVAL: {
+      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VINDEXED: {
+      OpCode op = OP_GETTABUP;  /* assume 't' is in an upvalue */
+      freereg(fs, e->u.ind.idx);
+      if (e->u.ind.vt == VLOCAL) {  /* 't' is in a register? */
+        freereg(fs, e->u.ind.t);
+        op = OP_GETTABLE;
+      }
+      e->u.info = luaK_codeABC(fs, op, 0, e->u.ind.t, e->u.ind.idx);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VVARARG:
+    case VCALL: {
+      luaK_setoneret(fs, e);
+      break;
+    }
+    default: break;  /* there is one value available (somewhere) */
+  }
+}
+
+
+static int code_label (FuncState *fs, int A, int b, int jump) {
+  luaK_getlabel(fs);  /* those instructions may be jump targets */
+  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
+}
+
+
+static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: {
+      luaK_nil(fs, reg, 1);
+      break;
+    }
+    case VFALSE:  case VTRUE: {
+      luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);
+      break;
+    }
+    case VK: {
+      luaK_codek(fs, reg, e->u.info);
+      break;
+    }
+    case VKNUM: {
+      luaK_codek(fs, reg, luaK_numberK(fs, e->u.nval));
+      break;
+    }
+    case VRELOCABLE: {
+      Instruction *pc = &getcode(fs, e);
+      SETARG_A(*pc, reg);
+      break;
+    }
+    case VNONRELOC: {
+      if (reg != e->u.info)
+        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);
+      break;
+    }
+    default: {
+      lua_assert(e->k == VVOID || e->k == VJMP);
+      return;  /* nothing to do... */
+    }
+  }
+  e->u.info = reg;
+  e->k = VNONRELOC;
+}
+
+
+static void discharge2anyreg (FuncState *fs, expdesc *e) {
+  if (e->k != VNONRELOC) {
+    luaK_reserveregs(fs, 1);
+    discharge2reg(fs, e, fs->freereg-1);
+  }
+}
+
+
+static void exp2reg (FuncState *fs, expdesc *e, int reg) {
+  discharge2reg(fs, e, reg);
+  if (e->k == VJMP)
+    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in `t' list */
+  if (hasjumps(e)) {
+    int final;  /* position after whole expression */
+    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
+    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
+    if (need_value(fs, e->t) || need_value(fs, e->f)) {
+      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);
+      p_f = code_label(fs, reg, 0, 1);
+      p_t = code_label(fs, reg, 1, 0);
+      luaK_patchtohere(fs, fj);
+    }
+    final = luaK_getlabel(fs);
+    patchlistaux(fs, e->f, final, reg, p_f);
+    patchlistaux(fs, e->t, final, reg, p_t);
+  }
+  e->f = e->t = NO_JUMP;
+  e->u.info = reg;
+  e->k = VNONRELOC;
+}
+
+
+void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  freeexp(fs, e);
+  luaK_reserveregs(fs, 1);
+  exp2reg(fs, e, fs->freereg - 1);
+}
+
+
+int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  if (e->k == VNONRELOC) {
+    if (!hasjumps(e)) return e->u.info;  /* exp is already in a register */
+    if (e->u.info >= fs->nactvar) {  /* reg. is not a local? */
+      exp2reg(fs, e, e->u.info);  /* put value on it */
+      return e->u.info;
+    }
+  }
+  luaK_exp2nextreg(fs, e);  /* default */
+  return e->u.info;
+}
+
+
+void luaK_exp2anyregup (FuncState *fs, expdesc *e) {
+  if (e->k != VUPVAL || hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_exp2val (FuncState *fs, expdesc *e) {
+  if (hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+  else
+    luaK_dischargevars(fs, e);
+}
+
+
+int luaK_exp2RK (FuncState *fs, expdesc *e) {
+  luaK_exp2val(fs, e);
+  switch (e->k) {
+    case VTRUE:
+    case VFALSE:
+    case VNIL: {
+      if (fs->nk <= MAXINDEXRK) {  /* constant fits in RK operand? */
+        e->u.info = (e->k == VNIL) ? nilK(fs) : boolK(fs, (e->k == VTRUE));
+        e->k = VK;
+        return RKASK(e->u.info);
+      }
+      else break;
+    }
+    case VKNUM: {
+      e->u.info = luaK_numberK(fs, e->u.nval);
+      e->k = VK;
+      /* go through */
+    }
+    case VK: {
+      if (e->u.info <= MAXINDEXRK)  /* constant fits in argC? */
+        return RKASK(e->u.info);
+      else break;
+    }
+    default: break;
+  }
+  /* not a constant in the right range: put it in a register */
+  return luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
+  switch (var->k) {
+    case VLOCAL: {
+      freeexp(fs, ex);
+      exp2reg(fs, ex, var->u.info);
+      return;
+    }
+    case VUPVAL: {
+      int e = luaK_exp2anyreg(fs, ex);
+      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);
+      break;
+    }
+    case VINDEXED: {
+      OpCode op = (var->u.ind.vt == VLOCAL) ? OP_SETTABLE : OP_SETTABUP;
+      int e = luaK_exp2RK(fs, ex);
+      luaK_codeABC(fs, op, var->u.ind.t, var->u.ind.idx, e);
+      break;
+    }
+    default: {
+      lua_assert(0);  /* invalid var kind to store */
+      break;
+    }
+  }
+  freeexp(fs, ex);
+}
+
+
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
+  int ereg;
+  luaK_exp2anyreg(fs, e);
+  ereg = e->u.info;  /* register where 'e' was placed */
+  freeexp(fs, e);
+  e->u.info = fs->freereg;  /* base register for op_self */
+  e->k = VNONRELOC;
+  luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */
+  luaK_codeABC(fs, OP_SELF, e->u.info, ereg, luaK_exp2RK(fs, key));
+  freeexp(fs, key);
+}
+
+
+static void invertjump (FuncState *fs, expdesc *e) {
+  Instruction *pc = getjumpcontrol(fs, e->u.info);
+  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
+                                           GET_OPCODE(*pc) != OP_TEST);
+  SETARG_A(*pc, !(GETARG_A(*pc)));
+}
+
+
+static int jumponcond (FuncState *fs, expdesc *e, int cond) {
+  if (e->k == VRELOCABLE) {
+    Instruction ie = getcode(fs, e);
+    if (GET_OPCODE(ie) == OP_NOT) {
+      fs->pc--;  /* remove previous OP_NOT */
+      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
+    }
+    /* else go through */
+  }
+  discharge2anyreg(fs, e);
+  freeexp(fs, e);
+  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, cond);
+}
+
+
+void luaK_goiftrue (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VJMP: {
+      invertjump(fs, e);
+      pc = e->u.info;
+      break;
+    }
+    case VK: case VKNUM: case VTRUE: {
+      pc = NO_JUMP;  /* always true; do nothing */
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 0);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */
+  luaK_patchtohere(fs, e->t);
+  e->t = NO_JUMP;
+}
+
+
+void luaK_goiffalse (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VJMP: {
+      pc = e->u.info;
+      break;
+    }
+    case VNIL: case VFALSE: {
+      pc = NO_JUMP;  /* always false; do nothing */
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 1);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */
+  luaK_patchtohere(fs, e->f);
+  e->f = NO_JUMP;
+}
+
+
+static void codenot (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: case VFALSE: {
+      e->k = VTRUE;
+      break;
+    }
+    case VK: case VKNUM: case VTRUE: {
+      e->k = VFALSE;
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      break;
+    }
+    case VRELOCABLE:
+    case VNONRELOC: {
+      discharge2anyreg(fs, e);
+      freeexp(fs, e);
+      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    default: {
+      lua_assert(0);  /* cannot happen */
+      break;
+    }
+  }
+  /* interchange true and false lists */
+  { int temp = e->f; e->f = e->t; e->t = temp; }
+  removevalues(fs, e->f);
+  removevalues(fs, e->t);
+}
+
+
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
+  lua_assert(!hasjumps(t));
+  t->u.ind.t = t->u.info;
+  t->u.ind.idx = luaK_exp2RK(fs, k);
+  t->u.ind.vt = (t->k == VUPVAL) ? VUPVAL
+                                 : check_exp(vkisinreg(t->k), VLOCAL);
+  t->k = VINDEXED;
+}
+
+
+static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
+  lua_Number r;
+  if (!isnumeral(e1) || !isnumeral(e2)) return 0;
+  if ((op == OP_DIV || op == OP_MOD) && e2->u.nval == 0)
+    return 0;  /* do not attempt to divide by 0 */
+  r = luaO_arith(op - OP_ADD + LUA_OPADD, e1->u.nval, e2->u.nval);
+  e1->u.nval = r;
+  return 1;
+}
+
+
+static void codearith (FuncState *fs, OpCode op,
+                       expdesc *e1, expdesc *e2, int line) {
+  if (constfolding(op, e1, e2))
+    return;
+  else {
+    int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
+    int o1 = luaK_exp2RK(fs, e1);
+    if (o1 > o2) {
+      freeexp(fs, e1);
+      freeexp(fs, e2);
+    }
+    else {
+      freeexp(fs, e2);
+      freeexp(fs, e1);
+    }
+    e1->u.info = luaK_codeABC(fs, op, 0, o1, o2);
+    e1->k = VRELOCABLE;
+    luaK_fixline(fs, line);
+  }
+}
+
+
+static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,
+                                                          expdesc *e2) {
+  int o1 = luaK_exp2RK(fs, e1);
+  int o2 = luaK_exp2RK(fs, e2);
+  freeexp(fs, e2);
+  freeexp(fs, e1);
+  if (cond == 0 && op != OP_EQ) {
+    int temp;  /* exchange args to replace by `<' or `<=' */
+    temp = o1; o1 = o2; o2 = temp;  /* o1 <==> o2 */
+    cond = 1;
+  }
+  e1->u.info = condjump(fs, op, cond, o1, o2);
+  e1->k = VJMP;
+}
+
+
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
+  expdesc e2;
+  e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
+  switch (op) {
+    case OPR_MINUS: {
+      if (isnumeral(e))  /* minus constant? */
+        e->u.nval = luai_numunm(NULL, e->u.nval);  /* fold it */
+      else {
+        luaK_exp2anyreg(fs, e);
+        codearith(fs, OP_UNM, e, &e2, line);
+      }
+      break;
+    }
+    case OPR_NOT: codenot(fs, e); break;
+    case OPR_LEN: {
+      luaK_exp2anyreg(fs, e);  /* cannot operate on constants */
+      codearith(fs, OP_LEN, e, &e2, line);
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
+  switch (op) {
+    case OPR_AND: {
+      luaK_goiftrue(fs, v);
+      break;
+    }
+    case OPR_OR: {
+      luaK_goiffalse(fs, v);
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
+      break;
+    }
+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
+    case OPR_MOD: case OPR_POW: {
+      if (!isnumeral(v)) luaK_exp2RK(fs, v);
+      break;
+    }
+    default: {
+      luaK_exp2RK(fs, v);
+      break;
+    }
+  }
+}
+
+
+void luaK_posfix (FuncState *fs, BinOpr op,
+                  expdesc *e1, expdesc *e2, int line) {
+  switch (op) {
+    case OPR_AND: {
+      lua_assert(e1->t == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e2->f, e1->f);
+      *e1 = *e2;
+      break;
+    }
+    case OPR_OR: {
+      lua_assert(e1->f == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e2->t, e1->t);
+      *e1 = *e2;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2val(fs, e2);
+      if (e2->k == VRELOCABLE && GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
+        lua_assert(e1->u.info == GETARG_B(getcode(fs, e2))-1);
+        freeexp(fs, e1);
+        SETARG_B(getcode(fs, e2), e1->u.info);
+        e1->k = VRELOCABLE; e1->u.info = e2->u.info;
+      }
+      else {
+        luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */
+        codearith(fs, OP_CONCAT, e1, e2, line);
+      }
+      break;
+    }
+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
+    case OPR_MOD: case OPR_POW: {
+      codearith(fs, cast(OpCode, op - OPR_ADD + OP_ADD), e1, e2, line);
+      break;
+    }
+    case OPR_EQ: case OPR_LT: case OPR_LE: {
+      codecomp(fs, cast(OpCode, op - OPR_EQ + OP_EQ), 1, e1, e2);
+      break;
+    }
+    case OPR_NE: case OPR_GT: case OPR_GE: {
+      codecomp(fs, cast(OpCode, op - OPR_NE + OP_EQ), 0, e1, e2);
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+void luaK_fixline (FuncState *fs, int line) {
+  fs->f->lineinfo[fs->pc - 1] = line;
+}
+
+
+void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
+  int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
+  int b = (tostore == LUA_MULTRET) ? 0 : tostore;
+  lua_assert(tostore != 0);
+  if (c <= MAXARG_C)
+    luaK_codeABC(fs, OP_SETLIST, base, b, c);
+  else if (c <= MAXARG_Ax) {
+    luaK_codeABC(fs, OP_SETLIST, base, b, 0);
+    codeextraarg(fs, c);
+  }
+  else
+    luaX_syntaxerror(fs->ls, "constructor too long");
+  fs->freereg = base + 1;  /* free registers with list values */
+}
+
diff --git a/dep/lualib/lcode.h b/dep/lualib/lcode.h
new file mode 100644
index 0000000..5a1fa9f
--- /dev/null
+++ b/dep/lualib/lcode.h
@@ -0,0 +1,83 @@
+/*
+** $Id: lcode.h,v 1.58 2011/08/30 16:26:41 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lcode_h
+#define lcode_h
+
+#include "llex.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+
+
+/*
+** Marks the end of a patch list. It is an invalid value both as an absolute
+** address, and as a list link (would link an element to itself).
+*/
+#define NO_JUMP (-1)
+
+
+/*
+** grep "ORDER OPR" if you change these enums  (ORDER OP)
+*/
+typedef enum BinOpr {
+  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,
+  OPR_CONCAT,
+  OPR_EQ, OPR_LT, OPR_LE,
+  OPR_NE, OPR_GT, OPR_GE,
+  OPR_AND, OPR_OR,
+  OPR_NOBINOPR
+} BinOpr;
+
+
+typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
+
+
+#define getcode(fs,e)	((fs)->f->code[(e)->u.info])
+
+#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
+
+#define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)
+
+#define luaK_jumpto(fs,t)	luaK_patchlist(fs, luaK_jump(fs), t)
+
+LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
+LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
+LUAI_FUNC int luaK_codek (FuncState *fs, int reg, int k);
+LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
+LUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);
+LUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);
+LUAI_FUNC void luaK_checkstack (FuncState *fs, int n);
+LUAI_FUNC int luaK_stringK (FuncState *fs, TString *s);
+LUAI_FUNC int luaK_numberK (FuncState *fs, lua_Number r);
+LUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2anyregup (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_exp2RK (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
+LUAI_FUNC void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
+LUAI_FUNC void luaK_goiftrue (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_goiffalse (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
+LUAI_FUNC void luaK_setreturns (FuncState *fs, expdesc *e, int nresults);
+LUAI_FUNC void luaK_setoneret (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_jump (FuncState *fs);
+LUAI_FUNC void luaK_ret (FuncState *fs, int first, int nret);
+LUAI_FUNC void luaK_patchlist (FuncState *fs, int list, int target);
+LUAI_FUNC void luaK_patchtohere (FuncState *fs, int list);
+LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level);
+LUAI_FUNC void luaK_concat (FuncState *fs, int *l1, int l2);
+LUAI_FUNC int luaK_getlabel (FuncState *fs);
+LUAI_FUNC void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v, int line);
+LUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
+LUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1,
+                            expdesc *v2, int line);
+LUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);
+
+
+#endif
diff --git a/dep/lualib/lcorolib.c b/dep/lualib/lcorolib.c
new file mode 100644
index 0000000..c7932d9
--- /dev/null
+++ b/dep/lualib/lcorolib.c
@@ -0,0 +1,155 @@
+/*
+** $Id: lcorolib.c,v 1.4 2012/04/27 18:59:04 roberto Exp $
+** Coroutine Library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+
+#define lcorolib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+static int auxresume (lua_State *L, lua_State *co, int narg) {
+  int status;
+  if (!lua_checkstack(co, narg)) {
+    lua_pushliteral(L, "too many arguments to resume");
+    return -1;  /* error flag */
+  }
+  if (lua_status(co) == LUA_OK && lua_gettop(co) == 0) {
+    lua_pushliteral(L, "cannot resume dead coroutine");
+    return -1;  /* error flag */
+  }
+  lua_xmove(L, co, narg);
+  status = lua_resume(co, L, narg);
+  if (status == LUA_OK || status == LUA_YIELD) {
+    int nres = lua_gettop(co);
+    if (!lua_checkstack(L, nres + 1)) {
+      lua_pop(co, nres);  /* remove results anyway */
+      lua_pushliteral(L, "too many results to resume");
+      return -1;  /* error flag */
+    }
+    lua_xmove(co, L, nres);  /* move yielded values */
+    return nres;
+  }
+  else {
+    lua_xmove(co, L, 1);  /* move error message */
+    return -1;  /* error flag */
+  }
+}
+
+
+static int luaB_coresume (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  int r;
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  r = auxresume(L, co, lua_gettop(L) - 1);
+  if (r < 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    lua_insert(L, -(r + 1));
+    return r + 1;  /* return true + `resume' returns */
+  }
+}
+
+
+static int luaB_auxwrap (lua_State *L) {
+  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
+  int r = auxresume(L, co, lua_gettop(L));
+  if (r < 0) {
+    if (lua_isstring(L, -1)) {  /* error object is a string? */
+      luaL_where(L, 1);  /* add extra info */
+      lua_insert(L, -2);
+      lua_concat(L, 2);
+    }
+    lua_error(L);  /* propagate error */
+  }
+  return r;
+}
+
+
+static int luaB_cocreate (lua_State *L) {
+  lua_State *NL;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  NL = lua_newthread(L);
+  lua_pushvalue(L, 1);  /* move function to top */
+  lua_xmove(L, NL, 1);  /* move function from L to NL */
+  return 1;
+}
+
+
+static int luaB_cowrap (lua_State *L) {
+  luaB_cocreate(L);
+  lua_pushcclosure(L, luaB_auxwrap, 1);
+  return 1;
+}
+
+
+static int luaB_yield (lua_State *L) {
+  return lua_yield(L, lua_gettop(L));
+}
+
+
+static int luaB_costatus (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  if (L == co) lua_pushliteral(L, "running");
+  else {
+    switch (lua_status(co)) {
+      case LUA_YIELD:
+        lua_pushliteral(L, "suspended");
+        break;
+      case LUA_OK: {
+        lua_Debug ar;
+        if (lua_getstack(co, 0, &ar) > 0)  /* does it have frames? */
+          lua_pushliteral(L, "normal");  /* it is running */
+        else if (lua_gettop(co) == 0)
+            lua_pushliteral(L, "dead");
+        else
+          lua_pushliteral(L, "suspended");  /* initial state */
+        break;
+      }
+      default:  /* some error occurred */
+        lua_pushliteral(L, "dead");
+        break;
+    }
+  }
+  return 1;
+}
+
+
+static int luaB_corunning (lua_State *L) {
+  int ismain = lua_pushthread(L);
+  lua_pushboolean(L, ismain);
+  return 2;
+}
+
+
+static const luaL_Reg co_funcs[] = {
+  {"create", luaB_cocreate},
+  {"resume", luaB_coresume},
+  {"running", luaB_corunning},
+  {"status", luaB_costatus},
+  {"wrap", luaB_cowrap},
+  {"yield", luaB_yield},
+  {NULL, NULL}
+};
+
+
+
+LUAMOD_API int luaopen_coroutine (lua_State *L) {
+  luaL_newlib(L, co_funcs);
+  return 1;
+}
+
diff --git a/dep/lualib/lctype.c b/dep/lualib/lctype.c
new file mode 100644
index 0000000..55e433a
--- /dev/null
+++ b/dep/lualib/lctype.c
@@ -0,0 +1,52 @@
+/*
+** $Id: lctype.c,v 1.11 2011/10/03 16:19:23 roberto Exp $
+** 'ctype' functions for Lua
+** See Copyright Notice in lua.h
+*/
+
+#define lctype_c
+#define LUA_CORE
+
+#include "lctype.h"
+
+#if !LUA_USE_CTYPE	/* { */
+
+#include <limits.h>
+
+LUAI_DDEF const lu_byte luai_ctype_[UCHAR_MAX + 2] = {
+  0x00,  /* EOZ */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 0. */
+  0x00,  0x08,  0x08,  0x08,  0x08,  0x08,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 1. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x0c,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,	/* 2. */
+  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
+  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,	/* 3. */
+  0x16,  0x16,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
+  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 4. */
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 5. */
+  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x05,
+  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 6. */
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 7. */
+  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 8. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 9. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* a. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* b. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* c. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* d. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* e. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* f. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+};
+
+#endif			/* } */
diff --git a/dep/lualib/lctype.h b/dep/lualib/lctype.h
new file mode 100644
index 0000000..99c7d12
--- /dev/null
+++ b/dep/lualib/lctype.h
@@ -0,0 +1,95 @@
+/*
+** $Id: lctype.h,v 1.12 2011/07/15 12:50:29 roberto Exp $
+** 'ctype' functions for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lctype_h
+#define lctype_h
+
+#include "lua.h"
+
+
+/*
+** WARNING: the functions defined here do not necessarily correspond
+** to the similar functions in the standard C ctype.h. They are
+** optimized for the specific needs of Lua
+*/
+
+#if !defined(LUA_USE_CTYPE)
+
+#if 'A' == 65 && '0' == 48
+/* ASCII case: can use its own tables; faster and fixed */
+#define LUA_USE_CTYPE	0
+#else
+/* must use standard C ctype */
+#define LUA_USE_CTYPE	1
+#endif
+
+#endif
+
+
+#if !LUA_USE_CTYPE	/* { */
+
+#include <limits.h>
+
+#include "llimits.h"
+
+
+#define ALPHABIT	0
+#define DIGITBIT	1
+#define PRINTBIT	2
+#define SPACEBIT	3
+#define XDIGITBIT	4
+
+
+#define MASK(B)		(1 << (B))
+
+
+/*
+** add 1 to char to allow index -1 (EOZ)
+*/
+#define testprop(c,p)	(luai_ctype_[(c)+1] & (p))
+
+/*
+** 'lalpha' (Lua alphabetic) and 'lalnum' (Lua alphanumeric) both include '_'
+*/
+#define lislalpha(c)	testprop(c, MASK(ALPHABIT))
+#define lislalnum(c)	testprop(c, (MASK(ALPHABIT) | MASK(DIGITBIT)))
+#define lisdigit(c)	testprop(c, MASK(DIGITBIT))
+#define lisspace(c)	testprop(c, MASK(SPACEBIT))
+#define lisprint(c)	testprop(c, MASK(PRINTBIT))
+#define lisxdigit(c)	testprop(c, MASK(XDIGITBIT))
+
+/*
+** this 'ltolower' only works for alphabetic characters
+*/
+#define ltolower(c)	((c) | ('A' ^ 'a'))
+
+
+/* two more entries for 0 and -1 (EOZ) */
+LUAI_DDEC const lu_byte luai_ctype_[UCHAR_MAX + 2];
+
+
+#else			/* }{ */
+
+/*
+** use standard C ctypes
+*/
+
+#include <ctype.h>
+
+
+#define lislalpha(c)	(isalpha(c) || (c) == '_')
+#define lislalnum(c)	(isalnum(c) || (c) == '_')
+#define lisdigit(c)	(isdigit(c))
+#define lisspace(c)	(isspace(c))
+#define lisprint(c)	(isprint(c))
+#define lisxdigit(c)	(isxdigit(c))
+
+#define ltolower(c)	(tolower(c))
+
+#endif			/* } */
+
+#endif
+
diff --git a/dep/lualib/ldblib.c b/dep/lualib/ldblib.c
new file mode 100644
index 0000000..c022694
--- /dev/null
+++ b/dep/lualib/ldblib.c
@@ -0,0 +1,398 @@
+/*
+** $Id: ldblib.c,v 1.132 2012/01/19 20:14:44 roberto Exp $
+** Interface from Lua to its debug API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldblib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define HOOKKEY		"_HKEY"
+
+
+
+static int db_getregistry (lua_State *L) {
+  lua_pushvalue(L, LUA_REGISTRYINDEX);
+  return 1;
+}
+
+
+static int db_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);  /* no metatable */
+  }
+  return 1;
+}
+
+
+static int db_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;  /* return 1st argument */
+}
+
+
+static int db_getuservalue (lua_State *L) {
+  if (lua_type(L, 1) != LUA_TUSERDATA)
+    lua_pushnil(L);
+  else
+    lua_getuservalue(L, 1);
+  return 1;
+}
+
+
+static int db_setuservalue (lua_State *L) {
+  if (lua_type(L, 1) == LUA_TLIGHTUSERDATA)
+    luaL_argerror(L, 1, "full userdata expected, got light userdata");
+  luaL_checktype(L, 1, LUA_TUSERDATA);
+  if (!lua_isnoneornil(L, 2))
+    luaL_checktype(L, 2, LUA_TTABLE);
+  lua_settop(L, 2);
+  lua_setuservalue(L, 1);
+  return 1;
+}
+
+
+static void settabss (lua_State *L, const char *i, const char *v) {
+  lua_pushstring(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static void settabsi (lua_State *L, const char *i, int v) {
+  lua_pushinteger(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static void settabsb (lua_State *L, const char *i, int v) {
+  lua_pushboolean(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static lua_State *getthread (lua_State *L, int *arg) {
+  if (lua_isthread(L, 1)) {
+    *arg = 1;
+    return lua_tothread(L, 1);
+  }
+  else {
+    *arg = 0;
+    return L;
+  }
+}
+
+
+static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
+  if (L == L1) {
+    lua_pushvalue(L, -2);
+    lua_remove(L, -3);
+  }
+  else
+    lua_xmove(L1, L, 1);
+  lua_setfield(L, -2, fname);
+}
+
+
+static int db_getinfo (lua_State *L) {
+  lua_Debug ar;
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  const char *options = luaL_optstring(L, arg+2, "flnStu");
+  if (lua_isnumber(L, arg+1)) {
+    if (!lua_getstack(L1, (int)lua_tointeger(L, arg+1), &ar)) {
+      lua_pushnil(L);  /* level out of range */
+      return 1;
+    }
+  }
+  else if (lua_isfunction(L, arg+1)) {
+    lua_pushfstring(L, ">%s", options);
+    options = lua_tostring(L, -1);
+    lua_pushvalue(L, arg+1);
+    lua_xmove(L, L1, 1);
+  }
+  else
+    return luaL_argerror(L, arg+1, "function or level expected");
+  if (!lua_getinfo(L1, options, &ar))
+    return luaL_argerror(L, arg+2, "invalid option");
+  lua_createtable(L, 0, 2);
+  if (strchr(options, 'S')) {
+    settabss(L, "source", ar.source);
+    settabss(L, "short_src", ar.short_src);
+    settabsi(L, "linedefined", ar.linedefined);
+    settabsi(L, "lastlinedefined", ar.lastlinedefined);
+    settabss(L, "what", ar.what);
+  }
+  if (strchr(options, 'l'))
+    settabsi(L, "currentline", ar.currentline);
+  if (strchr(options, 'u')) {
+    settabsi(L, "nups", ar.nups);
+    settabsi(L, "nparams", ar.nparams);
+    settabsb(L, "isvararg", ar.isvararg);
+  }
+  if (strchr(options, 'n')) {
+    settabss(L, "name", ar.name);
+    settabss(L, "namewhat", ar.namewhat);
+  }
+  if (strchr(options, 't'))
+    settabsb(L, "istailcall", ar.istailcall);
+  if (strchr(options, 'L'))
+    treatstackoption(L, L1, "activelines");
+  if (strchr(options, 'f'))
+    treatstackoption(L, L1, "func");
+  return 1;  /* return table */
+}
+
+
+static int db_getlocal (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  lua_Debug ar;
+  const char *name;
+  int nvar = luaL_checkint(L, arg+2);  /* local-variable index */
+  if (lua_isfunction(L, arg + 1)) {  /* function argument? */
+    lua_pushvalue(L, arg + 1);  /* push function */
+    lua_pushstring(L, lua_getlocal(L, NULL, nvar));  /* push local name */
+    return 1;
+  }
+  else {  /* stack-level argument */
+    if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+      return luaL_argerror(L, arg+1, "level out of range");
+    name = lua_getlocal(L1, &ar, nvar);
+    if (name) {
+      lua_xmove(L1, L, 1);  /* push local value */
+      lua_pushstring(L, name);  /* push name */
+      lua_pushvalue(L, -2);  /* re-order */
+      return 2;
+    }
+    else {
+      lua_pushnil(L);  /* no name (nor value) */
+      return 1;
+    }
+  }
+}
+
+
+static int db_setlocal (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  lua_Debug ar;
+  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+    return luaL_argerror(L, arg+1, "level out of range");
+  luaL_checkany(L, arg+3);
+  lua_settop(L, arg+3);
+  lua_xmove(L, L1, 1);
+  lua_pushstring(L, lua_setlocal(L1, &ar, luaL_checkint(L, arg+2)));
+  return 1;
+}
+
+
+static int auxupvalue (lua_State *L, int get) {
+  const char *name;
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
+  if (name == NULL) return 0;
+  lua_pushstring(L, name);
+  lua_insert(L, -(get+1));
+  return get + 1;
+}
+
+
+static int db_getupvalue (lua_State *L) {
+  return auxupvalue(L, 1);
+}
+
+
+static int db_setupvalue (lua_State *L) {
+  luaL_checkany(L, 3);
+  return auxupvalue(L, 0);
+}
+
+
+static int checkupval (lua_State *L, int argf, int argnup) {
+  lua_Debug ar;
+  int nup = luaL_checkint(L, argnup);
+  luaL_checktype(L, argf, LUA_TFUNCTION);
+  lua_pushvalue(L, argf);
+  lua_getinfo(L, ">u", &ar);
+  luaL_argcheck(L, 1 <= nup && nup <= ar.nups, argnup, "invalid upvalue index");
+  return nup;
+}
+
+
+static int db_upvalueid (lua_State *L) {
+  int n = checkupval(L, 1, 2);
+  lua_pushlightuserdata(L, lua_upvalueid(L, 1, n));
+  return 1;
+}
+
+
+static int db_upvaluejoin (lua_State *L) {
+  int n1 = checkupval(L, 1, 2);
+  int n2 = checkupval(L, 3, 4);
+  luaL_argcheck(L, !lua_iscfunction(L, 1), 1, "Lua function expected");
+  luaL_argcheck(L, !lua_iscfunction(L, 3), 3, "Lua function expected");
+  lua_upvaluejoin(L, 1, n1, 3, n2);
+  return 0;
+}
+
+
+#define gethooktable(L)	luaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY)
+
+
+static void hookf (lua_State *L, lua_Debug *ar) {
+  static const char *const hooknames[] =
+    {"call", "return", "line", "count", "tail call"};
+  gethooktable(L);
+  lua_pushthread(L);
+  lua_rawget(L, -2);
+  if (lua_isfunction(L, -1)) {
+    lua_pushstring(L, hooknames[(int)ar->event]);
+    if (ar->currentline >= 0)
+      lua_pushinteger(L, ar->currentline);
+    else lua_pushnil(L);
+    lua_assert(lua_getinfo(L, "lS", ar));
+    lua_call(L, 2, 0);
+  }
+}
+
+
+static int makemask (const char *smask, int count) {
+  int mask = 0;
+  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
+  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (count > 0) mask |= LUA_MASKCOUNT;
+  return mask;
+}
+
+
+static char *unmakemask (int mask, char *smask) {
+  int i = 0;
+  if (mask & LUA_MASKCALL) smask[i++] = 'c';
+  if (mask & LUA_MASKRET) smask[i++] = 'r';
+  if (mask & LUA_MASKLINE) smask[i++] = 'l';
+  smask[i] = '\0';
+  return smask;
+}
+
+
+static int db_sethook (lua_State *L) {
+  int arg, mask, count;
+  lua_Hook func;
+  lua_State *L1 = getthread(L, &arg);
+  if (lua_isnoneornil(L, arg+1)) {
+    lua_settop(L, arg+1);
+    func = NULL; mask = 0; count = 0;  /* turn off hooks */
+  }
+  else {
+    const char *smask = luaL_checkstring(L, arg+2);
+    luaL_checktype(L, arg+1, LUA_TFUNCTION);
+    count = luaL_optint(L, arg+3, 0);
+    func = hookf; mask = makemask(smask, count);
+  }
+  if (gethooktable(L) == 0) {  /* creating hook table? */
+    lua_pushstring(L, "k");
+    lua_setfield(L, -2, "__mode");  /** hooktable.__mode = "k" */
+    lua_pushvalue(L, -1);
+    lua_setmetatable(L, -2);  /* setmetatable(hooktable) = hooktable */
+  }
+  lua_pushthread(L1); lua_xmove(L1, L, 1);
+  lua_pushvalue(L, arg+1);
+  lua_rawset(L, -3);  /* set new hook */
+  lua_sethook(L1, func, mask, count);  /* set hooks */
+  return 0;
+}
+
+
+static int db_gethook (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  char buff[5];
+  int mask = lua_gethookmask(L1);
+  lua_Hook hook = lua_gethook(L1);
+  if (hook != NULL && hook != hookf)  /* external hook? */
+    lua_pushliteral(L, "external hook");
+  else {
+    gethooktable(L);
+    lua_pushthread(L1); lua_xmove(L1, L, 1);
+    lua_rawget(L, -2);   /* get hook */
+    lua_remove(L, -2);  /* remove hook table */
+  }
+  lua_pushstring(L, unmakemask(mask, buff));
+  lua_pushinteger(L, lua_gethookcount(L1));
+  return 3;
+}
+
+
+static int db_debug (lua_State *L) {
+  for (;;) {
+    char buffer[250];
+    luai_writestringerror("%s", "lua_debug> ");
+    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
+        strcmp(buffer, "cont\n") == 0)
+      return 0;
+    if (luaL_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
+        lua_pcall(L, 0, 0, 0))
+      luai_writestringerror("%s\n", lua_tostring(L, -1));
+    lua_settop(L, 0);  /* remove eventual returns */
+  }
+}
+
+
+static int db_traceback (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  const char *msg = lua_tostring(L, arg + 1);
+  if (msg == NULL && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */
+    lua_pushvalue(L, arg + 1);  /* return it untouched */
+  else {
+    int level = luaL_optint(L, arg + 2, (L == L1) ? 1 : 0);
+    luaL_traceback(L, L1, msg, level);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg dblib[] = {
+  {"debug", db_debug},
+  {"getuservalue", db_getuservalue},
+  {"gethook", db_gethook},
+  {"getinfo", db_getinfo},
+  {"getlocal", db_getlocal},
+  {"getregistry", db_getregistry},
+  {"getmetatable", db_getmetatable},
+  {"getupvalue", db_getupvalue},
+  {"upvaluejoin", db_upvaluejoin},
+  {"upvalueid", db_upvalueid},
+  {"setuservalue", db_setuservalue},
+  {"sethook", db_sethook},
+  {"setlocal", db_setlocal},
+  {"setmetatable", db_setmetatable},
+  {"setupvalue", db_setupvalue},
+  {"traceback", db_traceback},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_debug (lua_State *L) {
+  luaL_newlib(L, dblib);
+  return 1;
+}
+
diff --git a/dep/lualib/ldebug.c b/dep/lualib/ldebug.c
new file mode 100644
index 0000000..43f8f04
--- /dev/null
+++ b/dep/lualib/ldebug.c
@@ -0,0 +1,580 @@
+/*
+** $Id: ldebug.c,v 2.89 2012/01/20 22:05:50 roberto Exp $
+** Debug Interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <string.h>
+
+
+#define ldebug_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+#define noLuaClosure(f)		((f) == NULL || (f)->c.tt == LUA_TCCL)
+
+
+static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);
+
+
+static int currentpc (CallInfo *ci) {
+  lua_assert(isLua(ci));
+  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);
+}
+
+
+static int currentline (CallInfo *ci) {
+  return getfuncline(ci_func(ci)->p, currentpc(ci));
+}
+
+
+/*
+** this function can be called asynchronous (e.g. during a signal)
+*/
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+  if (func == NULL || mask == 0) {  /* turn off hooks? */
+    mask = 0;
+    func = NULL;
+  }
+  if (isLua(L->ci))
+    L->oldpc = L->ci->u.l.savedpc;
+  L->hook = func;
+  L->basehookcount = count;
+  resethookcount(L);
+  L->hookmask = cast_byte(mask);
+  return 1;
+}
+
+
+LUA_API lua_Hook lua_gethook (lua_State *L) {
+  return L->hook;
+}
+
+
+LUA_API int lua_gethookmask (lua_State *L) {
+  return L->hookmask;
+}
+
+
+LUA_API int lua_gethookcount (lua_State *L) {
+  return L->basehookcount;
+}
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
+  int status;
+  CallInfo *ci;
+  if (level < 0) return 0;  /* invalid (negative) level */
+  lua_lock(L);
+  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)
+    level--;
+  if (level == 0 && ci != &L->base_ci) {  /* level found? */
+    status = 1;
+    ar->i_ci = ci;
+  }
+  else status = 0;  /* no such level */
+  lua_unlock(L);
+  return status;
+}
+
+
+static const char *upvalname (Proto *p, int uv) {
+  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);
+  if (s == NULL) return "?";
+  else return getstr(s);
+}
+
+
+static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
+  int nparams = clLvalue(ci->func)->p->numparams;
+  if (n >= ci->u.l.base - ci->func - nparams)
+    return NULL;  /* no such vararg */
+  else {
+    *pos = ci->func + nparams + n;
+    return "(*vararg)";  /* generic name for any vararg */
+  }
+}
+
+
+static const char *findlocal (lua_State *L, CallInfo *ci, int n,
+                              StkId *pos) {
+  const char *name = NULL;
+  StkId base;
+  if (isLua(ci)) {
+    if (n < 0)  /* access to vararg values? */
+      return findvararg(ci, -n, pos);
+    else {
+      base = ci->u.l.base;
+      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));
+    }
+  }
+  else
+    base = ci->func + 1;
+  if (name == NULL) {  /* no 'standard' name? */
+    StkId limit = (ci == L->ci) ? L->top : ci->next->func;
+    if (limit - base >= n && n > 0)  /* is 'n' inside 'ci' stack? */
+      name = "(*temporary)";  /* generic name for any valid slot */
+    else
+      return NULL;  /* no name */
+  }
+  *pos = base + (n - 1);
+  return name;
+}
+
+
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  lua_lock(L);
+  if (ar == NULL) {  /* information about non-active function? */
+    if (!isLfunction(L->top - 1))  /* not a Lua function? */
+      name = NULL;
+    else  /* consider live variables at function start (parameters) */
+      name = luaF_getlocalname(clLvalue(L->top - 1)->p, n, 0);
+  }
+  else {  /* active function; get information through 'ar' */
+    StkId pos = 0;  /* to avoid warnings */
+    name = findlocal(L, ar->i_ci, n, &pos);
+    if (name) {
+      setobj2s(L, L->top, pos);
+      api_incr_top(L);
+    }
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
+  StkId pos = 0;  /* to avoid warnings */
+  const char *name = findlocal(L, ar->i_ci, n, &pos);
+  lua_lock(L);
+  if (name)
+    setobjs2s(L, pos, L->top - 1);
+  L->top--;  /* pop value */
+  lua_unlock(L);
+  return name;
+}
+
+
+static void funcinfo (lua_Debug *ar, Closure *cl) {
+  if (noLuaClosure(cl)) {
+    ar->source = "=[C]";
+    ar->linedefined = -1;
+    ar->lastlinedefined = -1;
+    ar->what = "C";
+  }
+  else {
+    Proto *p = cl->l.p;
+    ar->source = p->source ? getstr(p->source) : "=?";
+    ar->linedefined = p->linedefined;
+    ar->lastlinedefined = p->lastlinedefined;
+    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
+  }
+  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+}
+
+
+static void collectvalidlines (lua_State *L, Closure *f) {
+  if (noLuaClosure(f)) {
+    setnilvalue(L->top);
+    incr_top(L);
+  }
+  else {
+    int i;
+    TValue v;
+    int *lineinfo = f->l.p->lineinfo;
+    Table *t = luaH_new(L);  /* new table to store active lines */
+    sethvalue(L, L->top, t);  /* push it on stack */
+    incr_top(L);
+    setbvalue(&v, 1);  /* boolean 'true' to be the value of all indices */
+    for (i = 0; i < f->l.p->sizelineinfo; i++)  /* for all lines with code */
+      luaH_setint(L, t, lineinfo[i], &v);  /* table[line] = true */
+  }
+}
+
+
+static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
+                       Closure *f, CallInfo *ci) {
+  int status = 1;
+  for (; *what; what++) {
+    switch (*what) {
+      case 'S': {
+        funcinfo(ar, f);
+        break;
+      }
+      case 'l': {
+        ar->currentline = (ci && isLua(ci)) ? currentline(ci) : -1;
+        break;
+      }
+      case 'u': {
+        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;
+        if (noLuaClosure(f)) {
+          ar->isvararg = 1;
+          ar->nparams = 0;
+        }
+        else {
+          ar->isvararg = f->l.p->is_vararg;
+          ar->nparams = f->l.p->numparams;
+        }
+        break;
+      }
+      case 't': {
+        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;
+        break;
+      }
+      case 'n': {
+        /* calling function is a known Lua function? */
+        if (ci && !(ci->callstatus & CIST_TAIL) && isLua(ci->previous))
+          ar->namewhat = getfuncname(L, ci->previous, &ar->name);
+        else
+          ar->namewhat = NULL;
+        if (ar->namewhat == NULL) {
+          ar->namewhat = "";  /* not found */
+          ar->name = NULL;
+        }
+        break;
+      }
+      case 'L':
+      case 'f':  /* handled by lua_getinfo */
+        break;
+      default: status = 0;  /* invalid option */
+    }
+  }
+  return status;
+}
+
+
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
+  int status;
+  Closure *cl;
+  CallInfo *ci;
+  StkId func;
+  lua_lock(L);
+  if (*what == '>') {
+    ci = NULL;
+    func = L->top - 1;
+    api_check(L, ttisfunction(func), "function expected");
+    what++;  /* skip the '>' */
+    L->top--;  /* pop function */
+  }
+  else {
+    ci = ar->i_ci;
+    func = ci->func;
+    lua_assert(ttisfunction(ci->func));
+  }
+  cl = ttisclosure(func) ? clvalue(func) : NULL;
+  status = auxgetinfo(L, what, ar, cl, ci);
+  if (strchr(what, 'f')) {
+    setobjs2s(L, L->top, func);
+    incr_top(L);
+  }
+  if (strchr(what, 'L'))
+    collectvalidlines(L, cl);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** {======================================================
+** Symbolic Execution
+** =======================================================
+*/
+
+static const char *getobjname (Proto *p, int lastpc, int reg,
+                               const char **name);
+
+
+/*
+** find a "name" for the RK value 'c'
+*/
+static void kname (Proto *p, int pc, int c, const char **name) {
+  if (ISK(c)) {  /* is 'c' a constant? */
+    TValue *kvalue = &p->k[INDEXK(c)];
+    if (ttisstring(kvalue)) {  /* literal constant? */
+      *name = svalue(kvalue);  /* it is its own name */
+      return;
+    }
+    /* else no reasonable name found */
+  }
+  else {  /* 'c' is a register */
+    const char *what = getobjname(p, pc, c, name); /* search for 'c' */
+    if (what && *what == 'c') {  /* found a constant name? */
+      return;  /* 'name' already filled */
+    }
+    /* else no reasonable name found */
+  }
+  *name = "?";  /* no reasonable name found */
+}
+
+
+/*
+** try to find last instruction before 'lastpc' that modified register 'reg'
+*/
+static int findsetreg (Proto *p, int lastpc, int reg) {
+  int pc;
+  int setreg = -1;  /* keep last instruction that changed 'reg' */
+  for (pc = 0; pc < lastpc; pc++) {
+    Instruction i = p->code[pc];
+    OpCode op = GET_OPCODE(i);
+    int a = GETARG_A(i);
+    switch (op) {
+      case OP_LOADNIL: {
+        int b = GETARG_B(i);
+        if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */
+          setreg = pc;
+        break;
+      }
+      case OP_TFORCALL: {
+        if (reg >= a + 2) setreg = pc;  /* affect all regs above its base */
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        if (reg >= a) setreg = pc;  /* affect all registers above base */
+        break;
+      }
+      case OP_JMP: {
+        int b = GETARG_sBx(i);
+        int dest = pc + 1 + b;
+        /* jump is forward and do not skip `lastpc'? */
+        if (pc < dest && dest <= lastpc)
+          pc += b;  /* do the jump */
+        break;
+      }
+      case OP_TEST: {
+        if (reg == a) setreg = pc;  /* jumped code can change 'a' */
+        break;
+      }
+      default:
+        if (testAMode(op) && reg == a)  /* any instruction that set A */
+          setreg = pc;
+        break;
+    }
+  }
+  return setreg;
+}
+
+
+static const char *getobjname (Proto *p, int lastpc, int reg,
+                               const char **name) {
+  int pc;
+  *name = luaF_getlocalname(p, reg + 1, lastpc);
+  if (*name)  /* is a local? */
+    return "local";
+  /* else try symbolic execution */
+  pc = findsetreg(p, lastpc, reg);
+  if (pc != -1) {  /* could find instruction? */
+    Instruction i = p->code[pc];
+    OpCode op = GET_OPCODE(i);
+    switch (op) {
+      case OP_MOVE: {
+        int b = GETARG_B(i);  /* move from 'b' to 'a' */
+        if (b < GETARG_A(i))
+          return getobjname(p, pc, b, name);  /* get name for 'b' */
+        break;
+      }
+      case OP_GETTABUP:
+      case OP_GETTABLE: {
+        int k = GETARG_C(i);  /* key index */
+        int t = GETARG_B(i);  /* table index */
+        const char *vn = (op == OP_GETTABLE)  /* name of indexed variable */
+                         ? luaF_getlocalname(p, t + 1, pc)
+                         : upvalname(p, t);
+        kname(p, pc, k, name);
+        return (vn && strcmp(vn, LUA_ENV) == 0) ? "global" : "field";
+      }
+      case OP_GETUPVAL: {
+        *name = upvalname(p, GETARG_B(i));
+        return "upvalue";
+      }
+      case OP_LOADK:
+      case OP_LOADKX: {
+        int b = (op == OP_LOADK) ? GETARG_Bx(i)
+                                 : GETARG_Ax(p->code[pc + 1]);
+        if (ttisstring(&p->k[b])) {
+          *name = svalue(&p->k[b]);
+          return "constant";
+        }
+        break;
+      }
+      case OP_SELF: {
+        int k = GETARG_C(i);  /* key index */
+        kname(p, pc, k, name);
+        return "method";
+      }
+      default: break;  /* go through to return NULL */
+    }
+  }
+  return NULL;  /* could not find reasonable name */
+}
+
+
+static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
+  TMS tm;
+  Proto *p = ci_func(ci)->p;  /* calling function */
+  int pc = currentpc(ci);  /* calling instruction index */
+  Instruction i = p->code[pc];  /* calling instruction */
+  switch (GET_OPCODE(i)) {
+    case OP_CALL:
+    case OP_TAILCALL:  /* get function name */
+      return getobjname(p, pc, GETARG_A(i), name);
+    case OP_TFORCALL: {  /* for iterator */
+      *name = "for iterator";
+       return "for iterator";
+    }
+    /* all other instructions can call only through metamethods */
+    case OP_SELF:
+    case OP_GETTABUP:
+    case OP_GETTABLE: tm = TM_INDEX; break;
+    case OP_SETTABUP:
+    case OP_SETTABLE: tm = TM_NEWINDEX; break;
+    case OP_EQ: tm = TM_EQ; break;
+    case OP_ADD: tm = TM_ADD; break;
+    case OP_SUB: tm = TM_SUB; break;
+    case OP_MUL: tm = TM_MUL; break;
+    case OP_DIV: tm = TM_DIV; break;
+    case OP_MOD: tm = TM_MOD; break;
+    case OP_POW: tm = TM_POW; break;
+    case OP_UNM: tm = TM_UNM; break;
+    case OP_LEN: tm = TM_LEN; break;
+    case OP_LT: tm = TM_LT; break;
+    case OP_LE: tm = TM_LE; break;
+    case OP_CONCAT: tm = TM_CONCAT; break;
+    default:
+      return NULL;  /* else no useful name can be found */
+  }
+  *name = getstr(G(L)->tmname[tm]);
+  return "metamethod";
+}
+
+/* }====================================================== */
+
+
+
+/*
+** only ANSI way to check whether a pointer points to an array
+** (used only for error messages, so efficiency is not a big concern)
+*/
+static int isinstack (CallInfo *ci, const TValue *o) {
+  StkId p;
+  for (p = ci->u.l.base; p < ci->top; p++)
+    if (o == p) return 1;
+  return 0;
+}
+
+
+static const char *getupvalname (CallInfo *ci, const TValue *o,
+                                 const char **name) {
+  LClosure *c = ci_func(ci);
+  int i;
+  for (i = 0; i < c->nupvalues; i++) {
+    if (c->upvals[i]->v == o) {
+      *name = upvalname(c->p, i);
+      return "upvalue";
+    }
+  }
+  return NULL;
+}
+
+
+l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
+  CallInfo *ci = L->ci;
+  const char *name = NULL;
+  const char *t = objtypename(o);
+  const char *kind = NULL;
+  if (isLua(ci)) {
+    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */
+    if (!kind && isinstack(ci, o))  /* no? try a register */
+      kind = getobjname(ci_func(ci)->p, currentpc(ci),
+                        cast_int(o - ci->u.l.base), &name);
+  }
+  if (kind)
+    luaG_runerror(L, "attempt to %s %s " LUA_QS " (a %s value)",
+                op, kind, name, t);
+  else
+    luaG_runerror(L, "attempt to %s a %s value", op, t);
+}
+
+
+l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
+  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
+  lua_assert(!ttisstring(p1) && !ttisnumber(p2));
+  luaG_typeerror(L, p1, "concatenate");
+}
+
+
+l_noret luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
+  TValue temp;
+  if (luaV_tonumber(p1, &temp) == NULL)
+    p2 = p1;  /* first operand is wrong */
+  luaG_typeerror(L, p2, "perform arithmetic on");
+}
+
+
+l_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
+  const char *t1 = objtypename(p1);
+  const char *t2 = objtypename(p2);
+  if (t1 == t2)
+    luaG_runerror(L, "attempt to compare two %s values", t1);
+  else
+    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
+}
+
+
+static void addinfo (lua_State *L, const char *msg) {
+  CallInfo *ci = L->ci;
+  if (isLua(ci)) {  /* is Lua code? */
+    char buff[LUA_IDSIZE];  /* add file:line information */
+    int line = currentline(ci);
+    TString *src = ci_func(ci)->p->source;
+    if (src)
+      luaO_chunkid(buff, getstr(src), LUA_IDSIZE);
+    else {  /* no source available; use "?" instead */
+      buff[0] = '?'; buff[1] = '\0';
+    }
+    luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
+  }
+}
+
+
+l_noret luaG_errormsg (lua_State *L) {
+  if (L->errfunc != 0) {  /* is there an error handling function? */
+    StkId errfunc = restorestack(L, L->errfunc);
+    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
+    setobjs2s(L, L->top, L->top - 1);  /* move argument */
+    setobjs2s(L, L->top - 1, errfunc);  /* push function */
+    incr_top(L);
+    luaD_call(L, L->top - 2, 1, 0);  /* call it */
+  }
+  luaD_throw(L, LUA_ERRRUN);
+}
+
+
+l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  addinfo(L, luaO_pushvfstring(L, fmt, argp));
+  va_end(argp);
+  luaG_errormsg(L);
+}
+
diff --git a/dep/lualib/ldebug.h b/dep/lualib/ldebug.h
new file mode 100644
index 0000000..fe39556
--- /dev/null
+++ b/dep/lualib/ldebug.h
@@ -0,0 +1,34 @@
+/*
+** $Id: ldebug.h,v 2.7 2011/10/07 20:45:19 roberto Exp $
+** Auxiliary functions from Debug Interface module
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldebug_h
+#define ldebug_h
+
+
+#include "lstate.h"
+
+
+#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)
+
+#define getfuncline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
+
+#define resethookcount(L)	(L->hookcount = L->basehookcount)
+
+/* Active Lua function (given call info) */
+#define ci_func(ci)		(clLvalue((ci)->func))
+
+
+LUAI_FUNC l_noret luaG_typeerror (lua_State *L, const TValue *o,
+                                                const char *opname);
+LUAI_FUNC l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2);
+LUAI_FUNC l_noret luaG_aritherror (lua_State *L, const TValue *p1,
+                                                 const TValue *p2);
+LUAI_FUNC l_noret luaG_ordererror (lua_State *L, const TValue *p1,
+                                                 const TValue *p2);
+LUAI_FUNC l_noret luaG_runerror (lua_State *L, const char *fmt, ...);
+LUAI_FUNC l_noret luaG_errormsg (lua_State *L);
+
+#endif
diff --git a/dep/lualib/ldo.c b/dep/lualib/ldo.c
new file mode 100644
index 0000000..d18e33c
--- /dev/null
+++ b/dep/lualib/ldo.c
@@ -0,0 +1,668 @@
+/*
+** $Id: ldo.c,v 2.105 2012/06/08 15:14:04 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <setjmp.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldo_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+#include "lzio.h"
+
+
+
+
+/*
+** {======================================================
+** Error-recovery functions
+** =======================================================
+*/
+
+/*
+** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By
+** default, Lua handles errors with exceptions when compiling as
+** C++ code, with _longjmp/_setjmp when asked to use them, and with
+** longjmp/setjmp otherwise.
+*/
+#if !defined(LUAI_THROW)
+
+#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)
+/* C++ exceptions */
+#define LUAI_THROW(L,c)		throw(c)
+#define LUAI_TRY(L,c,a) \
+	try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
+#define luai_jmpbuf		int  /* dummy variable */
+
+#elif defined(LUA_USE_ULONGJMP)
+/* in Unix, try _longjmp/_setjmp (more efficient) */
+#define LUAI_THROW(L,c)		_longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)		if (_setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf		jmp_buf
+
+#else
+/* default handling with long jumps */
+#define LUAI_THROW(L,c)		longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)		if (setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf		jmp_buf
+
+#endif
+
+#endif
+
+
+
+/* chain list of long jump buffers */
+struct lua_longjmp {
+  struct lua_longjmp *previous;
+  luai_jmpbuf b;
+  volatile int status;  /* error code */
+};
+
+
+static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
+  switch (errcode) {
+    case LUA_ERRMEM: {  /* memory error? */
+      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */
+      break;
+    }
+    case LUA_ERRERR: {
+      setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
+      break;
+    }
+    default: {
+      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */
+      break;
+    }
+  }
+  L->top = oldtop + 1;
+}
+
+
+l_noret luaD_throw (lua_State *L, int errcode) {
+  if (L->errorJmp) {  /* thread has an error handler? */
+    L->errorJmp->status = errcode;  /* set status */
+    LUAI_THROW(L, L->errorJmp);  /* jump to it */
+  }
+  else {  /* thread has no error handler */
+    L->status = cast_byte(errcode);  /* mark it as dead */
+    if (G(L)->mainthread->errorJmp) {  /* main thread has a handler? */
+      setobjs2s(L, G(L)->mainthread->top++, L->top - 1);  /* copy error obj. */
+      luaD_throw(G(L)->mainthread, errcode);  /* re-throw in main thread */
+    }
+    else {  /* no handler at all; abort */
+      if (G(L)->panic) {  /* panic function? */
+        lua_unlock(L);
+        G(L)->panic(L);  /* call it (last chance to jump out) */
+      }
+      abort();
+    }
+  }
+}
+
+
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
+  unsigned short oldnCcalls = L->nCcalls;
+  struct lua_longjmp lj;
+  lj.status = LUA_OK;
+  lj.previous = L->errorJmp;  /* chain new error handler */
+  L->errorJmp = &lj;
+  LUAI_TRY(L, &lj,
+    (*f)(L, ud);
+  );
+  L->errorJmp = lj.previous;  /* restore old error handler */
+  L->nCcalls = oldnCcalls;
+  return lj.status;
+}
+
+/* }====================================================== */
+
+
+static void correctstack (lua_State *L, TValue *oldstack) {
+  CallInfo *ci;
+  GCObject *up;
+  L->top = (L->top - oldstack) + L->stack;
+  for (up = L->openupval; up != NULL; up = up->gch.next)
+    gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {
+    ci->top = (ci->top - oldstack) + L->stack;
+    ci->func = (ci->func - oldstack) + L->stack;
+    if (isLua(ci))
+      ci->u.l.base = (ci->u.l.base - oldstack) + L->stack;
+  }
+}
+
+
+/* some space for error handling */
+#define ERRORSTACKSIZE	(LUAI_MAXSTACK + 200)
+
+
+void luaD_reallocstack (lua_State *L, int newsize) {
+  TValue *oldstack = L->stack;
+  int lim = L->stacksize;
+  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);
+  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);
+  luaM_reallocvector(L, L->stack, L->stacksize, newsize, TValue);
+  for (; lim < newsize; lim++)
+    setnilvalue(L->stack + lim); /* erase new segment */
+  L->stacksize = newsize;
+  L->stack_last = L->stack + newsize - EXTRA_STACK;
+  correctstack(L, oldstack);
+}
+
+
+void luaD_growstack (lua_State *L, int n) {
+  int size = L->stacksize;
+  if (size > LUAI_MAXSTACK)  /* error after extra size? */
+    luaD_throw(L, LUA_ERRERR);
+  else {
+    int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;
+    int newsize = 2 * size;
+    if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;
+    if (newsize < needed) newsize = needed;
+    if (newsize > LUAI_MAXSTACK) {  /* stack overflow? */
+      luaD_reallocstack(L, ERRORSTACKSIZE);
+      luaG_runerror(L, "stack overflow");
+    }
+    else
+      luaD_reallocstack(L, newsize);
+  }
+}
+
+
+static int stackinuse (lua_State *L) {
+  CallInfo *ci;
+  StkId lim = L->top;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {
+    lua_assert(ci->top <= L->stack_last);
+    if (lim < ci->top) lim = ci->top;
+  }
+  return cast_int(lim - L->stack) + 1;  /* part of stack in use */
+}
+
+
+void luaD_shrinkstack (lua_State *L) {
+  int inuse = stackinuse(L);
+  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;
+  if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;
+  if (inuse > LUAI_MAXSTACK ||  /* handling stack overflow? */
+      goodsize >= L->stacksize)  /* would grow instead of shrink? */
+    condmovestack(L);  /* don't change stack (change only for debugging) */
+  else
+    luaD_reallocstack(L, goodsize);  /* shrink it */
+}
+
+
+void luaD_hook (lua_State *L, int event, int line) {
+  lua_Hook hook = L->hook;
+  if (hook && L->allowhook) {
+    CallInfo *ci = L->ci;
+    ptrdiff_t top = savestack(L, L->top);
+    ptrdiff_t ci_top = savestack(L, ci->top);
+    lua_Debug ar;
+    ar.event = event;
+    ar.currentline = line;
+    ar.i_ci = ci;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    ci->top = L->top + LUA_MINSTACK;
+    lua_assert(ci->top <= L->stack_last);
+    L->allowhook = 0;  /* cannot call hooks inside a hook */
+    ci->callstatus |= CIST_HOOKED;
+    lua_unlock(L);
+    (*hook)(L, &ar);
+    lua_lock(L);
+    lua_assert(!L->allowhook);
+    L->allowhook = 1;
+    ci->top = restorestack(L, ci_top);
+    L->top = restorestack(L, top);
+    ci->callstatus &= ~CIST_HOOKED;
+  }
+}
+
+
+static void callhook (lua_State *L, CallInfo *ci) {
+  int hook = LUA_HOOKCALL;
+  ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */
+  if (isLua(ci->previous) &&
+      GET_OPCODE(*(ci->previous->u.l.savedpc - 1)) == OP_TAILCALL) {
+    ci->callstatus |= CIST_TAIL;
+    hook = LUA_HOOKTAILCALL;
+  }
+  luaD_hook(L, hook, -1);
+  ci->u.l.savedpc--;  /* correct 'pc' */
+}
+
+
+static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
+  int i;
+  int nfixargs = p->numparams;
+  StkId base, fixed;
+  lua_assert(actual >= nfixargs);
+  /* move fixed parameters to final position */
+  fixed = L->top - actual;  /* first fixed argument */
+  base = L->top;  /* final position of first argument */
+  for (i=0; i<nfixargs; i++) {
+    setobjs2s(L, L->top++, fixed + i);
+    setnilvalue(fixed + i);
+  }
+  return base;
+}
+
+
+static StkId tryfuncTM (lua_State *L, StkId func) {
+  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
+  StkId p;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(tm))
+    luaG_typeerror(L, func, "call");
+  /* Open a hole inside the stack at `func' */
+  for (p = L->top; p > func; p--) setobjs2s(L, p, p-1);
+  incr_top(L);
+  func = restorestack(L, funcr);  /* previous call may change stack */
+  setobj2s(L, func, tm);  /* tag method is the new function to be called */
+  return func;
+}
+
+
+
+#define next_ci(L) (L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)))
+
+
+/*
+** returns true if function has been executed (C function)
+*/
+int luaD_precall (lua_State *L, StkId func, int nresults) {
+  lua_CFunction f;
+  CallInfo *ci;
+  int n;  /* number of arguments (Lua) or returns (C) */
+  ptrdiff_t funcr = savestack(L, func);
+  switch (ttype(func)) {
+    case LUA_TLCF:  /* light C function */
+      f = fvalue(func);
+      goto Cfunc;
+    case LUA_TCCL: {  /* C closure */
+      f = clCvalue(func)->f;
+     Cfunc:
+      luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+      ci = next_ci(L);  /* now 'enter' new function */
+      ci->nresults = nresults;
+      ci->func = restorestack(L, funcr);
+      ci->top = L->top + LUA_MINSTACK;
+      lua_assert(ci->top <= L->stack_last);
+      ci->callstatus = 0;
+      if (L->hookmask & LUA_MASKCALL)
+        luaD_hook(L, LUA_HOOKCALL, -1);
+      lua_unlock(L);
+      n = (*f)(L);  /* do the actual call */
+      lua_lock(L);
+      api_checknelems(L, n);
+      luaD_poscall(L, L->top - n);
+      return 1;
+    }
+    case LUA_TLCL: {  /* Lua function: prepare its call */
+      StkId base;
+      Proto *p = clLvalue(func)->p;
+      luaD_checkstack(L, p->maxstacksize);
+      func = restorestack(L, funcr);
+      n = cast_int(L->top - func) - 1;  /* number of real arguments */
+      for (; n < p->numparams; n++)
+        setnilvalue(L->top++);  /* complete missing arguments */
+      base = (!p->is_vararg) ? func + 1 : adjust_varargs(L, p, n);
+      ci = next_ci(L);  /* now 'enter' new function */
+      ci->nresults = nresults;
+      ci->func = func;
+      ci->u.l.base = base;
+      ci->top = base + p->maxstacksize;
+      lua_assert(ci->top <= L->stack_last);
+      ci->u.l.savedpc = p->code;  /* starting point */
+      ci->callstatus = CIST_LUA;
+      L->top = ci->top;
+      if (L->hookmask & LUA_MASKCALL)
+        callhook(L, ci);
+      return 0;
+    }
+    default: {  /* not a function */
+      func = tryfuncTM(L, func);  /* retry with 'function' tag method */
+      return luaD_precall(L, func, nresults);  /* now it must be a function */
+    }
+  }
+}
+
+
+int luaD_poscall (lua_State *L, StkId firstResult) {
+  StkId res;
+  int wanted, i;
+  CallInfo *ci = L->ci;
+  if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE)) {
+    if (L->hookmask & LUA_MASKRET) {
+      ptrdiff_t fr = savestack(L, firstResult);  /* hook may change stack */
+      luaD_hook(L, LUA_HOOKRET, -1);
+      firstResult = restorestack(L, fr);
+    }
+    L->oldpc = ci->previous->u.l.savedpc;  /* 'oldpc' for caller function */
+  }
+  res = ci->func;  /* res == final position of 1st result */
+  wanted = ci->nresults;
+  L->ci = ci = ci->previous;  /* back to caller */
+  /* move results to correct place */
+  for (i = wanted; i != 0 && firstResult < L->top; i--)
+    setobjs2s(L, res++, firstResult++);
+  while (i-- > 0)
+    setnilvalue(res++);
+  L->top = res;
+  return (wanted - LUA_MULTRET);  /* 0 iff wanted == LUA_MULTRET */
+}
+
+
+/*
+** Call a function (C or Lua). The function to be called is at *func.
+** The arguments are on the stack, right after the function.
+** When returns, all the results are on the stack, starting at the original
+** function position.
+*/
+void luaD_call (lua_State *L, StkId func, int nResults, int allowyield) {
+  if (++L->nCcalls >= LUAI_MAXCCALLS) {
+    if (L->nCcalls == LUAI_MAXCCALLS)
+      luaG_runerror(L, "C stack overflow");
+    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))
+      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
+  }
+  if (!allowyield) L->nny++;
+  if (!luaD_precall(L, func, nResults))  /* is a Lua function? */
+    luaV_execute(L);  /* call it */
+  if (!allowyield) L->nny--;
+  L->nCcalls--;
+  luaC_checkGC(L);
+}
+
+
+static void finishCcall (lua_State *L) {
+  CallInfo *ci = L->ci;
+  int n;
+  lua_assert(ci->u.c.k != NULL);  /* must have a continuation */
+  lua_assert(L->nny == 0);
+  /* finish 'lua_callk' */
+  adjustresults(L, ci->nresults);
+  /* call continuation function */
+  if (!(ci->callstatus & CIST_STAT))  /* no call status? */
+    ci->u.c.status = LUA_YIELD;  /* 'default' status */
+  lua_assert(ci->u.c.status != LUA_OK);
+  ci->callstatus = (ci->callstatus & ~(CIST_YPCALL | CIST_STAT)) | CIST_YIELDED;
+  lua_unlock(L);
+  n = (*ci->u.c.k)(L);
+  lua_lock(L);
+  api_checknelems(L, n);
+  /* finish 'luaD_precall' */
+  luaD_poscall(L, L->top - n);
+}
+
+
+static void unroll (lua_State *L, void *ud) {
+  UNUSED(ud);
+  for (;;) {
+    if (L->ci == &L->base_ci)  /* stack is empty? */
+      return;  /* coroutine finished normally */
+    if (!isLua(L->ci))  /* C function? */
+      finishCcall(L);
+    else {  /* Lua function */
+      luaV_finishOp(L);  /* finish interrupted instruction */
+      luaV_execute(L);  /* execute down to higher C 'boundary' */
+    }
+  }
+}
+
+
+/*
+** check whether thread has a suspended protected call
+*/
+static CallInfo *findpcall (lua_State *L) {
+  CallInfo *ci;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */
+    if (ci->callstatus & CIST_YPCALL)
+      return ci;
+  }
+  return NULL;  /* no pending pcall */
+}
+
+
+static int recover (lua_State *L, int status) {
+  StkId oldtop;
+  CallInfo *ci = findpcall(L);
+  if (ci == NULL) return 0;  /* no recovery point */
+  /* "finish" luaD_pcall */
+  oldtop = restorestack(L, ci->extra);
+  luaF_close(L, oldtop);
+  seterrorobj(L, status, oldtop);
+  L->ci = ci;
+  L->allowhook = ci->u.c.old_allowhook;
+  L->nny = 0;  /* should be zero to be yieldable */
+  luaD_shrinkstack(L);
+  L->errfunc = ci->u.c.old_errfunc;
+  ci->callstatus |= CIST_STAT;  /* call has error status */
+  ci->u.c.status = status;  /* (here it is) */
+  return 1;  /* continue running the coroutine */
+}
+
+
+/*
+** signal an error in the call to 'resume', not in the execution of the
+** coroutine itself. (Such errors should not be handled by any coroutine
+** error handler and should not kill the coroutine.)
+*/
+static l_noret resume_error (lua_State *L, const char *msg, StkId firstArg) {
+  L->top = firstArg;  /* remove args from the stack */
+  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */
+  incr_top(L);
+  luaD_throw(L, -1);  /* jump back to 'lua_resume' */
+}
+
+
+/*
+** do the work for 'lua_resume' in protected mode
+*/
+static void resume (lua_State *L, void *ud) {
+  int nCcalls = L->nCcalls;
+  StkId firstArg = cast(StkId, ud);
+  CallInfo *ci = L->ci;
+  if (nCcalls >= LUAI_MAXCCALLS)
+    resume_error(L, "C stack overflow", firstArg);
+  if (L->status == LUA_OK) {  /* may be starting a coroutine */
+    if (ci != &L->base_ci)  /* not in base level? */
+      resume_error(L, "cannot resume non-suspended coroutine", firstArg);
+    /* coroutine is in base level; start running it */
+    if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))  /* Lua function? */
+      luaV_execute(L);  /* call it */
+  }
+  else if (L->status != LUA_YIELD)
+    resume_error(L, "cannot resume dead coroutine", firstArg);
+  else {  /* resuming from previous yield */
+    L->status = LUA_OK;
+    ci->func = restorestack(L, ci->extra);
+    if (isLua(ci))  /* yielded inside a hook? */
+      luaV_execute(L);  /* just continue running Lua code */
+    else {  /* 'common' yield */
+      if (ci->u.c.k != NULL) {  /* does it have a continuation? */
+        int n;
+        ci->u.c.status = LUA_YIELD;  /* 'default' status */
+        ci->callstatus |= CIST_YIELDED;
+        lua_unlock(L);
+        n = (*ci->u.c.k)(L);  /* call continuation */
+        lua_lock(L);
+        api_checknelems(L, n);
+        firstArg = L->top - n;  /* yield results come from continuation */
+      }
+      luaD_poscall(L, firstArg);  /* finish 'luaD_precall' */
+    }
+    unroll(L, NULL);
+  }
+  lua_assert(nCcalls == L->nCcalls);
+}
+
+
+LUA_API int lua_resume (lua_State *L, lua_State *from, int nargs) {
+  int status;
+  lua_lock(L);
+  luai_userstateresume(L, nargs);
+  L->nCcalls = (from) ? from->nCcalls + 1 : 1;
+  L->nny = 0;  /* allow yields */
+  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);
+  status = luaD_rawrunprotected(L, resume, L->top - nargs);
+  if (status == -1)  /* error calling 'lua_resume'? */
+    status = LUA_ERRRUN;
+  else {  /* yield or regular error */
+    while (status != LUA_OK && status != LUA_YIELD) {  /* error? */
+      if (recover(L, status))  /* recover point? */
+        status = luaD_rawrunprotected(L, unroll, NULL);  /* run continuation */
+      else {  /* unrecoverable error */
+        L->status = cast_byte(status);  /* mark thread as `dead' */
+        seterrorobj(L, status, L->top);
+        L->ci->top = L->top;
+        break;
+      }
+    }
+    lua_assert(status == L->status);
+  }
+  L->nny = 1;  /* do not allow yields */
+  L->nCcalls--;
+  lua_assert(L->nCcalls == ((from) ? from->nCcalls : 0));
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_yieldk (lua_State *L, int nresults, int ctx, lua_CFunction k) {
+  CallInfo *ci = L->ci;
+  luai_userstateyield(L, nresults);
+  lua_lock(L);
+  api_checknelems(L, nresults);
+  if (L->nny > 0) {
+    if (L != G(L)->mainthread)
+      luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
+    else
+      luaG_runerror(L, "attempt to yield from outside a coroutine");
+  }
+  L->status = LUA_YIELD;
+  ci->extra = savestack(L, ci->func);  /* save current 'func' */
+  if (isLua(ci)) {  /* inside a hook? */
+    api_check(L, k == NULL, "hooks cannot continue after yielding");
+  }
+  else {
+    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */
+      ci->u.c.ctx = ctx;  /* save context */
+    ci->func = L->top - nresults - 1;  /* protect stack below results */
+    luaD_throw(L, LUA_YIELD);
+  }
+  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */
+  lua_unlock(L);
+  return 0;  /* return to 'luaD_hook' */
+}
+
+
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t old_top, ptrdiff_t ef) {
+  int status;
+  CallInfo *old_ci = L->ci;
+  lu_byte old_allowhooks = L->allowhook;
+  unsigned short old_nny = L->nny;
+  ptrdiff_t old_errfunc = L->errfunc;
+  L->errfunc = ef;
+  status = luaD_rawrunprotected(L, func, u);
+  if (status != LUA_OK) {  /* an error occurred? */
+    StkId oldtop = restorestack(L, old_top);
+    luaF_close(L, oldtop);  /* close possible pending closures */
+    seterrorobj(L, status, oldtop);
+    L->ci = old_ci;
+    L->allowhook = old_allowhooks;
+    L->nny = old_nny;
+    luaD_shrinkstack(L);
+  }
+  L->errfunc = old_errfunc;
+  return status;
+}
+
+
+
+/*
+** Execute a protected parser.
+*/
+struct SParser {  /* data to `f_parser' */
+  ZIO *z;
+  Mbuffer buff;  /* dynamic structure used by the scanner */
+  Dyndata dyd;  /* dynamic structures used by the parser */
+  const char *mode;
+  const char *name;
+};
+
+
+static void checkmode (lua_State *L, const char *mode, const char *x) {
+  if (mode && strchr(mode, x[0]) == NULL) {
+    luaO_pushfstring(L,
+       "attempt to load a %s chunk (mode is " LUA_QS ")", x, mode);
+    luaD_throw(L, LUA_ERRSYNTAX);
+  }
+}
+
+
+static void f_parser (lua_State *L, void *ud) {
+  int i;
+  Closure *cl;
+  struct SParser *p = cast(struct SParser *, ud);
+  int c = zgetc(p->z);  /* read first character */
+  if (c == LUA_SIGNATURE[0]) {
+    checkmode(L, p->mode, "binary");
+    cl = luaU_undump(L, p->z, &p->buff, p->name);
+  }
+  else {
+    checkmode(L, p->mode, "text");
+    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
+  }
+  lua_assert(cl->l.nupvalues == cl->l.p->sizeupvalues);
+  for (i = 0; i < cl->l.nupvalues; i++) {  /* initialize upvalues */
+    UpVal *up = luaF_newupval(L);
+    cl->l.upvals[i] = up;
+    luaC_objbarrier(L, cl, up);
+  }
+}
+
+
+int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
+                                        const char *mode) {
+  struct SParser p;
+  int status;
+  L->nny++;  /* cannot yield during parsing */
+  p.z = z; p.name = name; p.mode = mode;
+  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;
+  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;
+  p.dyd.label.arr = NULL; p.dyd.label.size = 0;
+  luaZ_initbuffer(L, &p.buff);
+  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);
+  luaZ_freebuffer(L, &p.buff);
+  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);
+  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);
+  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);
+  L->nny--;
+  return status;
+}
+
+
diff --git a/dep/lualib/ldo.h b/dep/lualib/ldo.h
new file mode 100644
index 0000000..27b837d
--- /dev/null
+++ b/dep/lualib/ldo.h
@@ -0,0 +1,46 @@
+/*
+** $Id: ldo.h,v 2.20 2011/11/29 15:55:08 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldo_h
+#define ldo_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+#define luaD_checkstack(L,n)	if (L->stack_last - L->top <= (n)) \
+				    luaD_growstack(L, n); else condmovestack(L);
+
+
+#define incr_top(L) {L->top++; luaD_checkstack(L,0);}
+
+#define savestack(L,p)		((char *)(p) - (char *)L->stack)
+#define restorestack(L,n)	((TValue *)((char *)L->stack + (n)))
+
+
+/* type of protected functions, to be ran by `runprotected' */
+typedef void (*Pfunc) (lua_State *L, void *ud);
+
+LUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
+                                                  const char *mode);
+LUAI_FUNC void luaD_hook (lua_State *L, int event, int line);
+LUAI_FUNC int luaD_precall (lua_State *L, StkId func, int nresults);
+LUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults,
+                                        int allowyield);
+LUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                                        ptrdiff_t oldtop, ptrdiff_t ef);
+LUAI_FUNC int luaD_poscall (lua_State *L, StkId firstResult);
+LUAI_FUNC void luaD_reallocstack (lua_State *L, int newsize);
+LUAI_FUNC void luaD_growstack (lua_State *L, int n);
+LUAI_FUNC void luaD_shrinkstack (lua_State *L);
+
+LUAI_FUNC l_noret luaD_throw (lua_State *L, int errcode);
+LUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);
+
+#endif
+
diff --git a/dep/lualib/ldump.c b/dep/lualib/ldump.c
new file mode 100644
index 0000000..d5e6a47
--- /dev/null
+++ b/dep/lualib/ldump.c
@@ -0,0 +1,173 @@
+/*
+** $Id: ldump.c,v 2.17 2012/01/23 23:02:10 roberto Exp $
+** save precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#include <stddef.h>
+
+#define ldump_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lundump.h"
+
+typedef struct {
+ lua_State* L;
+ lua_Writer writer;
+ void* data;
+ int strip;
+ int status;
+} DumpState;
+
+#define DumpMem(b,n,size,D)	DumpBlock(b,(n)*(size),D)
+#define DumpVar(x,D)		DumpMem(&x,1,sizeof(x),D)
+
+static void DumpBlock(const void* b, size_t size, DumpState* D)
+{
+ if (D->status==0)
+ {
+  lua_unlock(D->L);
+  D->status=(*D->writer)(D->L,b,size,D->data);
+  lua_lock(D->L);
+ }
+}
+
+static void DumpChar(int y, DumpState* D)
+{
+ char x=(char)y;
+ DumpVar(x,D);
+}
+
+static void DumpInt(int x, DumpState* D)
+{
+ DumpVar(x,D);
+}
+
+static void DumpNumber(lua_Number x, DumpState* D)
+{
+ DumpVar(x,D);
+}
+
+static void DumpVector(const void* b, int n, size_t size, DumpState* D)
+{
+ DumpInt(n,D);
+ DumpMem(b,n,size,D);
+}
+
+static void DumpString(const TString* s, DumpState* D)
+{
+ if (s==NULL)
+ {
+  size_t size=0;
+  DumpVar(size,D);
+ }
+ else
+ {
+  size_t size=s->tsv.len+1;		/* include trailing '\0' */
+  DumpVar(size,D);
+  DumpBlock(getstr(s),size*sizeof(char),D);
+ }
+}
+
+#define DumpCode(f,D)	 DumpVector(f->code,f->sizecode,sizeof(Instruction),D)
+
+static void DumpFunction(const Proto* f, DumpState* D);
+
+static void DumpConstants(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizek;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  const TValue* o=&f->k[i];
+  DumpChar(ttypenv(o),D);
+  switch (ttypenv(o))
+  {
+   case LUA_TNIL:
+	break;
+   case LUA_TBOOLEAN:
+	DumpChar(bvalue(o),D);
+	break;
+   case LUA_TNUMBER:
+	DumpNumber(nvalue(o),D);
+	break;
+   case LUA_TSTRING:
+	DumpString(rawtsvalue(o),D);
+	break;
+    default: lua_assert(0);
+  }
+ }
+ n=f->sizep;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpFunction(f->p[i],D);
+}
+
+static void DumpUpvalues(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpChar(f->upvalues[i].instack,D);
+  DumpChar(f->upvalues[i].idx,D);
+ }
+}
+
+static void DumpDebug(const Proto* f, DumpState* D)
+{
+ int i,n;
+ DumpString((D->strip) ? NULL : f->source,D);
+ n= (D->strip) ? 0 : f->sizelineinfo;
+ DumpVector(f->lineinfo,n,sizeof(int),D);
+ n= (D->strip) ? 0 : f->sizelocvars;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpString(f->locvars[i].varname,D);
+  DumpInt(f->locvars[i].startpc,D);
+  DumpInt(f->locvars[i].endpc,D);
+ }
+ n= (D->strip) ? 0 : f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpString(f->upvalues[i].name,D);
+}
+
+static void DumpFunction(const Proto* f, DumpState* D)
+{
+ DumpInt(f->linedefined,D);
+ DumpInt(f->lastlinedefined,D);
+ DumpChar(f->numparams,D);
+ DumpChar(f->is_vararg,D);
+ DumpChar(f->maxstacksize,D);
+ DumpCode(f,D);
+ DumpConstants(f,D);
+ DumpUpvalues(f,D);
+ DumpDebug(f,D);
+}
+
+static void DumpHeader(DumpState* D)
+{
+ lu_byte h[LUAC_HEADERSIZE];
+ luaU_header(h);
+ DumpBlock(h,LUAC_HEADERSIZE,D);
+}
+
+/*
+** dump Lua function as precompiled chunk
+*/
+int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
+{
+ DumpState D;
+ D.L=L;
+ D.writer=w;
+ D.data=data;
+ D.strip=strip;
+ D.status=0;
+ DumpHeader(&D);
+ DumpFunction(f,&D);
+ return D.status;
+}
diff --git a/dep/lualib/lfunc.c b/dep/lualib/lfunc.c
new file mode 100644
index 0000000..4fd27fe
--- /dev/null
+++ b/dep/lualib/lfunc.c
@@ -0,0 +1,161 @@
+/*
+** $Id: lfunc.c,v 2.29 2012/05/08 13:53:33 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define lfunc_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+Closure *luaF_newCclosure (lua_State *L, int n) {
+  Closure *c = &luaC_newobj(L, LUA_TCCL, sizeCclosure(n), NULL, 0)->cl;
+  c->c.nupvalues = cast_byte(n);
+  return c;
+}
+
+
+Closure *luaF_newLclosure (lua_State *L, int n) {
+  Closure *c = &luaC_newobj(L, LUA_TLCL, sizeLclosure(n), NULL, 0)->cl;
+  c->l.p = NULL;
+  c->l.nupvalues = cast_byte(n);
+  while (n--) c->l.upvals[n] = NULL;
+  return c;
+}
+
+
+UpVal *luaF_newupval (lua_State *L) {
+  UpVal *uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), NULL, 0)->uv;
+  uv->v = &uv->u.value;
+  setnilvalue(uv->v);
+  return uv;
+}
+
+
+UpVal *luaF_findupval (lua_State *L, StkId level) {
+  global_State *g = G(L);
+  GCObject **pp = &L->openupval;
+  UpVal *p;
+  UpVal *uv;
+  while (*pp != NULL && (p = gco2uv(*pp))->v >= level) {
+    GCObject *o = obj2gco(p);
+    lua_assert(p->v != &p->u.value);
+    if (p->v == level) {  /* found a corresponding upvalue? */
+      if (isdead(g, o))  /* is it dead? */
+        changewhite(o);  /* resurrect it */
+      return p;
+    }
+    resetoldbit(o);  /* may create a newer upval after this one */
+    pp = &p->next;
+  }
+  /* not found: create a new one */
+  uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), pp, 0)->uv;
+  uv->v = level;  /* current value lives in the stack */
+  uv->u.l.prev = &g->uvhead;  /* double link it in `uvhead' list */
+  uv->u.l.next = g->uvhead.u.l.next;
+  uv->u.l.next->u.l.prev = uv;
+  g->uvhead.u.l.next = uv;
+  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  return uv;
+}
+
+
+static void unlinkupval (UpVal *uv) {
+  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  uv->u.l.next->u.l.prev = uv->u.l.prev;  /* remove from `uvhead' list */
+  uv->u.l.prev->u.l.next = uv->u.l.next;
+}
+
+
+void luaF_freeupval (lua_State *L, UpVal *uv) {
+  if (uv->v != &uv->u.value)  /* is it open? */
+    unlinkupval(uv);  /* remove from open list */
+  luaM_free(L, uv);  /* free upvalue */
+}
+
+
+void luaF_close (lua_State *L, StkId level) {
+  UpVal *uv;
+  global_State *g = G(L);
+  while (L->openupval != NULL && (uv = gco2uv(L->openupval))->v >= level) {
+    GCObject *o = obj2gco(uv);
+    lua_assert(!isblack(o) && uv->v != &uv->u.value);
+    L->openupval = uv->next;  /* remove from `open' list */
+    if (isdead(g, o))
+      luaF_freeupval(L, uv);  /* free upvalue */
+    else {
+      unlinkupval(uv);  /* remove upvalue from 'uvhead' list */
+      setobj(L, &uv->u.value, uv->v);  /* move value to upvalue slot */
+      uv->v = &uv->u.value;  /* now current value lives here */
+      gch(o)->next = g->allgc;  /* link upvalue into 'allgc' list */
+      g->allgc = o;
+      luaC_checkupvalcolor(g, uv);
+    }
+  }
+}
+
+
+Proto *luaF_newproto (lua_State *L) {
+  Proto *f = &luaC_newobj(L, LUA_TPROTO, sizeof(Proto), NULL, 0)->p;
+  f->k = NULL;
+  f->sizek = 0;
+  f->p = NULL;
+  f->sizep = 0;
+  f->code = NULL;
+  f->cache = NULL;
+  f->sizecode = 0;
+  f->lineinfo = NULL;
+  f->sizelineinfo = 0;
+  f->upvalues = NULL;
+  f->sizeupvalues = 0;
+  f->numparams = 0;
+  f->is_vararg = 0;
+  f->maxstacksize = 0;
+  f->locvars = NULL;
+  f->sizelocvars = 0;
+  f->linedefined = 0;
+  f->lastlinedefined = 0;
+  f->source = NULL;
+  return f;
+}
+
+
+void luaF_freeproto (lua_State *L, Proto *f) {
+  luaM_freearray(L, f->code, f->sizecode);
+  luaM_freearray(L, f->p, f->sizep);
+  luaM_freearray(L, f->k, f->sizek);
+  luaM_freearray(L, f->lineinfo, f->sizelineinfo);
+  luaM_freearray(L, f->locvars, f->sizelocvars);
+  luaM_freearray(L, f->upvalues, f->sizeupvalues);
+  luaM_free(L, f);
+}
+
+
+/*
+** Look for n-th local variable at line `line' in function `func'.
+** Returns NULL if not found.
+*/
+const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
+  int i;
+  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
+    if (pc < f->locvars[i].endpc) {  /* is variable active? */
+      local_number--;
+      if (local_number == 0)
+        return getstr(f->locvars[i].varname);
+    }
+  }
+  return NULL;  /* not found */
+}
+
diff --git a/dep/lualib/lfunc.h b/dep/lualib/lfunc.h
new file mode 100644
index 0000000..e236a71
--- /dev/null
+++ b/dep/lualib/lfunc.h
@@ -0,0 +1,33 @@
+/*
+** $Id: lfunc.h,v 2.8 2012/05/08 13:53:33 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lfunc_h
+#define lfunc_h
+
+
+#include "lobject.h"
+
+
+#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
+                         cast(int, sizeof(TValue)*((n)-1)))
+
+#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
+                         cast(int, sizeof(TValue *)*((n)-1)))
+
+
+LUAI_FUNC Proto *luaF_newproto (lua_State *L);
+LUAI_FUNC Closure *luaF_newCclosure (lua_State *L, int nelems);
+LUAI_FUNC Closure *luaF_newLclosure (lua_State *L, int nelems);
+LUAI_FUNC UpVal *luaF_newupval (lua_State *L);
+LUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);
+LUAI_FUNC void luaF_close (lua_State *L, StkId level);
+LUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);
+LUAI_FUNC void luaF_freeupval (lua_State *L, UpVal *uv);
+LUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,
+                                         int pc);
+
+
+#endif
diff --git a/dep/lualib/lgc.c b/dep/lualib/lgc.c
new file mode 100644
index 0000000..06f972a
--- /dev/null
+++ b/dep/lualib/lgc.c
@@ -0,0 +1,1205 @@
+/*
+** $Id: lgc.c,v 2.133 2012/05/31 21:28:59 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lgc_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+
+/*
+** cost of sweeping one element (the size of a small object divided
+** by some adjust for the sweep speed)
+*/
+#define GCSWEEPCOST	((sizeof(TString) + 4) / 4)
+
+/* maximum number of elements to sweep in each single step */
+#define GCSWEEPMAX	(cast_int((GCSTEPSIZE / GCSWEEPCOST) / 4))
+
+/* maximum number of finalizers to call in each GC step */
+#define GCFINALIZENUM	4
+
+
+/*
+** macro to adjust 'stepmul': 'stepmul' is actually used like
+** 'stepmul / STEPMULADJ' (value chosen by tests)
+*/
+#define STEPMULADJ		200
+
+/*
+** macro to adjust 'pause': 'pause' is actually used like
+** 'pause / PAUSEADJ' (value chosen by tests)
+*/
+#define PAUSEADJ		200
+
+
+
+
+/*
+** standard negative debt for GC; a reasonable "time" to wait before
+** starting a new cycle
+*/
+#define stddebtest(g,e)	(-cast(l_mem, (e)/PAUSEADJ) * g->gcpause)
+#define stddebt(g)	stddebtest(g, gettotalbytes(g))
+
+
+/*
+** 'makewhite' erases all color bits plus the old bit and then
+** sets only the current white bit
+*/
+#define maskcolors	(~(bit2mask(BLACKBIT, OLDBIT) | WHITEBITS))
+#define makewhite(g,x)	\
+ (gch(x)->marked = cast_byte((gch(x)->marked & maskcolors) | luaC_white(g)))
+
+#define white2gray(x)	resetbits(gch(x)->marked, WHITEBITS)
+#define black2gray(x)	resetbit(gch(x)->marked, BLACKBIT)
+
+
+#define isfinalized(x)		testbit(gch(x)->marked, FINALIZEDBIT)
+
+#define checkdeadkey(n)	lua_assert(!ttisdeadkey(gkey(n)) || ttisnil(gval(n)))
+
+
+#define checkconsistency(obj)  \
+  lua_longassert(!iscollectable(obj) || righttt(obj))
+
+
+#define markvalue(g,o) { checkconsistency(o); \
+  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }
+
+#define markobject(g,t) { if ((t) && iswhite(obj2gco(t))) \
+		reallymarkobject(g, obj2gco(t)); }
+
+static void reallymarkobject (global_State *g, GCObject *o);
+
+
+/*
+** {======================================================
+** Generic functions
+** =======================================================
+*/
+
+
+/*
+** one after last element in a hash array
+*/
+#define gnodelast(h)	gnode(h, cast(size_t, sizenode(h)))
+
+
+/*
+** link table 'h' into list pointed by 'p'
+*/
+#define linktable(h,p)	((h)->gclist = *(p), *(p) = obj2gco(h))
+
+
+/*
+** if key is not marked, mark its entry as dead (therefore removing it
+** from the table)
+*/
+static void removeentry (Node *n) {
+  lua_assert(ttisnil(gval(n)));
+  if (valiswhite(gkey(n)))
+    setdeadvalue(gkey(n));  /* unused and unmarked key; remove it */
+}
+
+
+/*
+** tells whether a key or value can be cleared from a weak
+** table. Non-collectable objects are never removed from weak
+** tables. Strings behave as `values', so are never removed too. for
+** other objects: if really collected, cannot keep them; for objects
+** being finalized, keep them in keys, but not in values
+*/
+static int iscleared (global_State *g, const TValue *o) {
+  if (!iscollectable(o)) return 0;
+  else if (ttisstring(o)) {
+    markobject(g, rawtsvalue(o));  /* strings are `values', so are never weak */
+    return 0;
+  }
+  else return iswhite(gcvalue(o));
+}
+
+
+/*
+** barrier that moves collector forward, that is, mark the white object
+** being pointed by a black object.
+*/
+void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
+  global_State *g = G(L);
+  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
+  lua_assert(isgenerational(g) || g->gcstate != GCSpause);
+  lua_assert(gch(o)->tt != LUA_TTABLE);
+  if (keepinvariant(g))  /* must keep invariant? */
+    reallymarkobject(g, v);  /* restore invariant */
+  else {  /* sweep phase */
+    lua_assert(issweepphase(g));
+    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */
+  }
+}
+
+
+/*
+** barrier that moves collector backward, that is, mark the black object
+** pointing to a white object as gray again. (Current implementation
+** only works for tables; access to 'gclist' is not uniform across
+** different types.)
+*/
+void luaC_barrierback_ (lua_State *L, GCObject *o) {
+  global_State *g = G(L);
+  lua_assert(isblack(o) && !isdead(g, o) && gch(o)->tt == LUA_TTABLE);
+  black2gray(o);  /* make object gray (again) */
+  gco2t(o)->gclist = g->grayagain;
+  g->grayagain = o;
+}
+
+
+/*
+** barrier for prototypes. When creating first closure (cache is
+** NULL), use a forward barrier; this may be the only closure of the
+** prototype (if it is a "regular" function, with a single instance)
+** and the prototype may be big, so it is better to avoid traversing
+** it again. Otherwise, use a backward barrier, to avoid marking all
+** possible instances.
+*/
+LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c) {
+  global_State *g = G(L);
+  lua_assert(isblack(obj2gco(p)));
+  if (p->cache == NULL) {  /* first time? */
+    luaC_objbarrier(L, p, c);
+  }
+  else {  /* use a backward barrier */
+    black2gray(obj2gco(p));  /* make prototype gray (again) */
+    p->gclist = g->grayagain;
+    g->grayagain = obj2gco(p);
+  }
+}
+
+
+/*
+** check color (and invariants) for an upvalue that was closed,
+** i.e., moved into the 'allgc' list
+*/
+void luaC_checkupvalcolor (global_State *g, UpVal *uv) {
+  GCObject *o = obj2gco(uv);
+  lua_assert(!isblack(o));  /* open upvalues are never black */
+  if (isgray(o)) {
+    if (keepinvariant(g)) {
+      resetoldbit(o);  /* see MOVE OLD rule */
+      gray2black(o);  /* it is being visited now */
+      markvalue(g, uv->v);
+    }
+    else {
+      lua_assert(issweepphase(g));
+      makewhite(g, o);
+    }
+  }
+}
+
+
+/*
+** create a new collectable object (with given type and size) and link
+** it to '*list'. 'offset' tells how many bytes to allocate before the
+** object itself (used only by states).
+*/
+GCObject *luaC_newobj (lua_State *L, int tt, size_t sz, GCObject **list,
+                       int offset) {
+  global_State *g = G(L);
+  char *raw = cast(char *, luaM_newobject(L, novariant(tt), sz));
+  GCObject *o = obj2gco(raw + offset);
+  if (list == NULL)
+    list = &g->allgc;  /* standard list for collectable objects */
+  gch(o)->marked = luaC_white(g);
+  gch(o)->tt = tt;
+  gch(o)->next = *list;
+  *list = o;
+  return o;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Mark functions
+** =======================================================
+*/
+
+
+/*
+** mark an object. Userdata, strings, and closed upvalues are visited
+** and turned black here. Other objects are marked gray and added
+** to appropriate list to be visited (and turned black) later. (Open
+** upvalues are already linked in 'headuv' list.)
+*/
+static void reallymarkobject (global_State *g, GCObject *o) {
+  lu_mem size;
+  white2gray(o);
+  switch (gch(o)->tt) {
+    case LUA_TSHRSTR:
+    case LUA_TLNGSTR: {
+      size = sizestring(gco2ts(o));
+      break;  /* nothing else to mark; make it black */
+    }
+    case LUA_TUSERDATA: {
+      Table *mt = gco2u(o)->metatable;
+      markobject(g, mt);
+      markobject(g, gco2u(o)->env);
+      size = sizeudata(gco2u(o));
+      break;
+    }
+    case LUA_TUPVAL: {
+      UpVal *uv = gco2uv(o);
+      markvalue(g, uv->v);
+      if (uv->v != &uv->u.value)  /* open? */
+        return;  /* open upvalues remain gray */
+      size = sizeof(UpVal);
+      break;
+    }
+    case LUA_TLCL: {
+      gco2lcl(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TCCL: {
+      gco2ccl(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TTABLE: {
+      linktable(gco2t(o), &g->gray);
+      return;
+    }
+    case LUA_TTHREAD: {
+      gco2th(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TPROTO: {
+      gco2p(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    default: lua_assert(0); return;
+  }
+  gray2black(o);
+  g->GCmemtrav += size;
+}
+
+
+/*
+** mark metamethods for basic types
+*/
+static void markmt (global_State *g) {
+  int i;
+  for (i=0; i < LUA_NUMTAGS; i++)
+    markobject(g, g->mt[i]);
+}
+
+
+/*
+** mark all objects in list of being-finalized
+*/
+static void markbeingfnz (global_State *g) {
+  GCObject *o;
+  for (o = g->tobefnz; o != NULL; o = gch(o)->next) {
+    makewhite(g, o);
+    reallymarkobject(g, o);
+  }
+}
+
+
+/*
+** mark all values stored in marked open upvalues. (See comment in
+** 'lstate.h'.)
+*/
+static void remarkupvals (global_State *g) {
+  UpVal *uv;
+  for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {
+    if (isgray(obj2gco(uv)))
+      markvalue(g, uv->v);
+  }
+}
+
+
+/*
+** mark root set and reset all gray lists, to start a new
+** incremental (or full) collection
+*/
+static void markroot (global_State *g) {
+  g->gray = g->grayagain = NULL;
+  g->weak = g->allweak = g->ephemeron = NULL;
+  markobject(g, g->mainthread);
+  markvalue(g, &g->l_registry);
+  markmt(g);
+  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Traverse functions
+** =======================================================
+*/
+
+static void traverseweakvalue (global_State *g, Table *h) {
+  Node *n, *limit = gnodelast(h);
+  /* if there is array part, assume it may have white values (do not
+     traverse it just to check) */
+  int hasclears = (h->sizearray > 0);
+  for (n = gnode(h, 0); n < limit; n++) {
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else {
+      lua_assert(!ttisnil(gkey(n)));
+      markvalue(g, gkey(n));  /* mark key */
+      if (!hasclears && iscleared(g, gval(n)))  /* is there a white value? */
+        hasclears = 1;  /* table will have to be cleared */
+    }
+  }
+  if (hasclears)
+    linktable(h, &g->weak);  /* has to be cleared later */
+  else  /* no white values */
+    linktable(h, &g->grayagain);  /* no need to clean */
+}
+
+
+static int traverseephemeron (global_State *g, Table *h) {
+  int marked = 0;  /* true if an object is marked in this traversal */
+  int hasclears = 0;  /* true if table has white keys */
+  int prop = 0;  /* true if table has entry "white-key -> white-value" */
+  Node *n, *limit = gnodelast(h);
+  int i;
+  /* traverse array part (numeric keys are 'strong') */
+  for (i = 0; i < h->sizearray; i++) {
+    if (valiswhite(&h->array[i])) {
+      marked = 1;
+      reallymarkobject(g, gcvalue(&h->array[i]));
+    }
+  }
+  /* traverse hash part */
+  for (n = gnode(h, 0); n < limit; n++) {
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */
+      hasclears = 1;  /* table must be cleared */
+      if (valiswhite(gval(n)))  /* value not marked yet? */
+        prop = 1;  /* must propagate again */
+    }
+    else if (valiswhite(gval(n))) {  /* value not marked yet? */
+      marked = 1;
+      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */
+    }
+  }
+  if (prop)
+    linktable(h, &g->ephemeron);  /* have to propagate again */
+  else if (hasclears)  /* does table have white keys? */
+    linktable(h, &g->allweak);  /* may have to clean white keys */
+  else  /* no white keys */
+    linktable(h, &g->grayagain);  /* no need to clean */
+  return marked;
+}
+
+
+static void traversestrongtable (global_State *g, Table *h) {
+  Node *n, *limit = gnodelast(h);
+  int i;
+  for (i = 0; i < h->sizearray; i++)  /* traverse array part */
+    markvalue(g, &h->array[i]);
+  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else {
+      lua_assert(!ttisnil(gkey(n)));
+      markvalue(g, gkey(n));  /* mark key */
+      markvalue(g, gval(n));  /* mark value */
+    }
+  }
+}
+
+
+static lu_mem traversetable (global_State *g, Table *h) {
+  const char *weakkey, *weakvalue;
+  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);
+  markobject(g, h->metatable);
+  if (mode && ttisstring(mode) &&  /* is there a weak mode? */
+      ((weakkey = strchr(svalue(mode), 'k')),
+       (weakvalue = strchr(svalue(mode), 'v')),
+       (weakkey || weakvalue))) {  /* is really weak? */
+    black2gray(obj2gco(h));  /* keep table gray */
+    if (!weakkey)  /* strong keys? */
+      traverseweakvalue(g, h);
+    else if (!weakvalue)  /* strong values? */
+      traverseephemeron(g, h);
+    else  /* all weak */
+      linktable(h, &g->allweak);  /* nothing to traverse now */
+  }
+  else  /* not weak */
+    traversestrongtable(g, h);
+  return sizeof(Table) + sizeof(TValue) * h->sizearray +
+                         sizeof(Node) * sizenode(h);
+}
+
+
+static int traverseproto (global_State *g, Proto *f) {
+  int i;
+  if (f->cache && iswhite(obj2gco(f->cache)))
+    f->cache = NULL;  /* allow cache to be collected */
+  markobject(g, f->source);
+  for (i = 0; i < f->sizek; i++)  /* mark literals */
+    markvalue(g, &f->k[i]);
+  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */
+    markobject(g, f->upvalues[i].name);
+  for (i = 0; i < f->sizep; i++)  /* mark nested protos */
+    markobject(g, f->p[i]);
+  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */
+    markobject(g, f->locvars[i].varname);
+  return sizeof(Proto) + sizeof(Instruction) * f->sizecode +
+                         sizeof(Proto *) * f->sizep +
+                         sizeof(TValue) * f->sizek +
+                         sizeof(int) * f->sizelineinfo +
+                         sizeof(LocVar) * f->sizelocvars +
+                         sizeof(Upvaldesc) * f->sizeupvalues;
+}
+
+
+static lu_mem traverseCclosure (global_State *g, CClosure *cl) {
+  int i;
+  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
+    markvalue(g, &cl->upvalue[i]);
+  return sizeCclosure(cl->nupvalues);
+}
+
+static lu_mem traverseLclosure (global_State *g, LClosure *cl) {
+  int i;
+  markobject(g, cl->p);  /* mark its prototype */
+  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
+    markobject(g, cl->upvals[i]);
+  return sizeLclosure(cl->nupvalues);
+}
+
+
+static lu_mem traversestack (global_State *g, lua_State *th) {
+  StkId o = th->stack;
+  if (o == NULL)
+    return 1;  /* stack not completely built yet */
+  for (; o < th->top; o++)
+    markvalue(g, o);
+  if (g->gcstate == GCSatomic) {  /* final traversal? */
+    StkId lim = th->stack + th->stacksize;  /* real end of stack */
+    for (; o < lim; o++)  /* clear not-marked stack slice */
+      setnilvalue(o);
+  }
+  return sizeof(lua_State) + sizeof(TValue) * th->stacksize;
+}
+
+
+/*
+** traverse one gray object, turning it to black (except for threads,
+** which are always gray).
+*/
+static void propagatemark (global_State *g) {
+  lu_mem size;
+  GCObject *o = g->gray;
+  lua_assert(isgray(o));
+  gray2black(o);
+  switch (gch(o)->tt) {
+    case LUA_TTABLE: {
+      Table *h = gco2t(o);
+      g->gray = h->gclist;  /* remove from 'gray' list */
+      size = traversetable(g, h);
+      break;
+    }
+    case LUA_TLCL: {
+      LClosure *cl = gco2lcl(o);
+      g->gray = cl->gclist;  /* remove from 'gray' list */
+      size = traverseLclosure(g, cl);
+      break;
+    }
+    case LUA_TCCL: {
+      CClosure *cl = gco2ccl(o);
+      g->gray = cl->gclist;  /* remove from 'gray' list */
+      size = traverseCclosure(g, cl);
+      break;
+    }
+    case LUA_TTHREAD: {
+      lua_State *th = gco2th(o);
+      g->gray = th->gclist;  /* remove from 'gray' list */
+      th->gclist = g->grayagain;
+      g->grayagain = o;  /* insert into 'grayagain' list */
+      black2gray(o);
+      size = traversestack(g, th);
+      break;
+    }
+    case LUA_TPROTO: {
+      Proto *p = gco2p(o);
+      g->gray = p->gclist;  /* remove from 'gray' list */
+      size = traverseproto(g, p);
+      break;
+    }
+    default: lua_assert(0); return;
+  }
+  g->GCmemtrav += size;
+}
+
+
+static void propagateall (global_State *g) {
+  while (g->gray) propagatemark(g);
+}
+
+
+static void propagatelist (global_State *g, GCObject *l) {
+  lua_assert(g->gray == NULL);  /* no grays left */
+  g->gray = l;
+  propagateall(g);  /* traverse all elements from 'l' */
+}
+
+/*
+** retraverse all gray lists. Because tables may be reinserted in other
+** lists when traversed, traverse the original lists to avoid traversing
+** twice the same table (which is not wrong, but inefficient)
+*/
+static void retraversegrays (global_State *g) {
+  GCObject *weak = g->weak;  /* save original lists */
+  GCObject *grayagain = g->grayagain;
+  GCObject *ephemeron = g->ephemeron;
+  g->weak = g->grayagain = g->ephemeron = NULL;
+  propagateall(g);  /* traverse main gray list */
+  propagatelist(g, grayagain);
+  propagatelist(g, weak);
+  propagatelist(g, ephemeron);
+}
+
+
+static void convergeephemerons (global_State *g) {
+  int changed;
+  do {
+    GCObject *w;
+    GCObject *next = g->ephemeron;  /* get ephemeron list */
+    g->ephemeron = NULL;  /* tables will return to this list when traversed */
+    changed = 0;
+    while ((w = next) != NULL) {
+      next = gco2t(w)->gclist;
+      if (traverseephemeron(g, gco2t(w))) {  /* traverse marked some value? */
+        propagateall(g);  /* propagate changes */
+        changed = 1;  /* will have to revisit all ephemeron tables */
+      }
+    }
+  } while (changed);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Sweep Functions
+** =======================================================
+*/
+
+
+/*
+** clear entries with unmarked keys from all weaktables in list 'l' up
+** to element 'f'
+*/
+static void clearkeys (global_State *g, GCObject *l, GCObject *f) {
+  for (; l != f; l = gco2t(l)->gclist) {
+    Table *h = gco2t(l);
+    Node *n, *limit = gnodelast(h);
+    for (n = gnode(h, 0); n < limit; n++) {
+      if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {
+        setnilvalue(gval(n));  /* remove value ... */
+        removeentry(n);  /* and remove entry from table */
+      }
+    }
+  }
+}
+
+
+/*
+** clear entries with unmarked values from all weaktables in list 'l' up
+** to element 'f'
+*/
+static void clearvalues (global_State *g, GCObject *l, GCObject *f) {
+  for (; l != f; l = gco2t(l)->gclist) {
+    Table *h = gco2t(l);
+    Node *n, *limit = gnodelast(h);
+    int i;
+    for (i = 0; i < h->sizearray; i++) {
+      TValue *o = &h->array[i];
+      if (iscleared(g, o))  /* value was collected? */
+        setnilvalue(o);  /* remove value */
+    }
+    for (n = gnode(h, 0); n < limit; n++) {
+      if (!ttisnil(gval(n)) && iscleared(g, gval(n))) {
+        setnilvalue(gval(n));  /* remove value ... */
+        removeentry(n);  /* and remove entry from table */
+      }
+    }
+  }
+}
+
+
+static void freeobj (lua_State *L, GCObject *o) {
+  switch (gch(o)->tt) {
+    case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;
+    case LUA_TLCL: {
+      luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));
+      break;
+    }
+    case LUA_TCCL: {
+      luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));
+      break;
+    }
+    case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break;
+    case LUA_TTABLE: luaH_free(L, gco2t(o)); break;
+    case LUA_TTHREAD: luaE_freethread(L, gco2th(o)); break;
+    case LUA_TUSERDATA: luaM_freemem(L, o, sizeudata(gco2u(o))); break;
+    case LUA_TSHRSTR:
+      G(L)->strt.nuse--;
+      /* go through */
+    case LUA_TLNGSTR: {
+      luaM_freemem(L, o, sizestring(gco2ts(o)));
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+#define sweepwholelist(L,p)	sweeplist(L,p,MAX_LUMEM)
+static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count);
+
+
+/*
+** sweep the (open) upvalues of a thread and resize its stack and
+** list of call-info structures.
+*/
+static void sweepthread (lua_State *L, lua_State *L1) {
+  if (L1->stack == NULL) return;  /* stack not completely built yet */
+  sweepwholelist(L, &L1->openupval);  /* sweep open upvalues */
+  luaE_freeCI(L1);  /* free extra CallInfo slots */
+  /* should not change the stack during an emergency gc cycle */
+  if (G(L)->gckind != KGC_EMERGENCY)
+    luaD_shrinkstack(L1);
+}
+
+
+/*
+** sweep at most 'count' elements from a list of GCObjects erasing dead
+** objects, where a dead (not alive) object is one marked with the "old"
+** (non current) white and not fixed.
+** In non-generational mode, change all non-dead objects back to white,
+** preparing for next collection cycle.
+** In generational mode, keep black objects black, and also mark them as
+** old; stop when hitting an old object, as all objects after that
+** one will be old too.
+** When object is a thread, sweep its list of open upvalues too.
+*/
+static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
+  global_State *g = G(L);
+  int ow = otherwhite(g);
+  int toclear, toset;  /* bits to clear and to set in all live objects */
+  int tostop;  /* stop sweep when this is true */
+  if (isgenerational(g)) {  /* generational mode? */
+    toclear = ~0;  /* clear nothing */
+    toset = bitmask(OLDBIT);  /* set the old bit of all surviving objects */
+    tostop = bitmask(OLDBIT);  /* do not sweep old generation */
+  }
+  else {  /* normal mode */
+    toclear = maskcolors;  /* clear all color bits + old bit */
+    toset = luaC_white(g);  /* make object white */
+    tostop = 0;  /* do not stop */
+  }
+  while (*p != NULL && count-- > 0) {
+    GCObject *curr = *p;
+    int marked = gch(curr)->marked;
+    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */
+      *p = gch(curr)->next;  /* remove 'curr' from list */
+      freeobj(L, curr);  /* erase 'curr' */
+    }
+    else {
+      if (testbits(marked, tostop))
+        return NULL;  /* stop sweeping this list */
+      if (gch(curr)->tt == LUA_TTHREAD)
+        sweepthread(L, gco2th(curr));  /* sweep thread's upvalues */
+      /* update marks */
+      gch(curr)->marked = cast_byte((marked & toclear) | toset);
+      p = &gch(curr)->next;  /* go to next element */
+    }
+  }
+  return (*p == NULL) ? NULL : p;
+}
+
+
+/*
+** sweep a list until a live object (or end of list)
+*/
+static GCObject **sweeptolive (lua_State *L, GCObject **p, int *n) {
+  GCObject ** old = p;
+  int i = 0;
+  do {
+    i++;
+    p = sweeplist(L, p, 1);
+  } while (p == old);
+  if (n) *n += i;
+  return p;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Finalization
+** =======================================================
+*/
+
+static void checkSizes (lua_State *L) {
+  global_State *g = G(L);
+  if (g->gckind != KGC_EMERGENCY) {  /* do not change sizes in emergency */
+    int hs = g->strt.size / 2;  /* half the size of the string table */
+    if (g->strt.nuse < cast(lu_int32, hs))  /* using less than that half? */
+      luaS_resize(L, hs);  /* halve its size */
+    luaZ_freebuffer(L, &g->buff);  /* free concatenation buffer */
+  }
+}
+
+
+static GCObject *udata2finalize (global_State *g) {
+  GCObject *o = g->tobefnz;  /* get first element */
+  lua_assert(isfinalized(o));
+  g->tobefnz = gch(o)->next;  /* remove it from 'tobefnz' list */
+  gch(o)->next = g->allgc;  /* return it to 'allgc' list */
+  g->allgc = o;
+  resetbit(gch(o)->marked, SEPARATED);  /* mark that it is not in 'tobefnz' */
+  lua_assert(!isold(o));  /* see MOVE OLD rule */
+  if (!keepinvariant(g))  /* not keeping invariant? */
+    makewhite(g, o);  /* "sweep" object */
+  return o;
+}
+
+
+static void dothecall (lua_State *L, void *ud) {
+  UNUSED(ud);
+  luaD_call(L, L->top - 2, 0, 0);
+}
+
+
+static void GCTM (lua_State *L, int propagateerrors) {
+  global_State *g = G(L);
+  const TValue *tm;
+  TValue v;
+  setgcovalue(L, &v, udata2finalize(g));
+  tm = luaT_gettmbyobj(L, &v, TM_GC);
+  if (tm != NULL && ttisfunction(tm)) {  /* is there a finalizer? */
+    int status;
+    lu_byte oldah = L->allowhook;
+    int running  = g->gcrunning;
+    L->allowhook = 0;  /* stop debug hooks during GC metamethod */
+    g->gcrunning = 0;  /* avoid GC steps */
+    setobj2s(L, L->top, tm);  /* push finalizer... */
+    setobj2s(L, L->top + 1, &v);  /* ... and its argument */
+    L->top += 2;  /* and (next line) call the finalizer */
+    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);
+    L->allowhook = oldah;  /* restore hooks */
+    g->gcrunning = running;  /* restore state */
+    if (status != LUA_OK && propagateerrors) {  /* error while running __gc? */
+      if (status == LUA_ERRRUN) {  /* is there an error object? */
+        const char *msg = (ttisstring(L->top - 1))
+                            ? svalue(L->top - 1)
+                            : "no message";
+        luaO_pushfstring(L, "error in __gc metamethod (%s)", msg);
+        status = LUA_ERRGCMM;  /* error in __gc metamethod */
+      }
+      luaD_throw(L, status);  /* re-throw error */
+    }
+  }
+}
+
+
+/*
+** move all unreachable objects (or 'all' objects) that need
+** finalization from list 'finobj' to list 'tobefnz' (to be finalized)
+*/
+static void separatetobefnz (lua_State *L, int all) {
+  global_State *g = G(L);
+  GCObject **p = &g->finobj;
+  GCObject *curr;
+  GCObject **lastnext = &g->tobefnz;
+  /* find last 'next' field in 'tobefnz' list (to add elements in its end) */
+  while (*lastnext != NULL)
+    lastnext = &gch(*lastnext)->next;
+  while ((curr = *p) != NULL) {  /* traverse all finalizable objects */
+    lua_assert(!isfinalized(curr));
+    lua_assert(testbit(gch(curr)->marked, SEPARATED));
+    if (!(all || iswhite(curr)))  /* not being collected? */
+      p = &gch(curr)->next;  /* don't bother with it */
+    else {
+      l_setbit(gch(curr)->marked, FINALIZEDBIT); /* won't be finalized again */
+      *p = gch(curr)->next;  /* remove 'curr' from 'finobj' list */
+      gch(curr)->next = *lastnext;  /* link at the end of 'tobefnz' list */
+      *lastnext = curr;
+      lastnext = &gch(curr)->next;
+    }
+  }
+}
+
+
+/*
+** if object 'o' has a finalizer, remove it from 'allgc' list (must
+** search the list to find it) and link it in 'finobj' list.
+*/
+void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {
+  global_State *g = G(L);
+  if (testbit(gch(o)->marked, SEPARATED) || /* obj. is already separated... */
+      isfinalized(o) ||                           /* ... or is finalized... */
+      gfasttm(g, mt, TM_GC) == NULL)                /* or has no finalizer? */
+    return;  /* nothing to be done */
+  else {  /* move 'o' to 'finobj' list */
+    GCObject **p;
+    GCheader *ho = gch(o);
+    if (g->sweepgc == &ho->next) {  /* avoid removing current sweep object */
+      lua_assert(issweepphase(g));
+      g->sweepgc = sweeptolive(L, g->sweepgc, NULL);
+    }
+    /* search for pointer pointing to 'o' */
+    for (p = &g->allgc; *p != o; p = &gch(*p)->next) { /* empty */ }
+    *p = ho->next;  /* remove 'o' from root list */
+    ho->next = g->finobj;  /* link it in list 'finobj' */
+    g->finobj = o;
+    l_setbit(ho->marked, SEPARATED);  /* mark it as such */
+    if (!keepinvariant(g))  /* not keeping invariant? */
+      makewhite(g, o);  /* "sweep" object */
+    else
+      resetoldbit(o);  /* see MOVE OLD rule */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** GC control
+** =======================================================
+*/
+
+
+#define sweepphases  \
+	(bitmask(GCSsweepstring) | bitmask(GCSsweepudata) | bitmask(GCSsweep))
+
+
+/*
+** enter first sweep phase (strings) and prepare pointers for other
+** sweep phases.  The calls to 'sweeptolive' make pointers point to an
+** object inside the list (instead of to the header), so that the real
+** sweep do not need to skip objects created between "now" and the start
+** of the real sweep.
+** Returns how many objects it sweeped.
+*/
+static int entersweep (lua_State *L) {
+  global_State *g = G(L);
+  int n = 0;
+  g->gcstate = GCSsweepstring;
+  lua_assert(g->sweepgc == NULL && g->sweepfin == NULL);
+  /* prepare to sweep strings, finalizable objects, and regular objects */
+  g->sweepstrgc = 0;
+  g->sweepfin = sweeptolive(L, &g->finobj, &n);
+  g->sweepgc = sweeptolive(L, &g->allgc, &n);
+  return n;
+}
+
+
+/*
+** change GC mode
+*/
+void luaC_changemode (lua_State *L, int mode) {
+  global_State *g = G(L);
+  if (mode == g->gckind) return;  /* nothing to change */
+  if (mode == KGC_GEN) {  /* change to generational mode */
+    /* make sure gray lists are consistent */
+    luaC_runtilstate(L, bitmask(GCSpropagate));
+    g->GCestimate = gettotalbytes(g);
+    g->gckind = KGC_GEN;
+  }
+  else {  /* change to incremental mode */
+    /* sweep all objects to turn them back to white
+       (as white has not changed, nothing extra will be collected) */
+    g->gckind = KGC_NORMAL;
+    entersweep(L);
+    luaC_runtilstate(L, ~sweepphases);
+  }
+}
+
+
+/*
+** call all pending finalizers
+*/
+static void callallpendingfinalizers (lua_State *L, int propagateerrors) {
+  global_State *g = G(L);
+  while (g->tobefnz) {
+    resetoldbit(g->tobefnz);
+    GCTM(L, propagateerrors);
+  }
+}
+
+
+void luaC_freeallobjects (lua_State *L) {
+  global_State *g = G(L);
+  int i;
+  separatetobefnz(L, 1);  /* separate all objects with finalizers */
+  lua_assert(g->finobj == NULL);
+  callallpendingfinalizers(L, 0);
+  g->currentwhite = WHITEBITS; /* this "white" makes all objects look dead */
+  g->gckind = KGC_NORMAL;
+  sweepwholelist(L, &g->finobj);  /* finalizers can create objs. in 'finobj' */
+  sweepwholelist(L, &g->allgc);
+  for (i = 0; i < g->strt.size; i++)  /* free all string lists */
+    sweepwholelist(L, &g->strt.hash[i]);
+  lua_assert(g->strt.nuse == 0);
+}
+
+
+static l_mem atomic (lua_State *L) {
+  global_State *g = G(L);
+  l_mem work = -g->GCmemtrav;  /* start counting work */
+  GCObject *origweak, *origall;
+  lua_assert(!iswhite(obj2gco(g->mainthread)));
+  markobject(g, L);  /* mark running thread */
+  /* registry and global metatables may be changed by API */
+  markvalue(g, &g->l_registry);
+  markmt(g);  /* mark basic metatables */
+  /* remark occasional upvalues of (maybe) dead threads */
+  remarkupvals(g);
+  propagateall(g);  /* propagate changes */
+  work += g->GCmemtrav;  /* stop counting (do not (re)count grays) */
+  /* traverse objects caught by write barrier and by 'remarkupvals' */
+  retraversegrays(g);
+  work -= g->GCmemtrav;  /* restart counting */
+  convergeephemerons(g);
+  /* at this point, all strongly accessible objects are marked. */
+  /* clear values from weak tables, before checking finalizers */
+  clearvalues(g, g->weak, NULL);
+  clearvalues(g, g->allweak, NULL);
+  origweak = g->weak; origall = g->allweak;
+  work += g->GCmemtrav;  /* stop counting (objects being finalized) */
+  separatetobefnz(L, 0);  /* separate objects to be finalized */
+  markbeingfnz(g);  /* mark objects that will be finalized */
+  propagateall(g);  /* remark, to propagate `preserveness' */
+  work -= g->GCmemtrav;  /* restart counting */
+  convergeephemerons(g);
+  /* at this point, all resurrected objects are marked. */
+  /* remove dead objects from weak tables */
+  clearkeys(g, g->ephemeron, NULL);  /* clear keys from all ephemeron tables */
+  clearkeys(g, g->allweak, NULL);  /* clear keys from all allweak tables */
+  /* clear values from resurrected weak tables */
+  clearvalues(g, g->weak, origweak);
+  clearvalues(g, g->allweak, origall);
+  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */
+  work += g->GCmemtrav;  /* complete counting */
+  return work;  /* estimate of memory marked by 'atomic' */
+}
+
+
+static lu_mem singlestep (lua_State *L) {
+  global_State *g = G(L);
+  switch (g->gcstate) {
+    case GCSpause: {
+      g->GCmemtrav = 0;  /* start to count memory traversed */
+      if (!isgenerational(g))
+        markroot(g);  /* start a new collection */
+      /* in any case, root must be marked at this point */
+      lua_assert(!iswhite(obj2gco(g->mainthread))
+              && !iswhite(gcvalue(&g->l_registry)));
+      g->gcstate = GCSpropagate;
+      return g->GCmemtrav;
+    }
+    case GCSpropagate: {
+      if (g->gray) {
+        lu_mem oldtrav = g->GCmemtrav;
+        propagatemark(g);
+        return g->GCmemtrav - oldtrav;  /* memory traversed in this step */
+      }
+      else {  /* no more `gray' objects */
+        lu_mem work;
+        int sw;
+        g->gcstate = GCSatomic;  /* finish mark phase */
+        g->GCestimate = g->GCmemtrav;  /* save what was counted */;
+        work = atomic(L);  /* add what was traversed by 'atomic' */
+        g->GCestimate += work;  /* estimate of total memory traversed */ 
+        sw = entersweep(L);
+        return work + sw * GCSWEEPCOST;
+      }
+    }
+    case GCSsweepstring: {
+      int i;
+      for (i = 0; i < GCSWEEPMAX && g->sweepstrgc + i < g->strt.size; i++)
+        sweepwholelist(L, &g->strt.hash[g->sweepstrgc + i]);
+      g->sweepstrgc += i;
+      if (g->sweepstrgc >= g->strt.size)  /* no more strings to sweep? */
+        g->gcstate = GCSsweepudata;
+      return i * GCSWEEPCOST;
+    }
+    case GCSsweepudata: {
+      if (g->sweepfin) {
+        g->sweepfin = sweeplist(L, g->sweepfin, GCSWEEPMAX);
+        return GCSWEEPMAX*GCSWEEPCOST;
+      }
+      else {
+        g->gcstate = GCSsweep;
+        return 0;
+      }
+    }
+    case GCSsweep: {
+      if (g->sweepgc) {
+        g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
+        return GCSWEEPMAX*GCSWEEPCOST;
+      }
+      else {
+        /* sweep main thread */
+        GCObject *mt = obj2gco(g->mainthread);
+        sweeplist(L, &mt, 1);
+        checkSizes(L);
+        g->gcstate = GCSpause;  /* finish collection */
+        return GCSWEEPCOST;
+      }
+    }
+    default: lua_assert(0); return 0;
+  }
+}
+
+
+/*
+** advances the garbage collector until it reaches a state allowed
+** by 'statemask'
+*/
+void luaC_runtilstate (lua_State *L, int statesmask) {
+  global_State *g = G(L);
+  while (!testbit(statesmask, g->gcstate))
+    singlestep(L);
+}
+
+
+static void generationalcollection (lua_State *L) {
+  global_State *g = G(L);
+  if (g->GCestimate == 0) {  /* signal for another major collection? */
+    luaC_fullgc(L, 0);  /* perform a full regular collection */
+    g->GCestimate = gettotalbytes(g);  /* update control */
+  }
+  else {
+    lu_mem estimate = g->GCestimate;
+    luaC_runtilstate(L, ~bitmask(GCSpause));  /* run complete cycle */
+    luaC_runtilstate(L, bitmask(GCSpause));
+    if (gettotalbytes(g) > (estimate / 100) * g->gcmajorinc)
+      g->GCestimate = 0;  /* signal for a major collection */
+  }
+  luaE_setdebt(g, stddebt(g));
+}
+
+
+static void incstep (lua_State *L) {
+  global_State *g = G(L);
+  l_mem debt = g->GCdebt;
+  int stepmul = g->gcstepmul;
+  if (stepmul < 40) stepmul = 40;  /* avoid ridiculous low values */
+  /* convert debt from Kb to 'work units' (avoid zero debt and overflows) */
+  debt = (debt / STEPMULADJ) + 1;
+  debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;
+  do {  /* always perform at least one single step */
+    lu_mem work = singlestep(L);  /* do some work */
+    debt -= work;
+  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);
+  if (g->gcstate == GCSpause)
+    debt = stddebtest(g, g->GCestimate);  /* pause until next cycle */
+  else
+    debt = (debt / stepmul) * STEPMULADJ;  /* convert 'work units' to Kb */
+  luaE_setdebt(g, debt);
+}
+
+
+/*
+** performs a basic GC step
+*/
+void luaC_forcestep (lua_State *L) {
+  global_State *g = G(L);
+  int i;
+  if (isgenerational(g)) generationalcollection(L);
+  else incstep(L);
+  /* run a few finalizers (or all of them at the end of a collect cycle) */
+  for (i = 0; g->tobefnz && (i < GCFINALIZENUM || g->gcstate == GCSpause); i++)
+    GCTM(L, 1);  /* call one finalizer */
+}
+
+
+/*
+** performs a basic GC step only if collector is running
+*/
+void luaC_step (lua_State *L) {
+  global_State *g = G(L);
+  if (g->gcrunning) luaC_forcestep(L);
+  else luaE_setdebt(g, -GCSTEPSIZE);  /* avoid being called too often */
+}
+
+
+
+/*
+** performs a full GC cycle; if "isemergency", does not call
+** finalizers (which could change stack positions)
+*/
+void luaC_fullgc (lua_State *L, int isemergency) {
+  global_State *g = G(L);
+  int origkind = g->gckind;
+  int someblack = keepinvariant(g);
+  lua_assert(origkind != KGC_EMERGENCY);
+  if (isemergency)  /* do not run finalizers during emergency GC */
+    g->gckind = KGC_EMERGENCY;
+  else {
+    g->gckind = KGC_NORMAL;
+    callallpendingfinalizers(L, 1);
+  }
+  if (someblack) {  /* may there be some black objects? */
+    /* must sweep all objects to turn them back to white
+       (as white has not changed, nothing will be collected) */
+    entersweep(L);
+  }
+  /* finish any pending sweep phase to start a new cycle */
+  luaC_runtilstate(L, bitmask(GCSpause));
+  /* run entire collector */
+  luaC_runtilstate(L, ~bitmask(GCSpause));
+  luaC_runtilstate(L, bitmask(GCSpause));
+  if (origkind == KGC_GEN) {  /* generational mode? */
+    /* generational mode must always start in propagate phase */
+    luaC_runtilstate(L, bitmask(GCSpropagate));
+  }
+  g->gckind = origkind;
+  luaE_setdebt(g, stddebt(g));
+  if (!isemergency)   /* do not run finalizers during emergency GC */
+    callallpendingfinalizers(L, 1);
+}
+
+/* }====================================================== */
+
+
diff --git a/dep/lualib/lgc.h b/dep/lualib/lgc.h
new file mode 100644
index 0000000..bdd5cce
--- /dev/null
+++ b/dep/lualib/lgc.h
@@ -0,0 +1,147 @@
+/*
+** $Id: lgc.h,v 2.56 2012/05/23 15:43:14 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lgc_h
+#define lgc_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+
+/*
+** Collectable objects may have one of three colors: white, which
+** means the object is not marked; gray, which means the
+** object is marked, but its references may be not marked; and
+** black, which means that the object and all its references are marked.
+** The main invariant of the garbage collector, while marking objects,
+** is that a black object can never point to a white one. Moreover,
+** any gray object must be in a "gray list" (gray, grayagain, weak,
+** allweak, ephemeron) so that it can be visited again before finishing
+** the collection cycle. These lists have no meaning when the invariant
+** is not being enforced (e.g., sweep phase).
+*/
+
+
+
+/* how much to allocate before next GC step */
+#if !defined(GCSTEPSIZE)
+/* ~100 small strings */
+#define GCSTEPSIZE	(cast_int(100 * sizeof(TString)))
+#endif
+
+
+/*
+** Possible states of the Garbage Collector
+*/
+#define GCSpropagate	0
+#define GCSatomic	1
+#define GCSsweepstring	2
+#define GCSsweepudata	3
+#define GCSsweep	4
+#define GCSpause	5
+
+
+#define issweepphase(g)  \
+	(GCSsweepstring <= (g)->gcstate && (g)->gcstate <= GCSsweep)
+
+#define isgenerational(g)	((g)->gckind == KGC_GEN)
+
+/*
+** macro to tell when main invariant (white objects cannot point to black
+** ones) must be kept. During a non-generational collection, the sweep
+** phase may break the invariant, as objects turned white may point to
+** still-black objects. The invariant is restored when sweep ends and
+** all objects are white again. During a generational collection, the
+** invariant must be kept all times.
+*/
+#define keepinvariant(g)  (isgenerational(g) || g->gcstate <= GCSatomic)
+
+
+/*
+** some useful bit tricks
+*/
+#define resetbits(x,m)		((x) &= cast(lu_byte, ~(m)))
+#define setbits(x,m)		((x) |= (m))
+#define testbits(x,m)		((x) & (m))
+#define bitmask(b)		(1<<(b))
+#define bit2mask(b1,b2)		(bitmask(b1) | bitmask(b2))
+#define l_setbit(x,b)		setbits(x, bitmask(b))
+#define resetbit(x,b)		resetbits(x, bitmask(b))
+#define testbit(x,b)		testbits(x, bitmask(b))
+
+
+/* Layout for bit use in `marked' field: */
+#define WHITE0BIT	0  /* object is white (type 0) */
+#define WHITE1BIT	1  /* object is white (type 1) */
+#define BLACKBIT	2  /* object is black */
+#define FINALIZEDBIT	3  /* object has been separated for finalization */
+#define SEPARATED	4  /* object is in 'finobj' list or in 'tobefnz' */
+#define FIXEDBIT	5  /* object is fixed (should not be collected) */
+#define OLDBIT		6  /* object is old (only in generational mode) */
+/* bit 7 is currently used by tests (luaL_checkmemory) */
+
+#define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)
+
+
+#define iswhite(x)      testbits((x)->gch.marked, WHITEBITS)
+#define isblack(x)      testbit((x)->gch.marked, BLACKBIT)
+#define isgray(x)  /* neither white nor black */  \
+	(!testbits((x)->gch.marked, WHITEBITS | bitmask(BLACKBIT)))
+
+#define isold(x)	testbit((x)->gch.marked, OLDBIT)
+
+/* MOVE OLD rule: whenever an object is moved to the beginning of
+   a GC list, its old bit must be cleared */
+#define resetoldbit(o)	resetbit((o)->gch.marked, OLDBIT)
+
+#define otherwhite(g)	(g->currentwhite ^ WHITEBITS)
+#define isdeadm(ow,m)	(!(((m) ^ WHITEBITS) & (ow)))
+#define isdead(g,v)	isdeadm(otherwhite(g), (v)->gch.marked)
+
+#define changewhite(x)	((x)->gch.marked ^= WHITEBITS)
+#define gray2black(x)	l_setbit((x)->gch.marked, BLACKBIT)
+
+#define valiswhite(x)	(iscollectable(x) && iswhite(gcvalue(x)))
+
+#define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)
+
+
+#define luaC_condGC(L,c) \
+	{if (G(L)->GCdebt > 0) {c;}; condchangemem(L);}
+#define luaC_checkGC(L)		luaC_condGC(L, luaC_step(L);)
+
+
+#define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+	luaC_barrier_(L,obj2gco(p),gcvalue(v)); }
+
+#define luaC_barrierback(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+	luaC_barrierback_(L,p); }
+
+#define luaC_objbarrier(L,p,o)  \
+	{ if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \
+		luaC_barrier_(L,obj2gco(p),obj2gco(o)); }
+
+#define luaC_objbarrierback(L,p,o)  \
+   { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierback_(L,p); }
+
+#define luaC_barrierproto(L,p,c) \
+   { if (isblack(obj2gco(p))) luaC_barrierproto_(L,p,c); }
+
+LUAI_FUNC void luaC_freeallobjects (lua_State *L);
+LUAI_FUNC void luaC_step (lua_State *L);
+LUAI_FUNC void luaC_forcestep (lua_State *L);
+LUAI_FUNC void luaC_runtilstate (lua_State *L, int statesmask);
+LUAI_FUNC void luaC_fullgc (lua_State *L, int isemergency);
+LUAI_FUNC GCObject *luaC_newobj (lua_State *L, int tt, size_t sz,
+                                 GCObject **list, int offset);
+LUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);
+LUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o);
+LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c);
+LUAI_FUNC void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt);
+LUAI_FUNC void luaC_checkupvalcolor (global_State *g, UpVal *uv);
+LUAI_FUNC void luaC_changemode (lua_State *L, int mode);
+
+#endif
diff --git a/dep/lualib/linit.c b/dep/lualib/linit.c
new file mode 100644
index 0000000..8d3aa65
--- /dev/null
+++ b/dep/lualib/linit.c
@@ -0,0 +1,67 @@
+/*
+** $Id: linit.c,v 1.32 2011/04/08 19:17:36 roberto Exp $
+** Initialization of libraries for lua.c and other clients
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** If you embed Lua in your program and need to open the standard
+** libraries, call luaL_openlibs in your program. If you need a
+** different set of libraries, copy this file to your project and edit
+** it to suit your needs.
+*/
+
+
+#define linit_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lualib.h"
+#include "lauxlib.h"
+
+
+/*
+** these libs are loaded by lua.c and are readily available to any Lua
+** program
+*/
+static const luaL_Reg loadedlibs[] = {
+  {"_G", luaopen_base},
+  {LUA_LOADLIBNAME, luaopen_package},
+  {LUA_COLIBNAME, luaopen_coroutine},
+  {LUA_TABLIBNAME, luaopen_table},
+  {LUA_IOLIBNAME, luaopen_io},
+  {LUA_OSLIBNAME, luaopen_os},
+  {LUA_STRLIBNAME, luaopen_string},
+  {LUA_BITLIBNAME, luaopen_bit32},
+  {LUA_MATHLIBNAME, luaopen_math},
+  {LUA_DBLIBNAME, luaopen_debug},
+  {NULL, NULL}
+};
+
+
+/*
+** these libs are preloaded and must be required before used
+*/
+static const luaL_Reg preloadedlibs[] = {
+  {NULL, NULL}
+};
+
+
+LUALIB_API void luaL_openlibs (lua_State *L) {
+  const luaL_Reg *lib;
+  /* call open functions from 'loadedlibs' and set results to global table */
+  for (lib = loadedlibs; lib->func; lib++) {
+    luaL_requiref(L, lib->name, lib->func, 1);
+    lua_pop(L, 1);  /* remove lib */
+  }
+  /* add open functions from 'preloadedlibs' into 'package.preload' table */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  for (lib = preloadedlibs; lib->func; lib++) {
+    lua_pushcfunction(L, lib->func);
+    lua_setfield(L, -2, lib->name);
+  }
+  lua_pop(L, 1);  /* remove _PRELOAD table */
+}
+
diff --git a/dep/lualib/liolib.c b/dep/lualib/liolib.c
new file mode 100644
index 0000000..4814aa2
--- /dev/null
+++ b/dep/lualib/liolib.c
@@ -0,0 +1,657 @@
+/*
+** $Id: liolib.c,v 2.108 2011/11/25 12:50:03 roberto Exp $
+** Standard I/O (and system) library
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** POSIX idiosyncrasy!
+** This definition must come before the inclusion of 'stdio.h'; it
+** should not affect non-POSIX systems
+*/
+#if !defined(_FILE_OFFSET_BITS)
+#define _FILE_OFFSET_BITS 64
+#endif
+
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define liolib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+
+/*
+** {======================================================
+** lua_popen spawns a new process connected to the current
+** one through the file streams.
+** =======================================================
+*/
+
+#if !defined(lua_popen)	/* { */
+
+#if defined(LUA_USE_POPEN)	/* { */
+
+#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
+#define lua_pclose(L,file)	((void)L, pclose(file))
+
+#elif defined(LUA_WIN)		/* }{ */
+
+#define lua_popen(L,c,m)		((void)L, _popen(c,m))
+#define lua_pclose(L,file)		((void)L, _pclose(file))
+
+
+#else				/* }{ */
+
+#define lua_popen(L,c,m)		((void)((void)c, m),  \
+		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
+#define lua_pclose(L,file)		((void)((void)L, file), -1)
+
+
+#endif				/* } */
+
+#endif			/* } */
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** lua_fseek/lua_ftell: configuration for longer offsets
+** =======================================================
+*/
+
+#if !defined(lua_fseek)	/* { */
+
+#if defined(LUA_USE_POSIX)
+
+#define l_fseek(f,o,w)		fseeko(f,o,w)
+#define l_ftell(f)		ftello(f)
+#define l_seeknum		off_t
+
+#elif defined(LUA_WIN) && !defined(_CRTIMP_TYPEINFO) \
+   && defined(_MSC_VER) && (_MSC_VER >= 1400)
+/* Windows (but not DDK) and Visual C++ 2005 or higher */
+
+#define l_fseek(f,o,w)		_fseeki64(f,o,w)
+#define l_ftell(f)		_ftelli64(f)
+#define l_seeknum		__int64
+
+#else
+
+#define l_fseek(f,o,w)		fseek(f,o,w)
+#define l_ftell(f)		ftell(f)
+#define l_seeknum		long
+
+#endif
+
+#endif			/* } */
+
+/* }====================================================== */
+
+
+#define IO_PREFIX	"_IO_"
+#define IO_INPUT	(IO_PREFIX "input")
+#define IO_OUTPUT	(IO_PREFIX "output")
+
+
+typedef luaL_Stream LStream;
+
+
+#define tolstream(L)	((LStream *)luaL_checkudata(L, 1, LUA_FILEHANDLE))
+
+#define isclosed(p)	((p)->closef == NULL)
+
+
+static int io_type (lua_State *L) {
+  LStream *p;
+  luaL_checkany(L, 1);
+  p = (LStream *)luaL_testudata(L, 1, LUA_FILEHANDLE);
+  if (p == NULL)
+    lua_pushnil(L);  /* not a file */
+  else if (isclosed(p))
+    lua_pushliteral(L, "closed file");
+  else
+    lua_pushliteral(L, "file");
+  return 1;
+}
+
+
+static int f_tostring (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (isclosed(p))
+    lua_pushliteral(L, "file (closed)");
+  else
+    lua_pushfstring(L, "file (%p)", p->f);
+  return 1;
+}
+
+
+static FILE *tofile (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (isclosed(p))
+    luaL_error(L, "attempt to use a closed file");
+  lua_assert(p->f);
+  return p->f;
+}
+
+
+/*
+** When creating file handles, always creates a `closed' file handle
+** before opening the actual file; so, if there is a memory error, the
+** file is not left opened.
+*/
+static LStream *newprefile (lua_State *L) {
+  LStream *p = (LStream *)lua_newuserdata(L, sizeof(LStream));
+  p->closef = NULL;  /* mark file handle as 'closed' */
+  luaL_setmetatable(L, LUA_FILEHANDLE);
+  return p;
+}
+
+
+static int aux_close (lua_State *L) {
+  LStream *p = tolstream(L);
+  lua_CFunction cf = p->closef;
+  p->closef = NULL;  /* mark stream as closed */
+  return (*cf)(L);  /* close it */
+}
+
+
+static int io_close (lua_State *L) {
+  if (lua_isnone(L, 1))  /* no argument? */
+    lua_getfield(L, LUA_REGISTRYINDEX, IO_OUTPUT);  /* use standard output */
+  tofile(L);  /* make sure argument is an open stream */
+  return aux_close(L);
+}
+
+
+static int f_gc (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (!isclosed(p) && p->f != NULL)
+    aux_close(L);  /* ignore closed and incompletely open files */
+  return 0;
+}
+
+
+/*
+** function to close regular files
+*/
+static int io_fclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  int res = fclose(p->f);
+  return luaL_fileresult(L, (res == 0), NULL);
+}
+
+
+static LStream *newfile (lua_State *L) {
+  LStream *p = newprefile(L);
+  p->f = NULL;
+  p->closef = &io_fclose;
+  return p;
+}
+
+
+static void opencheck (lua_State *L, const char *fname, const char *mode) {
+  LStream *p = newfile(L);
+  p->f = fopen(fname, mode);
+  if (p->f == NULL)
+    luaL_error(L, "cannot open file " LUA_QS " (%s)", fname, strerror(errno));
+}
+
+
+static int io_open (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  LStream *p = newfile(L);
+  int i = 0;
+  /* check whether 'mode' matches '[rwa]%+?b?' */
+  if (!(mode[i] != '\0' && strchr("rwa", mode[i++]) != NULL &&
+       (mode[i] != '+' || ++i) &&  /* skip if char is '+' */
+       (mode[i] != 'b' || ++i) &&  /* skip if char is 'b' */
+       (mode[i] == '\0')))
+    return luaL_error(L, "invalid mode " LUA_QS
+                         " (should match " LUA_QL("[rwa]%%+?b?") ")", mode);
+  p->f = fopen(filename, mode);
+  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
+}
+
+
+/*
+** function to close 'popen' files
+*/
+static int io_pclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  return luaL_execresult(L, lua_pclose(L, p->f));
+}
+
+
+static int io_popen (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  LStream *p = newprefile(L);
+  p->f = lua_popen(L, filename, mode);
+  p->closef = &io_pclose;
+  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
+}
+
+
+static int io_tmpfile (lua_State *L) {
+  LStream *p = newfile(L);
+  p->f = tmpfile();
+  return (p->f == NULL) ? luaL_fileresult(L, 0, NULL) : 1;
+}
+
+
+static FILE *getiofile (lua_State *L, const char *findex) {
+  LStream *p;
+  lua_getfield(L, LUA_REGISTRYINDEX, findex);
+  p = (LStream *)lua_touserdata(L, -1);
+  if (isclosed(p))
+    luaL_error(L, "standard %s file is closed", findex + strlen(IO_PREFIX));
+  return p->f;
+}
+
+
+static int g_iofile (lua_State *L, const char *f, const char *mode) {
+  if (!lua_isnoneornil(L, 1)) {
+    const char *filename = lua_tostring(L, 1);
+    if (filename)
+      opencheck(L, filename, mode);
+    else {
+      tofile(L);  /* check that it's a valid file handle */
+      lua_pushvalue(L, 1);
+    }
+    lua_setfield(L, LUA_REGISTRYINDEX, f);
+  }
+  /* return current value */
+  lua_getfield(L, LUA_REGISTRYINDEX, f);
+  return 1;
+}
+
+
+static int io_input (lua_State *L) {
+  return g_iofile(L, IO_INPUT, "r");
+}
+
+
+static int io_output (lua_State *L) {
+  return g_iofile(L, IO_OUTPUT, "w");
+}
+
+
+static int io_readline (lua_State *L);
+
+
+static void aux_lines (lua_State *L, int toclose) {
+  int i;
+  int n = lua_gettop(L) - 1;  /* number of arguments to read */
+  /* ensure that arguments will fit here and into 'io_readline' stack */
+  luaL_argcheck(L, n <= LUA_MINSTACK - 3, LUA_MINSTACK - 3, "too many options");
+  lua_pushvalue(L, 1);  /* file handle */
+  lua_pushinteger(L, n);  /* number of arguments to read */
+  lua_pushboolean(L, toclose);  /* close/not close file when finished */
+  for (i = 1; i <= n; i++) lua_pushvalue(L, i + 1);  /* copy arguments */
+  lua_pushcclosure(L, io_readline, 3 + n);
+}
+
+
+static int f_lines (lua_State *L) {
+  tofile(L);  /* check that it's a valid file handle */
+  aux_lines(L, 0);
+  return 1;
+}
+
+
+static int io_lines (lua_State *L) {
+  int toclose;
+  if (lua_isnone(L, 1)) lua_pushnil(L);  /* at least one argument */
+  if (lua_isnil(L, 1)) {  /* no file name? */
+    lua_getfield(L, LUA_REGISTRYINDEX, IO_INPUT);  /* get default input */
+    lua_replace(L, 1);  /* put it at index 1 */
+    tofile(L);  /* check that it's a valid file handle */
+    toclose = 0;  /* do not close it after iteration */
+  }
+  else {  /* open a new file */
+    const char *filename = luaL_checkstring(L, 1);
+    opencheck(L, filename, "r");
+    lua_replace(L, 1);  /* put file at index 1 */
+    toclose = 1;  /* close it after iteration */
+  }
+  aux_lines(L, toclose);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** READ
+** =======================================================
+*/
+
+
+static int read_number (lua_State *L, FILE *f) {
+  lua_Number d;
+  if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1) {
+    lua_pushnumber(L, d);
+    return 1;
+  }
+  else {
+   lua_pushnil(L);  /* "result" to be removed */
+   return 0;  /* read fails */
+  }
+}
+
+
+static int test_eof (lua_State *L, FILE *f) {
+  int c = getc(f);
+  ungetc(c, f);
+  lua_pushlstring(L, NULL, 0);
+  return (c != EOF);
+}
+
+
+static int read_line (lua_State *L, FILE *f, int chop) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    size_t l;
+    char *p = luaL_prepbuffer(&b);
+    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
+      luaL_pushresult(&b);  /* close buffer */
+      return (lua_rawlen(L, -1) > 0);  /* check whether read something */
+    }
+    l = strlen(p);
+    if (l == 0 || p[l-1] != '\n')
+      luaL_addsize(&b, l);
+    else {
+      luaL_addsize(&b, l - chop);  /* chop 'eol' if needed */
+      luaL_pushresult(&b);  /* close buffer */
+      return 1;  /* read at least an `eol' */
+    }
+  }
+}
+
+
+#define MAX_SIZE_T	(~(size_t)0)
+
+static void read_all (lua_State *L, FILE *f) {
+  size_t rlen = LUAL_BUFFERSIZE;  /* how much to read in each cycle */
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    char *p = luaL_prepbuffsize(&b, rlen);
+    size_t nr = fread(p, sizeof(char), rlen, f);
+    luaL_addsize(&b, nr);
+    if (nr < rlen) break;  /* eof? */
+    else if (rlen <= (MAX_SIZE_T / 4))  /* avoid buffers too large */
+      rlen *= 2;  /* double buffer size at each iteration */
+  }
+  luaL_pushresult(&b);  /* close buffer */
+}
+
+
+static int read_chars (lua_State *L, FILE *f, size_t n) {
+  size_t nr;  /* number of chars actually read */
+  char *p;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  p = luaL_prepbuffsize(&b, n);  /* prepare buffer to read whole block */
+  nr = fread(p, sizeof(char), n, f);  /* try to read 'n' chars */
+  luaL_addsize(&b, nr);
+  luaL_pushresult(&b);  /* close buffer */
+  return (nr > 0);  /* true iff read something */
+}
+
+
+static int g_read (lua_State *L, FILE *f, int first) {
+  int nargs = lua_gettop(L) - 1;
+  int success;
+  int n;
+  clearerr(f);
+  if (nargs == 0) {  /* no arguments? */
+    success = read_line(L, f, 1);
+    n = first+1;  /* to return 1 result */
+  }
+  else {  /* ensure stack space for all results and for auxlib's buffer */
+    luaL_checkstack(L, nargs+LUA_MINSTACK, "too many arguments");
+    success = 1;
+    for (n = first; nargs-- && success; n++) {
+      if (lua_type(L, n) == LUA_TNUMBER) {
+        size_t l = (size_t)lua_tointeger(L, n);
+        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+      }
+      else {
+        const char *p = lua_tostring(L, n);
+        luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
+        switch (p[1]) {
+          case 'n':  /* number */
+            success = read_number(L, f);
+            break;
+          case 'l':  /* line */
+            success = read_line(L, f, 1);
+            break;
+          case 'L':  /* line with end-of-line */
+            success = read_line(L, f, 0);
+            break;
+          case 'a':  /* file */
+            read_all(L, f);  /* read entire file */
+            success = 1; /* always success */
+            break;
+          default:
+            return luaL_argerror(L, n, "invalid format");
+        }
+      }
+    }
+  }
+  if (ferror(f))
+    return luaL_fileresult(L, 0, NULL);
+  if (!success) {
+    lua_pop(L, 1);  /* remove last result */
+    lua_pushnil(L);  /* push nil instead */
+  }
+  return n - first;
+}
+
+
+static int io_read (lua_State *L) {
+  return g_read(L, getiofile(L, IO_INPUT), 1);
+}
+
+
+static int f_read (lua_State *L) {
+  return g_read(L, tofile(L), 2);
+}
+
+
+static int io_readline (lua_State *L) {
+  LStream *p = (LStream *)lua_touserdata(L, lua_upvalueindex(1));
+  int i;
+  int n = (int)lua_tointeger(L, lua_upvalueindex(2));
+  if (isclosed(p))  /* file is already closed? */
+    return luaL_error(L, "file is already closed");
+  lua_settop(L , 1);
+  for (i = 1; i <= n; i++)  /* push arguments to 'g_read' */
+    lua_pushvalue(L, lua_upvalueindex(3 + i));
+  n = g_read(L, p->f, 2);  /* 'n' is number of results */
+  lua_assert(n > 0);  /* should return at least a nil */
+  if (!lua_isnil(L, -n))  /* read at least one value? */
+    return n;  /* return them */
+  else {  /* first result is nil: EOF or error */
+    if (n > 1) {  /* is there error information? */
+      /* 2nd result is error message */
+      return luaL_error(L, "%s", lua_tostring(L, -n + 1));
+    }
+    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */
+      lua_settop(L, 0);
+      lua_pushvalue(L, lua_upvalueindex(1));
+      aux_close(L);  /* close it */
+    }
+    return 0;
+  }
+}
+
+/* }====================================================== */
+
+
+static int g_write (lua_State *L, FILE *f, int arg) {
+  int nargs = lua_gettop(L) - arg;
+  int status = 1;
+  for (; nargs--; arg++) {
+    if (lua_type(L, arg) == LUA_TNUMBER) {
+      /* optimization: could be done exactly as for strings */
+      status = status &&
+          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
+    }
+    else {
+      size_t l;
+      const char *s = luaL_checklstring(L, arg, &l);
+      status = status && (fwrite(s, sizeof(char), l, f) == l);
+    }
+  }
+  if (status) return 1;  /* file handle already on stack top */
+  else return luaL_fileresult(L, status, NULL);
+}
+
+
+static int io_write (lua_State *L) {
+  return g_write(L, getiofile(L, IO_OUTPUT), 1);
+}
+
+
+static int f_write (lua_State *L) {
+  FILE *f = tofile(L);
+  lua_pushvalue(L, 1);  /* push file at the stack top (to be returned) */
+  return g_write(L, f, 2);
+}
+
+
+static int f_seek (lua_State *L) {
+  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
+  static const char *const modenames[] = {"set", "cur", "end", NULL};
+  FILE *f = tofile(L);
+  int op = luaL_checkoption(L, 2, "cur", modenames);
+  lua_Number p3 = luaL_optnumber(L, 3, 0);
+  l_seeknum offset = (l_seeknum)p3;
+  luaL_argcheck(L, (lua_Number)offset == p3, 3,
+                  "not an integer in proper range");
+  op = l_fseek(f, offset, mode[op]);
+  if (op)
+    return luaL_fileresult(L, 0, NULL);  /* error */
+  else {
+    lua_pushnumber(L, (lua_Number)l_ftell(f));
+    return 1;
+  }
+}
+
+
+static int f_setvbuf (lua_State *L) {
+  static const int mode[] = {_IONBF, _IOFBF, _IOLBF};
+  static const char *const modenames[] = {"no", "full", "line", NULL};
+  FILE *f = tofile(L);
+  int op = luaL_checkoption(L, 2, NULL, modenames);
+  lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
+  int res = setvbuf(f, NULL, mode[op], sz);
+  return luaL_fileresult(L, res == 0, NULL);
+}
+
+
+
+static int io_flush (lua_State *L) {
+  return luaL_fileresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
+}
+
+
+static int f_flush (lua_State *L) {
+  return luaL_fileresult(L, fflush(tofile(L)) == 0, NULL);
+}
+
+
+/*
+** functions for 'io' library
+*/
+static const luaL_Reg iolib[] = {
+  {"close", io_close},
+  {"flush", io_flush},
+  {"input", io_input},
+  {"lines", io_lines},
+  {"open", io_open},
+  {"output", io_output},
+  {"popen", io_popen},
+  {"read", io_read},
+  {"tmpfile", io_tmpfile},
+  {"type", io_type},
+  {"write", io_write},
+  {NULL, NULL}
+};
+
+
+/*
+** methods for file handles
+*/
+static const luaL_Reg flib[] = {
+  {"close", io_close},
+  {"flush", f_flush},
+  {"lines", f_lines},
+  {"read", f_read},
+  {"seek", f_seek},
+  {"setvbuf", f_setvbuf},
+  {"write", f_write},
+  {"__gc", f_gc},
+  {"__tostring", f_tostring},
+  {NULL, NULL}
+};
+
+
+static void createmeta (lua_State *L) {
+  luaL_newmetatable(L, LUA_FILEHANDLE);  /* create metatable for file handles */
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  luaL_setfuncs(L, flib, 0);  /* add file methods to new metatable */
+  lua_pop(L, 1);  /* pop new metatable */
+}
+
+
+/*
+** function to (not) close the standard files stdin, stdout, and stderr
+*/
+static int io_noclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  p->closef = &io_noclose;  /* keep file opened */
+  lua_pushnil(L);
+  lua_pushliteral(L, "cannot close standard file");
+  return 2;
+}
+
+
+static void createstdfile (lua_State *L, FILE *f, const char *k,
+                           const char *fname) {
+  LStream *p = newprefile(L);
+  p->f = f;
+  p->closef = &io_noclose;
+  if (k != NULL) {
+    lua_pushvalue(L, -1);
+    lua_setfield(L, LUA_REGISTRYINDEX, k);  /* add file to registry */
+  }
+  lua_setfield(L, -2, fname);  /* add file to module */
+}
+
+
+LUAMOD_API int luaopen_io (lua_State *L) {
+  luaL_newlib(L, iolib);  /* new module */
+  createmeta(L);
+  /* create (and set) default files */
+  createstdfile(L, stdin, IO_INPUT, "stdin");
+  createstdfile(L, stdout, IO_OUTPUT, "stdout");
+  createstdfile(L, stderr, NULL, "stderr");
+  return 1;
+}
+
diff --git a/dep/lualib/llex.c b/dep/lualib/llex.c
new file mode 100644
index 0000000..c4d8c65
--- /dev/null
+++ b/dep/lualib/llex.c
@@ -0,0 +1,527 @@
+/*
+** $Id: llex.c,v 2.61 2012/01/23 23:05:51 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+
+#include <locale.h>
+#include <string.h>
+
+#define llex_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lctype.h"
+#include "ldo.h"
+#include "llex.h"
+#include "lobject.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lzio.h"
+
+
+
+#define next(ls) (ls->current = zgetc(ls->z))
+
+
+
+#define currIsNewline(ls)	(ls->current == '\n' || ls->current == '\r')
+
+
+/* ORDER RESERVED */
+static const char *const luaX_tokens [] = {
+    "and", "break", "do", "else", "elseif",
+    "end", "false", "for", "function", "goto", "if",
+    "in", "local", "nil", "not", "or", "repeat",
+    "return", "then", "true", "until", "while",
+    "..", "...", "==", ">=", "<=", "~=", "::", "<eof>",
+    "<number>", "<name>", "<string>"
+};
+
+
+#define save_and_next(ls) (save(ls, ls->current), next(ls))
+
+
+static l_noret lexerror (LexState *ls, const char *msg, int token);
+
+
+static void save (LexState *ls, int c) {
+  Mbuffer *b = ls->buff;
+  if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {
+    size_t newsize;
+    if (luaZ_sizebuffer(b) >= MAX_SIZET/2)
+      lexerror(ls, "lexical element too long", 0);
+    newsize = luaZ_sizebuffer(b) * 2;
+    luaZ_resizebuffer(ls->L, b, newsize);
+  }
+  b->buffer[luaZ_bufflen(b)++] = cast(char, c);
+}
+
+
+void luaX_init (lua_State *L) {
+  int i;
+  for (i=0; i<NUM_RESERVED; i++) {
+    TString *ts = luaS_new(L, luaX_tokens[i]);
+    luaS_fix(ts);  /* reserved words are never collected */
+    ts->tsv.extra = cast_byte(i+1);  /* reserved word */
+  }
+}
+
+
+const char *luaX_token2str (LexState *ls, int token) {
+  if (token < FIRST_RESERVED) {
+    lua_assert(token == cast(unsigned char, token));
+    return (lisprint(token)) ? luaO_pushfstring(ls->L, LUA_QL("%c"), token) :
+                              luaO_pushfstring(ls->L, "char(%d)", token);
+  }
+  else {
+    const char *s = luaX_tokens[token - FIRST_RESERVED];
+    if (token < TK_EOS)
+      return luaO_pushfstring(ls->L, LUA_QS, s);
+    else
+      return s;
+  }
+}
+
+
+static const char *txtToken (LexState *ls, int token) {
+  switch (token) {
+    case TK_NAME:
+    case TK_STRING:
+    case TK_NUMBER:
+      save(ls, '\0');
+      return luaO_pushfstring(ls->L, LUA_QS, luaZ_buffer(ls->buff));
+    default:
+      return luaX_token2str(ls, token);
+  }
+}
+
+
+static l_noret lexerror (LexState *ls, const char *msg, int token) {
+  char buff[LUA_IDSIZE];
+  luaO_chunkid(buff, getstr(ls->source), LUA_IDSIZE);
+  msg = luaO_pushfstring(ls->L, "%s:%d: %s", buff, ls->linenumber, msg);
+  if (token)
+    luaO_pushfstring(ls->L, "%s near %s", msg, txtToken(ls, token));
+  luaD_throw(ls->L, LUA_ERRSYNTAX);
+}
+
+
+l_noret luaX_syntaxerror (LexState *ls, const char *msg) {
+  lexerror(ls, msg, ls->t.token);
+}
+
+
+/*
+** creates a new string and anchors it in function's table so that
+** it will not be collected until the end of the function's compilation
+** (by that time it should be anchored in function's prototype)
+*/
+TString *luaX_newstring (LexState *ls, const char *str, size_t l) {
+  lua_State *L = ls->L;
+  TValue *o;  /* entry for `str' */
+  TString *ts = luaS_newlstr(L, str, l);  /* create new string */
+  setsvalue2s(L, L->top++, ts);  /* temporarily anchor it in stack */
+  o = luaH_set(L, ls->fs->h, L->top - 1);
+  if (ttisnil(o)) {  /* not in use yet? (see 'addK') */
+    /* boolean value does not need GC barrier;
+       table has no metatable, so it does not need to invalidate cache */
+    setbvalue(o, 1);  /* t[string] = true */
+    luaC_checkGC(L);
+  }
+  L->top--;  /* remove string from stack */
+  return ts;
+}
+
+
+/*
+** increment line number and skips newline sequence (any of
+** \n, \r, \n\r, or \r\n)
+*/
+static void inclinenumber (LexState *ls) {
+  int old = ls->current;
+  lua_assert(currIsNewline(ls));
+  next(ls);  /* skip `\n' or `\r' */
+  if (currIsNewline(ls) && ls->current != old)
+    next(ls);  /* skip `\n\r' or `\r\n' */
+  if (++ls->linenumber >= MAX_INT)
+    luaX_syntaxerror(ls, "chunk has too many lines");
+}
+
+
+void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
+                    int firstchar) {
+  ls->decpoint = '.';
+  ls->L = L;
+  ls->current = firstchar;
+  ls->lookahead.token = TK_EOS;  /* no look-ahead token */
+  ls->z = z;
+  ls->fs = NULL;
+  ls->linenumber = 1;
+  ls->lastline = 1;
+  ls->source = source;
+  ls->envn = luaS_new(L, LUA_ENV);  /* create env name */
+  luaS_fix(ls->envn);  /* never collect this name */
+  luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  /* initialize buffer */
+}
+
+
+
+/*
+** =======================================================
+** LEXICAL ANALYZER
+** =======================================================
+*/
+
+
+
+static int check_next (LexState *ls, const char *set) {
+  if (ls->current == '\0' || !strchr(set, ls->current))
+    return 0;
+  save_and_next(ls);
+  return 1;
+}
+
+
+/*
+** change all characters 'from' in buffer to 'to'
+*/
+static void buffreplace (LexState *ls, char from, char to) {
+  size_t n = luaZ_bufflen(ls->buff);
+  char *p = luaZ_buffer(ls->buff);
+  while (n--)
+    if (p[n] == from) p[n] = to;
+}
+
+
+#if !defined(getlocaledecpoint)
+#define getlocaledecpoint()	(localeconv()->decimal_point[0])
+#endif
+
+
+#define buff2d(b,e)	luaO_str2d(luaZ_buffer(b), luaZ_bufflen(b) - 1, e)
+
+/*
+** in case of format error, try to change decimal point separator to
+** the one defined in the current locale and check again
+*/
+static void trydecpoint (LexState *ls, SemInfo *seminfo) {
+  char old = ls->decpoint;
+  ls->decpoint = getlocaledecpoint();
+  buffreplace(ls, old, ls->decpoint);  /* try new decimal separator */
+  if (!buff2d(ls->buff, &seminfo->r)) {
+    /* format error with correct decimal point: no more options */
+    buffreplace(ls, ls->decpoint, '.');  /* undo change (for error message) */
+    lexerror(ls, "malformed number", TK_NUMBER);
+  }
+}
+
+
+/* LUA_NUMBER */
+/*
+** this function is quite liberal in what it accepts, as 'luaO_str2d'
+** will reject ill-formed numerals.
+*/
+static void read_numeral (LexState *ls, SemInfo *seminfo) {
+  const char *expo = "Ee";
+  int first = ls->current;
+  lua_assert(lisdigit(ls->current));
+  save_and_next(ls);
+  if (first == '0' && check_next(ls, "Xx"))  /* hexadecimal? */
+    expo = "Pp";
+  for (;;) {
+    if (check_next(ls, expo))  /* exponent part? */
+      check_next(ls, "+-");  /* optional exponent sign */
+    if (lisxdigit(ls->current) || ls->current == '.')
+      save_and_next(ls);
+    else  break;
+  }
+  save(ls, '\0');
+  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */
+  if (!buff2d(ls->buff, &seminfo->r))  /* format error? */
+    trydecpoint(ls, seminfo); /* try to update decimal point separator */
+}
+
+
+/*
+** skip a sequence '[=*[' or ']=*]' and return its number of '='s or
+** -1 if sequence is malformed
+*/
+static int skip_sep (LexState *ls) {
+  int count = 0;
+  int s = ls->current;
+  lua_assert(s == '[' || s == ']');
+  save_and_next(ls);
+  while (ls->current == '=') {
+    save_and_next(ls);
+    count++;
+  }
+  return (ls->current == s) ? count : (-count) - 1;
+}
+
+
+static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {
+  save_and_next(ls);  /* skip 2nd `[' */
+  if (currIsNewline(ls))  /* string starts with a newline? */
+    inclinenumber(ls);  /* skip it */
+  for (;;) {
+    switch (ls->current) {
+      case EOZ:
+        lexerror(ls, (seminfo) ? "unfinished long string" :
+                                 "unfinished long comment", TK_EOS);
+        break;  /* to avoid warnings */
+      case ']': {
+        if (skip_sep(ls) == sep) {
+          save_and_next(ls);  /* skip 2nd `]' */
+          goto endloop;
+        }
+        break;
+      }
+      case '\n': case '\r': {
+        save(ls, '\n');
+        inclinenumber(ls);
+        if (!seminfo) luaZ_resetbuffer(ls->buff);  /* avoid wasting space */
+        break;
+      }
+      default: {
+        if (seminfo) save_and_next(ls);
+        else next(ls);
+      }
+    }
+  } endloop:
+  if (seminfo)
+    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + (2 + sep),
+                                     luaZ_bufflen(ls->buff) - 2*(2 + sep));
+}
+
+
+static void escerror (LexState *ls, int *c, int n, const char *msg) {
+  int i;
+  luaZ_resetbuffer(ls->buff);  /* prepare error message */
+  save(ls, '\\');
+  for (i = 0; i < n && c[i] != EOZ; i++)
+    save(ls, c[i]);
+  lexerror(ls, msg, TK_STRING);
+}
+
+
+static int readhexaesc (LexState *ls) {
+  int c[3], i;  /* keep input for error message */
+  int r = 0;  /* result accumulator */
+  c[0] = 'x';  /* for error message */
+  for (i = 1; i < 3; i++) {  /* read two hexa digits */
+    c[i] = next(ls);
+    if (!lisxdigit(c[i]))
+      escerror(ls, c, i + 1, "hexadecimal digit expected");
+    r = (r << 4) + luaO_hexavalue(c[i]);
+  }
+  return r;
+}
+
+
+static int readdecesc (LexState *ls) {
+  int c[3], i;
+  int r = 0;  /* result accumulator */
+  for (i = 0; i < 3 && lisdigit(ls->current); i++) {  /* read up to 3 digits */
+    c[i] = ls->current;
+    r = 10*r + c[i] - '0';
+    next(ls);
+  }
+  if (r > UCHAR_MAX)
+    escerror(ls, c, i, "decimal escape too large");
+  return r;
+}
+
+
+static void read_string (LexState *ls, int del, SemInfo *seminfo) {
+  save_and_next(ls);  /* keep delimiter (for error messages) */
+  while (ls->current != del) {
+    switch (ls->current) {
+      case EOZ:
+        lexerror(ls, "unfinished string", TK_EOS);
+        break;  /* to avoid warnings */
+      case '\n':
+      case '\r':
+        lexerror(ls, "unfinished string", TK_STRING);
+        break;  /* to avoid warnings */
+      case '\\': {  /* escape sequences */
+        int c;  /* final character to be saved */
+        next(ls);  /* do not save the `\' */
+        switch (ls->current) {
+          case 'a': c = '\a'; goto read_save;
+          case 'b': c = '\b'; goto read_save;
+          case 'f': c = '\f'; goto read_save;
+          case 'n': c = '\n'; goto read_save;
+          case 'r': c = '\r'; goto read_save;
+          case 't': c = '\t'; goto read_save;
+          case 'v': c = '\v'; goto read_save;
+          case 'x': c = readhexaesc(ls); goto read_save;
+          case '\n': case '\r':
+            inclinenumber(ls); c = '\n'; goto only_save;
+          case '\\': case '\"': case '\'':
+            c = ls->current; goto read_save;
+          case EOZ: goto no_save;  /* will raise an error next loop */
+          case 'z': {  /* zap following span of spaces */
+            next(ls);  /* skip the 'z' */
+            while (lisspace(ls->current)) {
+              if (currIsNewline(ls)) inclinenumber(ls);
+              else next(ls);
+            }
+            goto no_save;
+          }
+          default: {
+            if (!lisdigit(ls->current))
+              escerror(ls, &ls->current, 1, "invalid escape sequence");
+            /* digital escape \ddd */
+            c = readdecesc(ls);
+            goto only_save;
+          }
+        }
+       read_save: next(ls);  /* read next character */
+       only_save: save(ls, c);  /* save 'c' */
+       no_save: break;
+      }
+      default:
+        save_and_next(ls);
+    }
+  }
+  save_and_next(ls);  /* skip delimiter */
+  seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,
+                                   luaZ_bufflen(ls->buff) - 2);
+}
+
+
+static int llex (LexState *ls, SemInfo *seminfo) {
+  luaZ_resetbuffer(ls->buff);
+  for (;;) {
+    switch (ls->current) {
+      case '\n': case '\r': {  /* line breaks */
+        inclinenumber(ls);
+        break;
+      }
+      case ' ': case '\f': case '\t': case '\v': {  /* spaces */
+        next(ls);
+        break;
+      }
+      case '-': {  /* '-' or '--' (comment) */
+        next(ls);
+        if (ls->current != '-') return '-';
+        /* else is a comment */
+        next(ls);
+        if (ls->current == '[') {  /* long comment? */
+          int sep = skip_sep(ls);
+          luaZ_resetbuffer(ls->buff);  /* `skip_sep' may dirty the buffer */
+          if (sep >= 0) {
+            read_long_string(ls, NULL, sep);  /* skip long comment */
+            luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */
+            break;
+          }
+        }
+        /* else short comment */
+        while (!currIsNewline(ls) && ls->current != EOZ)
+          next(ls);  /* skip until end of line (or end of file) */
+        break;
+      }
+      case '[': {  /* long string or simply '[' */
+        int sep = skip_sep(ls);
+        if (sep >= 0) {
+          read_long_string(ls, seminfo, sep);
+          return TK_STRING;
+        }
+        else if (sep == -1) return '[';
+        else lexerror(ls, "invalid long string delimiter", TK_STRING);
+      }
+      case '=': {
+        next(ls);
+        if (ls->current != '=') return '=';
+        else { next(ls); return TK_EQ; }
+      }
+      case '<': {
+        next(ls);
+        if (ls->current != '=') return '<';
+        else { next(ls); return TK_LE; }
+      }
+      case '>': {
+        next(ls);
+        if (ls->current != '=') return '>';
+        else { next(ls); return TK_GE; }
+      }
+      case '~': {
+        next(ls);
+        if (ls->current != '=') return '~';
+        else { next(ls); return TK_NE; }
+      }
+      case ':': {
+        next(ls);
+        if (ls->current != ':') return ':';
+        else { next(ls); return TK_DBCOLON; }
+      }
+      case '"': case '\'': {  /* short literal strings */
+        read_string(ls, ls->current, seminfo);
+        return TK_STRING;
+      }
+      case '.': {  /* '.', '..', '...', or number */
+        save_and_next(ls);
+        if (check_next(ls, ".")) {
+          if (check_next(ls, "."))
+            return TK_DOTS;   /* '...' */
+          else return TK_CONCAT;   /* '..' */
+        }
+        else if (!lisdigit(ls->current)) return '.';
+        /* else go through */
+      }
+      case '0': case '1': case '2': case '3': case '4':
+      case '5': case '6': case '7': case '8': case '9': {
+        read_numeral(ls, seminfo);
+        return TK_NUMBER;
+      }
+      case EOZ: {
+        return TK_EOS;
+      }
+      default: {
+        if (lislalpha(ls->current)) {  /* identifier or reserved word? */
+          TString *ts;
+          do {
+            save_and_next(ls);
+          } while (lislalnum(ls->current));
+          ts = luaX_newstring(ls, luaZ_buffer(ls->buff),
+                                  luaZ_bufflen(ls->buff));
+          seminfo->ts = ts;
+          if (isreserved(ts))  /* reserved word? */
+            return ts->tsv.extra - 1 + FIRST_RESERVED;
+          else {
+            return TK_NAME;
+          }
+        }
+        else {  /* single-char tokens (+ - / ...) */
+          int c = ls->current;
+          next(ls);
+          return c;
+        }
+      }
+    }
+  }
+}
+
+
+void luaX_next (LexState *ls) {
+  ls->lastline = ls->linenumber;
+  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
+    ls->t = ls->lookahead;  /* use this one */
+    ls->lookahead.token = TK_EOS;  /* and discharge it */
+  }
+  else
+    ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */
+}
+
+
+int luaX_lookahead (LexState *ls) {
+  lua_assert(ls->lookahead.token == TK_EOS);
+  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);
+  return ls->lookahead.token;
+}
+
diff --git a/dep/lualib/llex.h b/dep/lualib/llex.h
new file mode 100644
index 0000000..9ca8a29
--- /dev/null
+++ b/dep/lualib/llex.h
@@ -0,0 +1,78 @@
+/*
+** $Id: llex.h,v 1.72 2011/11/30 12:43:51 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llex_h
+#define llex_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+
+#define FIRST_RESERVED	257
+
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER RESERVED"
+*/
+enum RESERVED {
+  /* terminal symbols denoted by reserved words */
+  TK_AND = FIRST_RESERVED, TK_BREAK,
+  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
+  TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
+  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
+  /* other terminal symbols */
+  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_DBCOLON, TK_EOS,
+  TK_NUMBER, TK_NAME, TK_STRING
+};
+
+/* number of reserved words */
+#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
+
+
+typedef union {
+  lua_Number r;
+  TString *ts;
+} SemInfo;  /* semantics information */
+
+
+typedef struct Token {
+  int token;
+  SemInfo seminfo;
+} Token;
+
+
+/* state of the lexer plus state of the parser when shared by all
+   functions */
+typedef struct LexState {
+  int current;  /* current character (charint) */
+  int linenumber;  /* input line counter */
+  int lastline;  /* line of last token `consumed' */
+  Token t;  /* current token */
+  Token lookahead;  /* look ahead token */
+  struct FuncState *fs;  /* current function (parser) */
+  struct lua_State *L;
+  ZIO *z;  /* input stream */
+  Mbuffer *buff;  /* buffer for tokens */
+  struct Dyndata *dyd;  /* dynamic structures used by the parser */
+  TString *source;  /* current source name */
+  TString *envn;  /* environment variable name */
+  char decpoint;  /* locale decimal point */
+} LexState;
+
+
+LUAI_FUNC void luaX_init (lua_State *L);
+LUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,
+                              TString *source, int firstchar);
+LUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);
+LUAI_FUNC void luaX_next (LexState *ls);
+LUAI_FUNC int luaX_lookahead (LexState *ls);
+LUAI_FUNC l_noret luaX_syntaxerror (LexState *ls, const char *s);
+LUAI_FUNC const char *luaX_token2str (LexState *ls, int token);
+
+
+#endif
diff --git a/dep/lualib/llimits.h b/dep/lualib/llimits.h
new file mode 100644
index 0000000..fc9de1a
--- /dev/null
+++ b/dep/lualib/llimits.h
@@ -0,0 +1,309 @@
+/*
+** $Id: llimits.h,v 1.99 2012/05/28 20:32:28 roberto Exp $
+** Limits, basic types, and some other `installation-dependent' definitions
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llimits_h
+#define llimits_h
+
+
+#include <limits.h>
+#include <stddef.h>
+
+
+#include "lua.h"
+
+
+typedef unsigned LUA_INT32 lu_int32;
+
+typedef LUAI_UMEM lu_mem;
+
+typedef LUAI_MEM l_mem;
+
+
+
+/* chars used as small naturals (so that `char' is reserved for characters) */
+typedef unsigned char lu_byte;
+
+
+#define MAX_SIZET	((size_t)(~(size_t)0)-2)
+
+#define MAX_LUMEM	((lu_mem)(~(lu_mem)0)-2)
+
+#define MAX_LMEM	((l_mem) ((MAX_LUMEM >> 1) - 2))
+
+
+#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */
+
+/*
+** conversion of pointer to integer
+** this is for hashing only; there is no problem if the integer
+** cannot hold the whole pointer value
+*/
+#define IntPoint(p)  ((unsigned int)(lu_mem)(p))
+
+
+
+/* type to ensure maximum alignment */
+#if !defined(LUAI_USER_ALIGNMENT_T)
+#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }
+#endif
+
+typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;
+
+
+/* result of a `usual argument conversion' over lua_Number */
+typedef LUAI_UACNUMBER l_uacNumber;
+
+
+/* internal assertions for in-house debugging */
+#if defined(lua_assert)
+#define check_exp(c,e)		(lua_assert(c), (e))
+/* to avoid problems with conditions too long */
+#define lua_longassert(c)	{ if (!(c)) lua_assert(0); }
+#else
+#define lua_assert(c)		((void)0)
+#define check_exp(c,e)		(e)
+#define lua_longassert(c)	((void)0)
+#endif
+
+/*
+** assertion for checking API calls
+*/
+#if !defined(luai_apicheck)
+
+#if defined(LUA_USE_APICHECK)
+#include <assert.h>
+#define luai_apicheck(L,e)	assert(e)
+#else
+#define luai_apicheck(L,e)	lua_assert(e)
+#endif
+
+#endif
+
+#define api_check(l,e,msg)	luai_apicheck(l,(e) && msg)
+
+
+#if !defined(UNUSED)
+#define UNUSED(x)	((void)(x))	/* to avoid warnings */
+#endif
+
+
+#define cast(t, exp)	((t)(exp))
+
+#define cast_byte(i)	cast(lu_byte, (i))
+#define cast_num(i)	cast(lua_Number, (i))
+#define cast_int(i)	cast(int, (i))
+#define cast_uchar(i)	cast(unsigned char, (i))
+
+
+/*
+** non-return type
+*/
+#if defined(__GNUC__)
+#define l_noret		void __attribute__((noreturn))
+#elif defined(_MSC_VER)
+#define l_noret		void __declspec(noreturn)
+#else
+#define l_noret		void
+#endif
+
+
+
+/*
+** maximum depth for nested C calls and syntactical nested non-terminals
+** in a program. (Value must fit in an unsigned short int.)
+*/
+#if !defined(LUAI_MAXCCALLS)
+#define LUAI_MAXCCALLS		200
+#endif
+
+/*
+** maximum number of upvalues in a closure (both C and Lua). (Value
+** must fit in an unsigned char.)
+*/
+#define MAXUPVAL	UCHAR_MAX
+
+
+/*
+** type for virtual-machine instructions
+** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
+*/
+typedef lu_int32 Instruction;
+
+
+
+/* maximum stack for a Lua function */
+#define MAXSTACK	250
+
+
+
+/* minimum size for the string table (must be power of 2) */
+#if !defined(MINSTRTABSIZE)
+#define MINSTRTABSIZE	32
+#endif
+
+
+/* minimum size for string buffer */
+#if !defined(LUA_MINBUFFER)
+#define LUA_MINBUFFER	32
+#endif
+
+
+#if !defined(lua_lock)
+#define lua_lock(L)     ((void) 0)
+#define lua_unlock(L)   ((void) 0)
+#endif
+
+#if !defined(luai_threadyield)
+#define luai_threadyield(L)     {lua_unlock(L); lua_lock(L);}
+#endif
+
+
+/*
+** these macros allow user-specific actions on threads when you defined
+** LUAI_EXTRASPACE and need to do something extra when a thread is
+** created/deleted/resumed/yielded.
+*/
+#if !defined(luai_userstateopen)
+#define luai_userstateopen(L)		((void)L)
+#endif
+
+#if !defined(luai_userstateclose)
+#define luai_userstateclose(L)		((void)L)
+#endif
+
+#if !defined(luai_userstatethread)
+#define luai_userstatethread(L,L1)	((void)L)
+#endif
+
+#if !defined(luai_userstatefree)
+#define luai_userstatefree(L,L1)	((void)L)
+#endif
+
+#if !defined(luai_userstateresume)
+#define luai_userstateresume(L,n)       ((void)L)
+#endif
+
+#if !defined(luai_userstateyield)
+#define luai_userstateyield(L,n)        ((void)L)
+#endif
+
+/*
+** lua_number2int is a macro to convert lua_Number to int.
+** lua_number2integer is a macro to convert lua_Number to lua_Integer.
+** lua_number2unsigned is a macro to convert a lua_Number to a lua_Unsigned.
+** lua_unsigned2number is a macro to convert a lua_Unsigned to a lua_Number.
+** luai_hashnum is a macro to hash a lua_Number value into an integer.
+** The hash must be deterministic and give reasonable values for
+** both small and large values (outside the range of integers).
+*/
+
+#if defined(MS_ASMTRICK)	/* { */
+/* trick with Microsoft assembler for X86 */
+
+#define lua_number2int(i,n)  __asm {__asm fld n   __asm fistp i}
+#define lua_number2integer(i,n)		lua_number2int(i, n)
+#define lua_number2unsigned(i,n)  \
+  {__int64 l; __asm {__asm fld n   __asm fistp l} i = (unsigned int)l;}
+
+
+#elif defined(LUA_IEEE754TRICK)		/* }{ */
+/* the next trick should work on any machine using IEEE754 with
+   a 32-bit int type */
+
+union luai_Cast { double l_d; LUA_INT32 l_p[2]; };
+
+#if !defined(LUA_IEEEENDIAN)	/* { */
+#define LUAI_EXTRAIEEE	\
+  static const union luai_Cast ieeeendian = {-(33.0 + 6755399441055744.0)};
+#define LUA_IEEEENDIANLOC	(ieeeendian.l_p[1] == 33)
+#else
+#define LUA_IEEEENDIANLOC	LUA_IEEEENDIAN
+#define LUAI_EXTRAIEEE		/* empty */
+#endif				/* } */
+
+#define lua_number2int32(i,n,t) \
+  { LUAI_EXTRAIEEE \
+    volatile union luai_Cast u; u.l_d = (n) + 6755399441055744.0; \
+    (i) = (t)u.l_p[LUA_IEEEENDIANLOC]; }
+
+#define luai_hashnum(i,n)  \
+  { volatile union luai_Cast u; u.l_d = (n) + 1.0;  /* avoid -0 */ \
+    (i) = u.l_p[0]; (i) += u.l_p[1]; }  /* add double bits for his hash */
+
+#define lua_number2int(i,n)		lua_number2int32(i, n, int)
+#define lua_number2unsigned(i,n)	lua_number2int32(i, n, lua_Unsigned)
+
+/* the trick can be expanded to lua_Integer when it is a 32-bit value */
+#if defined(LUA_IEEELL)
+#define lua_number2integer(i,n)		lua_number2int32(i, n, lua_Integer)
+#endif
+
+#endif				/* } */
+
+
+/* the following definitions always work, but may be slow */
+
+#if !defined(lua_number2int)
+#define lua_number2int(i,n)	((i)=(int)(n))
+#endif
+
+#if !defined(lua_number2integer)
+#define lua_number2integer(i,n)	((i)=(lua_Integer)(n))
+#endif
+
+#if !defined(lua_number2unsigned)	/* { */
+/* the following definition assures proper modulo behavior */
+#if defined(LUA_NUMBER_DOUBLE)
+#include <math.h>
+#define SUPUNSIGNED	((lua_Number)(~(lua_Unsigned)0) + 1)
+#define lua_number2unsigned(i,n)  \
+	((i)=(lua_Unsigned)((n) - floor((n)/SUPUNSIGNED)*SUPUNSIGNED))
+#else
+#define lua_number2unsigned(i,n)	((i)=(lua_Unsigned)(n))
+#endif
+#endif				/* } */
+
+
+#if !defined(lua_unsigned2number)
+/* on several machines, coercion from unsigned to double is slow,
+   so it may be worth to avoid */
+#define lua_unsigned2number(u)  \
+    (((u) <= (lua_Unsigned)INT_MAX) ? (lua_Number)(int)(u) : (lua_Number)(u))
+#endif
+
+
+
+#if defined(ltable_c) && !defined(luai_hashnum)
+
+#include <float.h>
+#include <math.h>
+
+#define luai_hashnum(i,n) { int e;  \
+  n = frexp(n, &e) * (lua_Number)(INT_MAX - DBL_MAX_EXP);  \
+  lua_number2int(i, n); i += e; }
+
+#endif
+
+
+
+/*
+** macro to control inclusion of some hard tests on stack reallocation
+*/
+#if !defined(HARDSTACKTESTS)
+#define condmovestack(L)	((void)0)
+#else
+/* realloc stack keeping its size */
+#define condmovestack(L)	luaD_reallocstack((L), (L)->stacksize)
+#endif
+
+#if !defined(HARDMEMTESTS)
+#define condchangemem(L)	condmovestack(L)
+#else
+#define condchangemem(L)  \
+	((void)(!(G(L)->gcrunning) || (luaC_fullgc(L, 0), 1)))
+#endif
+
+#endif
diff --git a/dep/lualib/lmathlib.c b/dep/lualib/lmathlib.c
new file mode 100644
index 0000000..c3c605e
--- /dev/null
+++ b/dep/lualib/lmathlib.c
@@ -0,0 +1,283 @@
+/*
+** $Id: lmathlib.c,v 1.81 2012/05/18 17:47:53 roberto Exp $
+** Standard mathematical library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+#include <math.h>
+
+#define lmathlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/* macro 'l_tg' allows the addition of an 'l' or 'f' to all math operations */
+#if !defined(l_tg)
+#define l_tg(x)		(x)
+#endif
+
+
+#undef PI
+#define PI (l_tg(3.1415926535897932384626433832795))
+#define RADIANS_PER_DEGREE (PI/180.0)
+
+
+
+static int math_abs (lua_State *L) {
+  lua_pushnumber(L, l_tg(fabs)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sin (lua_State *L) {
+  lua_pushnumber(L, l_tg(sin)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sinh (lua_State *L) {
+  lua_pushnumber(L, l_tg(sinh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_cos (lua_State *L) {
+  lua_pushnumber(L, l_tg(cos)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_cosh (lua_State *L) {
+  lua_pushnumber(L, l_tg(cosh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_tan (lua_State *L) {
+  lua_pushnumber(L, l_tg(tan)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_tanh (lua_State *L) {
+  lua_pushnumber(L, l_tg(tanh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_asin (lua_State *L) {
+  lua_pushnumber(L, l_tg(asin)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_acos (lua_State *L) {
+  lua_pushnumber(L, l_tg(acos)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_atan (lua_State *L) {
+  lua_pushnumber(L, l_tg(atan)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_atan2 (lua_State *L) {
+  lua_pushnumber(L, l_tg(atan2)(luaL_checknumber(L, 1),
+                                luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_ceil (lua_State *L) {
+  lua_pushnumber(L, l_tg(ceil)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_floor (lua_State *L) {
+  lua_pushnumber(L, l_tg(floor)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_fmod (lua_State *L) {
+  lua_pushnumber(L, l_tg(fmod)(luaL_checknumber(L, 1),
+                               luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_modf (lua_State *L) {
+  lua_Number ip;
+  lua_Number fp = l_tg(modf)(luaL_checknumber(L, 1), &ip);
+  lua_pushnumber(L, ip);
+  lua_pushnumber(L, fp);
+  return 2;
+}
+
+static int math_sqrt (lua_State *L) {
+  lua_pushnumber(L, l_tg(sqrt)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_pow (lua_State *L) {
+  lua_pushnumber(L, l_tg(pow)(luaL_checknumber(L, 1),
+                              luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_log (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  lua_Number res;
+  if (lua_isnoneornil(L, 2))
+    res = l_tg(log)(x);
+  else {
+    lua_Number base = luaL_checknumber(L, 2);
+    if (base == 10.0) res = l_tg(log10)(x);
+    else res = l_tg(log)(x)/l_tg(log)(base);
+  }
+  lua_pushnumber(L, res);
+  return 1;
+}
+
+#if defined(LUA_COMPAT_LOG10)
+static int math_log10 (lua_State *L) {
+  lua_pushnumber(L, l_tg(log10)(luaL_checknumber(L, 1)));
+  return 1;
+}
+#endif
+
+static int math_exp (lua_State *L) {
+  lua_pushnumber(L, l_tg(exp)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_deg (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_rad (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_frexp (lua_State *L) {
+  int e;
+  lua_pushnumber(L, l_tg(frexp)(luaL_checknumber(L, 1), &e));
+  lua_pushinteger(L, e);
+  return 2;
+}
+
+static int math_ldexp (lua_State *L) {
+  lua_pushnumber(L, l_tg(ldexp)(luaL_checknumber(L, 1),
+                                luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+
+static int math_min (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmin = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d < dmin)
+      dmin = d;
+  }
+  lua_pushnumber(L, dmin);
+  return 1;
+}
+
+
+static int math_max (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmax = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d > dmax)
+      dmax = d;
+  }
+  lua_pushnumber(L, dmax);
+  return 1;
+}
+
+
+static int math_random (lua_State *L) {
+  /* the `%' avoids the (rare) case of r==1, and is needed also because on
+     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
+  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
+  switch (lua_gettop(L)) {  /* check number of arguments */
+    case 0: {  /* no arguments */
+      lua_pushnumber(L, r);  /* Number between 0 and 1 */
+      break;
+    }
+    case 1: {  /* only upper limit */
+      lua_Number u = luaL_checknumber(L, 1);
+      luaL_argcheck(L, 1.0 <= u, 1, "interval is empty");
+      lua_pushnumber(L, l_tg(floor)(r*u) + 1.0);  /* int in [1, u] */
+      break;
+    }
+    case 2: {  /* lower and upper limits */
+      lua_Number l = luaL_checknumber(L, 1);
+      lua_Number u = luaL_checknumber(L, 2);
+      luaL_argcheck(L, l <= u, 2, "interval is empty");
+      lua_pushnumber(L, l_tg(floor)(r*(u-l+1)) + l);  /* int in [l, u] */
+      break;
+    }
+    default: return luaL_error(L, "wrong number of arguments");
+  }
+  return 1;
+}
+
+
+static int math_randomseed (lua_State *L) {
+  srand(luaL_checkunsigned(L, 1));
+  (void)rand(); /* discard first value to avoid undesirable correlations */
+  return 0;
+}
+
+
+static const luaL_Reg mathlib[] = {
+  {"abs",   math_abs},
+  {"acos",  math_acos},
+  {"asin",  math_asin},
+  {"atan2", math_atan2},
+  {"atan",  math_atan},
+  {"ceil",  math_ceil},
+  {"cosh",   math_cosh},
+  {"cos",   math_cos},
+  {"deg",   math_deg},
+  {"exp",   math_exp},
+  {"floor", math_floor},
+  {"fmod",   math_fmod},
+  {"frexp", math_frexp},
+  {"ldexp", math_ldexp},
+#if defined(LUA_COMPAT_LOG10)
+  {"log10", math_log10},
+#endif
+  {"log",   math_log},
+  {"max",   math_max},
+  {"min",   math_min},
+  {"modf",   math_modf},
+  {"pow",   math_pow},
+  {"rad",   math_rad},
+  {"random",     math_random},
+  {"randomseed", math_randomseed},
+  {"sinh",   math_sinh},
+  {"sin",   math_sin},
+  {"sqrt",  math_sqrt},
+  {"tanh",   math_tanh},
+  {"tan",   math_tan},
+  {NULL, NULL}
+};
+
+
+/*
+** Open math library
+*/
+LUAMOD_API int luaopen_math (lua_State *L) {
+  luaL_newlib(L, mathlib);
+  lua_pushnumber(L, PI);
+  lua_setfield(L, -2, "pi");
+  lua_pushnumber(L, HUGE_VAL);
+  lua_setfield(L, -2, "huge");
+  return 1;
+}
+
diff --git a/dep/lualib/lmem.c b/dep/lualib/lmem.c
new file mode 100644
index 0000000..3f88496
--- /dev/null
+++ b/dep/lualib/lmem.c
@@ -0,0 +1,99 @@
+/*
+** $Id: lmem.c,v 1.84 2012/05/23 15:41:53 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define lmem_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+/*
+** About the realloc function:
+** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
+** (`osize' is the old size, `nsize' is the new size)
+**
+** * frealloc(ud, NULL, x, s) creates a new block of size `s' (no
+** matter 'x').
+**
+** * frealloc(ud, p, x, 0) frees the block `p'
+** (in this specific case, frealloc must return NULL);
+** particularly, frealloc(ud, NULL, 0, 0) does nothing
+** (which is equivalent to free(NULL) in ANSI C)
+**
+** frealloc returns NULL if it cannot create or reallocate the area
+** (any reallocation to an equal or smaller size cannot fail!)
+*/
+
+
+
+#define MINSIZEARRAY	4
+
+
+void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
+                     int limit, const char *what) {
+  void *newblock;
+  int newsize;
+  if (*size >= limit/2) {  /* cannot double it? */
+    if (*size >= limit)  /* cannot grow even a little? */
+      luaG_runerror(L, "too many %s (limit is %d)", what, limit);
+    newsize = limit;  /* still have at least one free place */
+  }
+  else {
+    newsize = (*size)*2;
+    if (newsize < MINSIZEARRAY)
+      newsize = MINSIZEARRAY;  /* minimum size */
+  }
+  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
+  *size = newsize;  /* update only when everything else is OK */
+  return newblock;
+}
+
+
+l_noret luaM_toobig (lua_State *L) {
+  luaG_runerror(L, "memory allocation error: block too big");
+}
+
+
+
+/*
+** generic allocation routine.
+*/
+void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
+  void *newblock;
+  global_State *g = G(L);
+  size_t realosize = (block) ? osize : 0;
+  lua_assert((realosize == 0) == (block == NULL));
+#if defined(HARDMEMTESTS)
+  if (nsize > realosize && g->gcrunning)
+    luaC_fullgc(L, 1);  /* force a GC whenever possible */
+#endif
+  newblock = (*g->frealloc)(g->ud, block, osize, nsize);
+  if (newblock == NULL && nsize > 0) {
+    api_check(L, nsize > realosize,
+                 "realloc cannot fail when shrinking a block");
+    if (g->gcrunning) {
+      luaC_fullgc(L, 1);  /* try to free some memory... */
+      newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */
+    }
+    if (newblock == NULL)
+      luaD_throw(L, LUA_ERRMEM);
+  }
+  lua_assert((nsize == 0) == (newblock == NULL));
+  g->GCdebt = (g->GCdebt + nsize) - realosize;
+  return newblock;
+}
+
diff --git a/dep/lualib/lmem.h b/dep/lualib/lmem.h
new file mode 100644
index 0000000..535dfe0
--- /dev/null
+++ b/dep/lualib/lmem.h
@@ -0,0 +1,50 @@
+/*
+** $Id: lmem.h,v 1.38 2011/12/02 13:26:54 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lmem_h
+#define lmem_h
+
+
+#include <stddef.h>
+
+#include "llimits.h"
+#include "lua.h"
+
+
+#define luaM_reallocv(L,b,on,n,e) \
+	((cast(size_t, (n)+1) > MAX_SIZET/(e)) ?  /* +1 to avoid warnings */ \
+		(luaM_toobig(L), (void *)0) : \
+		luaM_realloc_(L, (b), (on)*(e), (n)*(e)))
+
+#define luaM_freemem(L, b, s)	luaM_realloc_(L, (b), (s), 0)
+#define luaM_free(L, b)		luaM_realloc_(L, (b), sizeof(*(b)), 0)
+#define luaM_freearray(L, b, n)   luaM_reallocv(L, (b), n, 0, sizeof((b)[0]))
+
+#define luaM_malloc(L,s)	luaM_realloc_(L, NULL, 0, (s))
+#define luaM_new(L,t)		cast(t *, luaM_malloc(L, sizeof(t)))
+#define luaM_newvector(L,n,t) \
+		cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
+
+#define luaM_newobject(L,tag,s)	luaM_realloc_(L, NULL, tag, (s))
+
+#define luaM_growvector(L,v,nelems,size,t,limit,e) \
+          if ((nelems)+1 > (size)) \
+            ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
+
+#define luaM_reallocvector(L, v,oldn,n,t) \
+   ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
+
+LUAI_FUNC l_noret luaM_toobig (lua_State *L);
+
+/* not to be called directly */
+LUAI_FUNC void *luaM_realloc_ (lua_State *L, void *block, size_t oldsize,
+                                                          size_t size);
+LUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int *size,
+                               size_t size_elem, int limit,
+                               const char *what);
+
+#endif
+
diff --git a/dep/lualib/loadlib.c b/dep/lualib/loadlib.c
new file mode 100644
index 0000000..a995927
--- /dev/null
+++ b/dep/lualib/loadlib.c
@@ -0,0 +1,725 @@
+/*
+** $Id: loadlib.c,v 1.111 2012/05/30 12:33:44 roberto Exp $
+** Dynamic library loader for Lua
+** See Copyright Notice in lua.h
+**
+** This module contains an implementation of loadlib for Unix systems
+** that have dlfcn, an implementation for Windows, and a stub for other
+** systems.
+*/
+
+
+/*
+** if needed, includes windows header before everything else
+*/
+#if defined(_WIN32)
+#include <windows.h>
+#endif
+
+
+#include <stdlib.h>
+#include <string.h>
+
+
+#define loadlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** LUA_PATH and LUA_CPATH are the names of the environment
+** variables that Lua check to set its paths.
+*/
+#if !defined(LUA_PATH)
+#define LUA_PATH	"LUA_PATH"
+#endif
+
+#if !defined(LUA_CPATH)
+#define LUA_CPATH	"LUA_CPATH"
+#endif
+
+#define LUA_PATHSUFFIX		"_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+
+#define LUA_PATHVERSION		LUA_PATH LUA_PATHSUFFIX
+#define LUA_CPATHVERSION	LUA_CPATH LUA_PATHSUFFIX
+
+/*
+** LUA_PATH_SEP is the character that separates templates in a path.
+** LUA_PATH_MARK is the string that marks the substitution points in a
+** template.
+** LUA_EXEC_DIR in a Windows path is replaced by the executable's
+** directory.
+** LUA_IGMARK is a mark to ignore all before it when building the
+** luaopen_ function name.
+*/
+#if !defined (LUA_PATH_SEP)
+#define LUA_PATH_SEP		";"
+#endif
+#if !defined (LUA_PATH_MARK)
+#define LUA_PATH_MARK		"?"
+#endif
+#if !defined (LUA_EXEC_DIR)
+#define LUA_EXEC_DIR		"!"
+#endif
+#if !defined (LUA_IGMARK)
+#define LUA_IGMARK		"-"
+#endif
+
+
+/*
+** LUA_CSUBSEP is the character that replaces dots in submodule names
+** when searching for a C loader.
+** LUA_LSUBSEP is the character that replaces dots in submodule names
+** when searching for a Lua loader.
+*/
+#if !defined(LUA_CSUBSEP)
+#define LUA_CSUBSEP		LUA_DIRSEP
+#endif
+
+#if !defined(LUA_LSUBSEP)
+#define LUA_LSUBSEP		LUA_DIRSEP
+#endif
+
+
+/* prefix for open functions in C libraries */
+#define LUA_POF		"luaopen_"
+
+/* separator for open functions in C libraries */
+#define LUA_OFSEP	"_"
+
+
+/* table (in the registry) that keeps handles for all loaded C libraries */
+#define CLIBS		"_CLIBS"
+
+#define LIB_FAIL	"open"
+
+
+/* error codes for ll_loadfunc */
+#define ERRLIB		1
+#define ERRFUNC		2
+
+#define setprogdir(L)		((void)0)
+
+
+/*
+** system-dependent functions
+*/
+static void ll_unloadlib (void *lib);
+static void *ll_load (lua_State *L, const char *path, int seeglb);
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);
+
+
+
+#if defined(LUA_USE_DLOPEN)
+/*
+** {========================================================================
+** This is an implementation of loadlib based on the dlfcn interface.
+** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
+** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
+** as an emulation layer on top of native functions.
+** =========================================================================
+*/
+
+#include <dlfcn.h>
+
+static void ll_unloadlib (void *lib) {
+  dlclose(lib);
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));
+  if (lib == NULL) lua_pushstring(L, dlerror());
+  return lib;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);
+  if (f == NULL) lua_pushstring(L, dlerror());
+  return f;
+}
+
+/* }====================================================== */
+
+
+
+#elif defined(LUA_DL_DLL)
+/*
+** {======================================================================
+** This is an implementation of loadlib for Windows using native functions.
+** =======================================================================
+*/
+
+#undef setprogdir
+
+/*
+** optional flags for LoadLibraryEx
+*/
+#if !defined(LUA_LLE_FLAGS)
+#define LUA_LLE_FLAGS	0
+#endif
+
+
+static void setprogdir (lua_State *L) {
+  char buff[MAX_PATH + 1];
+  char *lb;
+  DWORD nsize = sizeof(buff)/sizeof(char);
+  DWORD n = GetModuleFileNameA(NULL, buff, nsize);
+  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\')) == NULL)
+    luaL_error(L, "unable to get ModuleFileName");
+  else {
+    *lb = '\0';
+    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);
+    lua_remove(L, -2);  /* remove original string */
+  }
+}
+
+
+static void pusherror (lua_State *L) {
+  int error = GetLastError();
+  char buffer[128];
+  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
+      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))
+    lua_pushstring(L, buffer);
+  else
+    lua_pushfstring(L, "system error %d\n", error);
+}
+
+static void ll_unloadlib (void *lib) {
+  FreeLibrary((HMODULE)lib);
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);
+  (void)(seeglb);  /* not used: symbols are 'global' by default */
+  if (lib == NULL) pusherror(L);
+  return lib;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);
+  if (f == NULL) pusherror(L);
+  return f;
+}
+
+/* }====================================================== */
+
+
+#else
+/*
+** {======================================================
+** Fallback for other systems
+** =======================================================
+*/
+
+#undef LIB_FAIL
+#define LIB_FAIL	"absent"
+
+
+#define DLMSG	"dynamic libraries not enabled; check your Lua installation"
+
+
+static void ll_unloadlib (void *lib) {
+  (void)(lib);  /* not used */
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  (void)(path); (void)(seeglb);  /* not used */
+  lua_pushliteral(L, DLMSG);
+  return NULL;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  (void)(lib); (void)(sym);  /* not used */
+  lua_pushliteral(L, DLMSG);
+  return NULL;
+}
+
+/* }====================================================== */
+#endif
+
+
+static void *ll_checkclib (lua_State *L, const char *path) {
+  void *plib;
+  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_getfield(L, -1, path);
+  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */
+  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */
+  return plib;
+}
+
+
+static void ll_addtoclib (lua_State *L, const char *path, void *plib) {
+  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_pushlightuserdata(L, plib);
+  lua_pushvalue(L, -1);
+  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */
+  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */
+  lua_pop(L, 1);  /* pop CLIBS table */
+}
+
+
+/*
+** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib
+** handles in list CLIBS
+*/
+static int gctm (lua_State *L) {
+  int n = luaL_len(L, 1);
+  for (; n >= 1; n--) {  /* for each handle, in reverse order */
+    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */
+    ll_unloadlib(lua_touserdata(L, -1));
+    lua_pop(L, 1);  /* pop handle */
+  }
+  return 0;
+}
+
+
+static int ll_loadfunc (lua_State *L, const char *path, const char *sym) {
+  void *reg = ll_checkclib(L, path);  /* check loaded C libraries */
+  if (reg == NULL) {  /* must load library? */
+    reg = ll_load(L, path, *sym == '*');
+    if (reg == NULL) return ERRLIB;  /* unable to load library */
+    ll_addtoclib(L, path, reg);
+  }
+  if (*sym == '*') {  /* loading only library (no function)? */
+    lua_pushboolean(L, 1);  /* return 'true' */
+    return 0;  /* no errors */
+  }
+  else {
+    lua_CFunction f = ll_sym(L, reg, sym);
+    if (f == NULL)
+      return ERRFUNC;  /* unable to find function */
+    lua_pushcfunction(L, f);  /* else create new function */
+    return 0;  /* no errors */
+  }
+}
+
+
+static int ll_loadlib (lua_State *L) {
+  const char *path = luaL_checkstring(L, 1);
+  const char *init = luaL_checkstring(L, 2);
+  int stat = ll_loadfunc(L, path, init);
+  if (stat == 0)  /* no errors? */
+    return 1;  /* return the loaded function */
+  else {  /* error; error message is on stack top */
+    lua_pushnil(L);
+    lua_insert(L, -2);
+    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : "init");
+    return 3;  /* return nil, error message, and where */
+  }
+}
+
+
+
+/*
+** {======================================================
+** 'require' function
+** =======================================================
+*/
+
+
+static int readable (const char *filename) {
+  FILE *f = fopen(filename, "r");  /* try to open file */
+  if (f == NULL) return 0;  /* open failed */
+  fclose(f);
+  return 1;
+}
+
+
+static const char *pushnexttemplate (lua_State *L, const char *path) {
+  const char *l;
+  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */
+  if (*path == '\0') return NULL;  /* no more templates */
+  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */
+  if (l == NULL) l = path + strlen(path);
+  lua_pushlstring(L, path, l - path);  /* template */
+  return l;
+}
+
+
+static const char *searchpath (lua_State *L, const char *name,
+                                             const char *path,
+                                             const char *sep,
+                                             const char *dirsep) {
+  luaL_Buffer msg;  /* to build error message */
+  luaL_buffinit(L, &msg);
+  if (*sep != '\0')  /* non-empty separator? */
+    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */
+  while ((path = pushnexttemplate(L, path)) != NULL) {
+    const char *filename = luaL_gsub(L, lua_tostring(L, -1),
+                                     LUA_PATH_MARK, name);
+    lua_remove(L, -2);  /* remove path template */
+    if (readable(filename))  /* does file exist and is readable? */
+      return filename;  /* return that file name */
+    lua_pushfstring(L, "\n\tno file " LUA_QS, filename);
+    lua_remove(L, -2);  /* remove file name */
+    luaL_addvalue(&msg);  /* concatenate error msg. entry */
+  }
+  luaL_pushresult(&msg);  /* create error message */
+  return NULL;  /* not found */
+}
+
+
+static int ll_searchpath (lua_State *L) {
+  const char *f = searchpath(L, luaL_checkstring(L, 1),
+                                luaL_checkstring(L, 2),
+                                luaL_optstring(L, 3, "."),
+                                luaL_optstring(L, 4, LUA_DIRSEP));
+  if (f != NULL) return 1;
+  else {  /* error message is on top of the stack */
+    lua_pushnil(L);
+    lua_insert(L, -2);
+    return 2;  /* return nil + error message */
+  }
+}
+
+
+static const char *findfile (lua_State *L, const char *name,
+                                           const char *pname,
+                                           const char *dirsep) {
+  const char *path;
+  lua_getfield(L, lua_upvalueindex(1), pname);
+  path = lua_tostring(L, -1);
+  if (path == NULL)
+    luaL_error(L, LUA_QL("package.%s") " must be a string", pname);
+  return searchpath(L, name, path, ".", dirsep);
+}
+
+
+static int checkload (lua_State *L, int stat, const char *filename) {
+  if (stat) {  /* module loaded successfully? */
+    lua_pushstring(L, filename);  /* will be 2nd argument to module */
+    return 2;  /* return open function and file name */
+  }
+  else
+    return luaL_error(L, "error loading module " LUA_QS
+                         " from file " LUA_QS ":\n\t%s",
+                          lua_tostring(L, 1), filename, lua_tostring(L, -1));
+}
+
+
+static int searcher_Lua (lua_State *L) {
+  const char *filename;
+  const char *name = luaL_checkstring(L, 1);
+  filename = findfile(L, name, "path", LUA_LSUBSEP);
+  if (filename == NULL) return 1;  /* module not found in this path */
+  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);
+}
+
+
+static int loadfunc (lua_State *L, const char *filename, const char *modname) {
+  const char *funcname;
+  const char *mark;
+  modname = luaL_gsub(L, modname, ".", LUA_OFSEP);
+  mark = strchr(modname, *LUA_IGMARK);
+  if (mark) {
+    int stat;
+    funcname = lua_pushlstring(L, modname, mark - modname);
+    funcname = lua_pushfstring(L, LUA_POF"%s", funcname);
+    stat = ll_loadfunc(L, filename, funcname);
+    if (stat != ERRFUNC) return stat;
+    modname = mark + 1;  /* else go ahead and try old-style name */
+  }
+  funcname = lua_pushfstring(L, LUA_POF"%s", modname);
+  return ll_loadfunc(L, filename, funcname);
+}
+
+
+static int searcher_C (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  const char *filename = findfile(L, name, "cpath", LUA_CSUBSEP);
+  if (filename == NULL) return 1;  /* module not found in this path */
+  return checkload(L, (loadfunc(L, filename, name) == 0), filename);
+}
+
+
+static int searcher_Croot (lua_State *L) {
+  const char *filename;
+  const char *name = luaL_checkstring(L, 1);
+  const char *p = strchr(name, '.');
+  int stat;
+  if (p == NULL) return 0;  /* is root */
+  lua_pushlstring(L, name, p - name);
+  filename = findfile(L, lua_tostring(L, -1), "cpath", LUA_CSUBSEP);
+  if (filename == NULL) return 1;  /* root not found */
+  if ((stat = loadfunc(L, filename, name)) != 0) {
+    if (stat != ERRFUNC)
+      return checkload(L, 0, filename);  /* real error */
+    else {  /* open function not found */
+      lua_pushfstring(L, "\n\tno module " LUA_QS " in file " LUA_QS,
+                         name, filename);
+      return 1;
+    }
+  }
+  lua_pushstring(L, filename);  /* will be 2nd argument to module */
+  return 2;
+}
+
+
+static int searcher_preload (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  lua_getfield(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  lua_getfield(L, -1, name);
+  if (lua_isnil(L, -1))  /* not found? */
+    lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
+  return 1;
+}
+
+
+static void findloader (lua_State *L, const char *name) {
+  int i;
+  luaL_Buffer msg;  /* to build error message */
+  luaL_buffinit(L, &msg);
+  lua_getfield(L, lua_upvalueindex(1), "searchers");  /* will be at index 3 */
+  if (!lua_istable(L, 3))
+    luaL_error(L, LUA_QL("package.searchers") " must be a table");
+  /*  iterate over available searchers to find a loader */
+  for (i = 1; ; i++) {
+    lua_rawgeti(L, 3, i);  /* get a searcher */
+    if (lua_isnil(L, -1)) {  /* no more searchers? */
+      lua_pop(L, 1);  /* remove nil */
+      luaL_pushresult(&msg);  /* create error message */
+      luaL_error(L, "module " LUA_QS " not found:%s",
+                    name, lua_tostring(L, -1));
+    }
+    lua_pushstring(L, name);
+    lua_call(L, 1, 2);  /* call it */
+    if (lua_isfunction(L, -2))  /* did it find a loader? */
+      return;  /* module loader found */
+    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */
+      lua_pop(L, 1);  /* remove extra return */
+      luaL_addvalue(&msg);  /* concatenate error message */
+    }
+    else
+      lua_pop(L, 2);  /* remove both returns */
+  }
+}
+
+
+static int ll_require (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  lua_settop(L, 1);  /* _LOADED table will be at index 2 */
+  lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_getfield(L, 2, name);  /* _LOADED[name] */
+  if (lua_toboolean(L, -1))  /* is it there? */
+    return 1;  /* package is already loaded */
+  /* else must load package */
+  lua_pop(L, 1);  /* remove 'getfield' result */
+  findloader(L, name);
+  lua_pushstring(L, name);  /* pass name as argument to module loader */
+  lua_insert(L, -2);  /* name is 1st argument (before search data) */
+  lua_call(L, 2, 1);  /* run loader to load module */
+  if (!lua_isnil(L, -1))  /* non-nil return? */
+    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */
+  lua_getfield(L, 2, name);
+  if (lua_isnil(L, -1)) {   /* module did not set a value? */
+    lua_pushboolean(L, 1);  /* use true as result */
+    lua_pushvalue(L, -1);  /* extra copy to be returned */
+    lua_setfield(L, 2, name);  /* _LOADED[name] = true */
+  }
+  return 1;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** 'module' function
+** =======================================================
+*/
+#if defined(LUA_COMPAT_MODULE)
+
+/*
+** changes the environment variable of calling function
+*/
+static void set_env (lua_State *L) {
+  lua_Debug ar;
+  if (lua_getstack(L, 1, &ar) == 0 ||
+      lua_getinfo(L, "f", &ar) == 0 ||  /* get calling function */
+      lua_iscfunction(L, -1))
+    luaL_error(L, LUA_QL("module") " not called from a Lua function");
+  lua_pushvalue(L, -2);  /* copy new environment table to top */
+  lua_setupvalue(L, -2, 1);
+  lua_pop(L, 1);  /* remove function */
+}
+
+
+static void dooptions (lua_State *L, int n) {
+  int i;
+  for (i = 2; i <= n; i++) {
+    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */
+      lua_pushvalue(L, i);  /* get option (a function) */
+      lua_pushvalue(L, -2);  /* module */
+      lua_call(L, 1, 0);
+    }
+  }
+}
+
+
+static void modinit (lua_State *L, const char *modname) {
+  const char *dot;
+  lua_pushvalue(L, -1);
+  lua_setfield(L, -2, "_M");  /* module._M = module */
+  lua_pushstring(L, modname);
+  lua_setfield(L, -2, "_NAME");
+  dot = strrchr(modname, '.');  /* look for last dot in module name */
+  if (dot == NULL) dot = modname;
+  else dot++;
+  /* set _PACKAGE as package name (full module name minus last part) */
+  lua_pushlstring(L, modname, dot - modname);
+  lua_setfield(L, -2, "_PACKAGE");
+}
+
+
+static int ll_module (lua_State *L) {
+  const char *modname = luaL_checkstring(L, 1);
+  int lastarg = lua_gettop(L);  /* last parameter */
+  luaL_pushmodule(L, modname, 1);  /* get/create module table */
+  /* check whether table already has a _NAME field */
+  lua_getfield(L, -1, "_NAME");
+  if (!lua_isnil(L, -1))  /* is table an initialized module? */
+    lua_pop(L, 1);
+  else {  /* no; initialize it */
+    lua_pop(L, 1);
+    modinit(L, modname);
+  }
+  lua_pushvalue(L, -1);
+  set_env(L);
+  dooptions(L, lastarg);
+  return 1;
+}
+
+
+static int ll_seeall (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (!lua_getmetatable(L, 1)) {
+    lua_createtable(L, 0, 1); /* create new metatable */
+    lua_pushvalue(L, -1);
+    lua_setmetatable(L, 1);
+  }
+  lua_pushglobaltable(L);
+  lua_setfield(L, -2, "__index");  /* mt.__index = _G */
+  return 0;
+}
+
+#endif
+/* }====================================================== */
+
+
+
+/* auxiliary mark (for internal use) */
+#define AUXMARK		"\1"
+
+
+/*
+** return registry.LUA_NOENV as a boolean
+*/
+static int noenv (lua_State *L) {
+  int b;
+  lua_getfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
+  b = lua_toboolean(L, -1);
+  lua_pop(L, 1);  /* remove value */
+  return b;
+}
+
+
+static void setpath (lua_State *L, const char *fieldname, const char *envname1,
+                                   const char *envname2, const char *def) {
+  const char *path = getenv(envname1);
+  if (path == NULL)  /* no environment variable? */
+    path = getenv(envname2);  /* try alternative name */
+  if (path == NULL || noenv(L))  /* no environment variable? */
+    lua_pushstring(L, def);  /* use default */
+  else {
+    /* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
+    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,
+                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);
+    luaL_gsub(L, path, AUXMARK, def);
+    lua_remove(L, -2);
+  }
+  setprogdir(L);
+  lua_setfield(L, -2, fieldname);
+}
+
+
+static const luaL_Reg pk_funcs[] = {
+  {"loadlib", ll_loadlib},
+  {"searchpath", ll_searchpath},
+#if defined(LUA_COMPAT_MODULE)
+  {"seeall", ll_seeall},
+#endif
+  {NULL, NULL}
+};
+
+
+static const luaL_Reg ll_funcs[] = {
+#if defined(LUA_COMPAT_MODULE)
+  {"module", ll_module},
+#endif
+  {"require", ll_require},
+  {NULL, NULL}
+};
+
+
+static void createsearcherstable (lua_State *L) {
+  static const lua_CFunction searchers[] =
+    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};
+  int i;
+  /* create 'searchers' table */
+  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);
+  /* fill it with pre-defined searchers */
+  for (i=0; searchers[i] != NULL; i++) {
+    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */
+    lua_pushcclosure(L, searchers[i], 1);
+    lua_rawseti(L, -2, i+1);
+  }
+}
+
+
+LUAMOD_API int luaopen_package (lua_State *L) {
+  /* create table CLIBS to keep track of loaded C libraries */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_createtable(L, 0, 1);  /* metatable for CLIBS */
+  lua_pushcfunction(L, gctm);
+  lua_setfield(L, -2, "__gc");  /* set finalizer for CLIBS table */
+  lua_setmetatable(L, -2);
+  /* create `package' table */
+  luaL_newlib(L, pk_funcs);
+  createsearcherstable(L);
+#if defined(LUA_COMPAT_LOADERS)
+  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */
+  lua_setfield(L, -3, "loaders");  /* put it in field `loaders' */
+#endif
+  lua_setfield(L, -2, "searchers");  /* put it in field 'searchers' */
+  /* set field 'path' */
+  setpath(L, "path", LUA_PATHVERSION, LUA_PATH, LUA_PATH_DEFAULT);
+  /* set field 'cpath' */
+  setpath(L, "cpath", LUA_CPATHVERSION, LUA_CPATH, LUA_CPATH_DEFAULT);
+  /* store config information */
+  lua_pushliteral(L, LUA_DIRSEP "\n" LUA_PATH_SEP "\n" LUA_PATH_MARK "\n"
+                     LUA_EXEC_DIR "\n" LUA_IGMARK "\n");
+  lua_setfield(L, -2, "config");
+  /* set field `loaded' */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_setfield(L, -2, "loaded");
+  /* set field `preload' */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  lua_setfield(L, -2, "preload");
+  lua_pushglobaltable(L);
+  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */
+  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */
+  lua_pop(L, 1);  /* pop global table */
+  return 1;  /* return 'package' table */
+}
+
diff --git a/dep/lualib/lobject.c b/dep/lualib/lobject.c
new file mode 100644
index 0000000..cf0f754
--- /dev/null
+++ b/dep/lualib/lobject.c
@@ -0,0 +1,289 @@
+/*
+** $Id: lobject.c,v 2.55 2011/11/30 19:30:16 roberto Exp $
+** Some generic functions over Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lobject_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lctype.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "lvm.h"
+
+
+
+LUAI_DDEF const TValue luaO_nilobject_ = {NILCONSTANT};
+
+
+/*
+** converts an integer to a "floating point byte", represented as
+** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
+** eeeee != 0 and (xxx) otherwise.
+*/
+int luaO_int2fb (unsigned int x) {
+  int e = 0;  /* exponent */
+  if (x < 8) return x;
+  while (x >= 0x10) {
+    x = (x+1) >> 1;
+    e++;
+  }
+  return ((e+1) << 3) | (cast_int(x) - 8);
+}
+
+
+/* converts back */
+int luaO_fb2int (int x) {
+  int e = (x >> 3) & 0x1f;
+  if (e == 0) return x;
+  else return ((x & 7) + 8) << (e - 1);
+}
+
+
+int luaO_ceillog2 (unsigned int x) {
+  static const lu_byte log_2[256] = {
+    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
+  };
+  int l = 0;
+  x--;
+  while (x >= 256) { l += 8; x >>= 8; }
+  return l + log_2[x];
+}
+
+
+lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2) {
+  switch (op) {
+    case LUA_OPADD: return luai_numadd(NULL, v1, v2);
+    case LUA_OPSUB: return luai_numsub(NULL, v1, v2);
+    case LUA_OPMUL: return luai_nummul(NULL, v1, v2);
+    case LUA_OPDIV: return luai_numdiv(NULL, v1, v2);
+    case LUA_OPMOD: return luai_nummod(NULL, v1, v2);
+    case LUA_OPPOW: return luai_numpow(NULL, v1, v2);
+    case LUA_OPUNM: return luai_numunm(NULL, v1);
+    default: lua_assert(0); return 0;
+  }
+}
+
+
+int luaO_hexavalue (int c) {
+  if (lisdigit(c)) return c - '0';
+  else return ltolower(c) - 'a' + 10;
+}
+
+
+#if !defined(lua_strx2number)
+
+#include <math.h>
+
+
+static int isneg (const char **s) {
+  if (**s == '-') { (*s)++; return 1; }
+  else if (**s == '+') (*s)++;
+  return 0;
+}
+
+
+static lua_Number readhexa (const char **s, lua_Number r, int *count) {
+  for (; lisxdigit(cast_uchar(**s)); (*s)++) {  /* read integer part */
+    r = (r * 16.0) + cast_num(luaO_hexavalue(cast_uchar(**s)));
+    (*count)++;
+  }
+  return r;
+}
+
+
+/*
+** convert an hexadecimal numeric string to a number, following
+** C99 specification for 'strtod'
+*/
+static lua_Number lua_strx2number (const char *s, char **endptr) {
+  lua_Number r = 0.0;
+  int e = 0, i = 0;
+  int neg = 0;  /* 1 if number is negative */
+  *endptr = cast(char *, s);  /* nothing is valid yet */
+  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
+  neg = isneg(&s);  /* check signal */
+  if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */
+    return 0.0;  /* invalid format (no '0x') */
+  s += 2;  /* skip '0x' */
+  r = readhexa(&s, r, &i);  /* read integer part */
+  if (*s == '.') {
+    s++;  /* skip dot */
+    r = readhexa(&s, r, &e);  /* read fractional part */
+  }
+  if (i == 0 && e == 0)
+    return 0.0;  /* invalid format (no digit) */
+  e *= -4;  /* each fractional digit divides value by 2^-4 */
+  *endptr = cast(char *, s);  /* valid up to here */
+  if (*s == 'p' || *s == 'P') {  /* exponent part? */
+    int exp1 = 0;
+    int neg1;
+    s++;  /* skip 'p' */
+    neg1 = isneg(&s);  /* signal */
+    if (!lisdigit(cast_uchar(*s)))
+      goto ret;  /* must have at least one digit */
+    while (lisdigit(cast_uchar(*s)))  /* read exponent */
+      exp1 = exp1 * 10 + *(s++) - '0';
+    if (neg1) exp1 = -exp1;
+    e += exp1;
+  }
+  *endptr = cast(char *, s);  /* valid up to here */
+ ret:
+  if (neg) r = -r;
+  return ldexp(r, e);
+}
+
+#endif
+
+
+int luaO_str2d (const char *s, size_t len, lua_Number *result) {
+  char *endptr;
+  if (strpbrk(s, "nN"))  /* reject 'inf' and 'nan' */
+    return 0;
+  else if (strpbrk(s, "xX"))  /* hexa? */
+    *result = lua_strx2number(s, &endptr);
+  else
+    *result = lua_str2number(s, &endptr);
+  if (endptr == s) return 0;  /* nothing recognized */
+  while (lisspace(cast_uchar(*endptr))) endptr++;
+  return (endptr == s + len);  /* OK if no trailing characters */
+}
+
+
+
+static void pushstr (lua_State *L, const char *str, size_t l) {
+  setsvalue2s(L, L->top, luaS_newlstr(L, str, l));
+  incr_top(L);
+}
+
+
+/* this function handles only `%d', `%c', %f, %p, and `%s' formats */
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
+  int n = 0;
+  for (;;) {
+    const char *e = strchr(fmt, '%');
+    if (e == NULL) break;
+    setsvalue2s(L, L->top, luaS_newlstr(L, fmt, e-fmt));
+    incr_top(L);
+    switch (*(e+1)) {
+      case 's': {
+        const char *s = va_arg(argp, char *);
+        if (s == NULL) s = "(null)";
+        pushstr(L, s, strlen(s));
+        break;
+      }
+      case 'c': {
+        char buff;
+        buff = cast(char, va_arg(argp, int));
+        pushstr(L, &buff, 1);
+        break;
+      }
+      case 'd': {
+        setnvalue(L->top, cast_num(va_arg(argp, int)));
+        incr_top(L);
+        break;
+      }
+      case 'f': {
+        setnvalue(L->top, cast_num(va_arg(argp, l_uacNumber)));
+        incr_top(L);
+        break;
+      }
+      case 'p': {
+        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */
+        int l = sprintf(buff, "%p", va_arg(argp, void *));
+        pushstr(L, buff, l);
+        break;
+      }
+      case '%': {
+        pushstr(L, "%", 1);
+        break;
+      }
+      default: {
+        luaG_runerror(L,
+            "invalid option " LUA_QL("%%%c") " to " LUA_QL("lua_pushfstring"),
+            *(e + 1));
+      }
+    }
+    n += 2;
+    fmt = e+2;
+  }
+  pushstr(L, fmt, strlen(fmt));
+  if (n > 0) luaV_concat(L, n + 1);
+  return svalue(L->top - 1);
+}
+
+
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *msg;
+  va_list argp;
+  va_start(argp, fmt);
+  msg = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  return msg;
+}
+
+
+/* number of chars of a literal string without the ending \0 */
+#define LL(x)	(sizeof(x)/sizeof(char) - 1)
+
+#define RETS	"..."
+#define PRE	"[string \""
+#define POS	"\"]"
+
+#define addstr(a,b,l)	( memcpy(a,b,(l) * sizeof(char)), a += (l) )
+
+void luaO_chunkid (char *out, const char *source, size_t bufflen) {
+  size_t l = strlen(source);
+  if (*source == '=') {  /* 'literal' source */
+    if (l <= bufflen)  /* small enough? */
+      memcpy(out, source + 1, l * sizeof(char));
+    else {  /* truncate it */
+      addstr(out, source + 1, bufflen - 1);
+      *out = '\0';
+    }
+  }
+  else if (*source == '@') {  /* file name */
+    if (l <= bufflen)  /* small enough? */
+      memcpy(out, source + 1, l * sizeof(char));
+    else {  /* add '...' before rest of name */
+      addstr(out, RETS, LL(RETS));
+      bufflen -= LL(RETS);
+      memcpy(out, source + 1 + l - bufflen, bufflen * sizeof(char));
+    }
+  }
+  else {  /* string; format as [string "source"] */
+    const char *nl = strchr(source, '\n');  /* find first new line (if any) */
+    addstr(out, PRE, LL(PRE));  /* add prefix */
+    bufflen -= LL(PRE RETS POS) + 1;  /* save space for prefix+suffix+'\0' */
+    if (l < bufflen && nl == NULL) {  /* small one-line source? */
+      addstr(out, source, l);  /* keep it */
+    }
+    else {
+      if (nl != NULL) l = nl - source;  /* stop at first newline */
+      if (l > bufflen) l = bufflen;
+      addstr(out, source, l);
+      addstr(out, RETS, LL(RETS));
+    }
+    memcpy(out, POS, (LL(POS) + 1) * sizeof(char));
+  }
+}
+
diff --git a/dep/lualib/lobject.h b/dep/lualib/lobject.h
new file mode 100644
index 0000000..ca75a02
--- /dev/null
+++ b/dep/lualib/lobject.h
@@ -0,0 +1,610 @@
+/*
+** $Id: lobject.h,v 2.70 2012/05/11 14:10:50 roberto Exp $
+** Type definitions for Lua objects
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lobject_h
+#define lobject_h
+
+
+#include <stdarg.h>
+
+
+#include "llimits.h"
+#include "lua.h"
+
+
+/*
+** Extra tags for non-values
+*/
+#define LUA_TPROTO	LUA_NUMTAGS
+#define LUA_TUPVAL	(LUA_NUMTAGS+1)
+#define LUA_TDEADKEY	(LUA_NUMTAGS+2)
+
+/*
+** number of all possible tags (including LUA_TNONE but excluding DEADKEY)
+*/
+#define LUA_TOTALTAGS	(LUA_TUPVAL+2)
+
+
+/*
+** tags for Tagged Values have the following use of bits:
+** bits 0-3: actual tag (a LUA_T* value)
+** bits 4-5: variant bits
+** bit 6: whether value is collectable
+*/
+
+#define VARBITS		(3 << 4)
+
+
+/*
+** LUA_TFUNCTION variants:
+** 0 - Lua function
+** 1 - light C function
+** 2 - regular C function (closure)
+*/
+
+/* Variant tags for functions */
+#define LUA_TLCL	(LUA_TFUNCTION | (0 << 4))  /* Lua closure */
+#define LUA_TLCF	(LUA_TFUNCTION | (1 << 4))  /* light C function */
+#define LUA_TCCL	(LUA_TFUNCTION | (2 << 4))  /* C closure */
+
+
+/*
+** LUA_TSTRING variants */
+#define LUA_TSHRSTR	(LUA_TSTRING | (0 << 4))  /* short strings */
+#define LUA_TLNGSTR	(LUA_TSTRING | (1 << 4))  /* long strings */
+
+
+/* Bit mark for collectable types */
+#define BIT_ISCOLLECTABLE	(1 << 6)
+
+/* mark a tag as collectable */
+#define ctb(t)			((t) | BIT_ISCOLLECTABLE)
+
+
+/*
+** Union of all collectable objects
+*/
+typedef union GCObject GCObject;
+
+
+/*
+** Common Header for all collectable objects (in macro form, to be
+** included in other objects)
+*/
+#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
+
+
+/*
+** Common header in struct form
+*/
+typedef struct GCheader {
+  CommonHeader;
+} GCheader;
+
+
+
+/*
+** Union of all Lua values
+*/
+typedef union Value Value;
+
+
+#define numfield	lua_Number n;    /* numbers */
+
+
+
+/*
+** Tagged Values. This is the basic representation of values in Lua,
+** an actual value plus a tag with its type.
+*/
+
+#define TValuefields	Value value_; int tt_
+
+typedef struct lua_TValue TValue;
+
+
+/* macro defining a nil value */
+#define NILCONSTANT	{NULL}, LUA_TNIL
+
+
+#define val_(o)		((o)->value_)
+#define num_(o)		(val_(o).n)
+
+
+/* raw type tag of a TValue */
+#define rttype(o)	((o)->tt_)
+
+/* tag with no variants (bits 0-3) */
+#define novariant(x)	((x) & 0x0F)
+
+/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */
+#define ttype(o)	(rttype(o) & 0x3F)
+
+/* type tag of a TValue with no variants (bits 0-3) */
+#define ttypenv(o)	(novariant(rttype(o)))
+
+
+/* Macros to test type */
+#define checktag(o,t)		(rttype(o) == (t))
+#define checktype(o,t)		(ttypenv(o) == (t))
+#define ttisnumber(o)		checktag((o), LUA_TNUMBER)
+#define ttisnil(o)		checktag((o), LUA_TNIL)
+#define ttisboolean(o)		checktag((o), LUA_TBOOLEAN)
+#define ttislightuserdata(o)	checktag((o), LUA_TLIGHTUSERDATA)
+#define ttisstring(o)		checktype((o), LUA_TSTRING)
+#define ttisshrstring(o)	checktag((o), ctb(LUA_TSHRSTR))
+#define ttislngstring(o)	checktag((o), ctb(LUA_TLNGSTR))
+#define ttistable(o)		checktag((o), ctb(LUA_TTABLE))
+#define ttisfunction(o)		checktype(o, LUA_TFUNCTION)
+#define ttisclosure(o)		((rttype(o) & 0x1F) == LUA_TFUNCTION)
+#define ttisCclosure(o)		checktag((o), ctb(LUA_TCCL))
+#define ttisLclosure(o)		checktag((o), ctb(LUA_TLCL))
+#define ttislcf(o)		checktag((o), LUA_TLCF)
+#define ttisuserdata(o)		checktag((o), ctb(LUA_TUSERDATA))
+#define ttisthread(o)		checktag((o), ctb(LUA_TTHREAD))
+#define ttisdeadkey(o)		checktag((o), LUA_TDEADKEY)
+
+#define ttisequal(o1,o2)	(rttype(o1) == rttype(o2))
+
+/* Macros to access values */
+#define nvalue(o)	check_exp(ttisnumber(o), num_(o))
+#define gcvalue(o)	check_exp(iscollectable(o), val_(o).gc)
+#define pvalue(o)	check_exp(ttislightuserdata(o), val_(o).p)
+#define rawtsvalue(o)	check_exp(ttisstring(o), &val_(o).gc->ts)
+#define tsvalue(o)	(&rawtsvalue(o)->tsv)
+#define rawuvalue(o)	check_exp(ttisuserdata(o), &val_(o).gc->u)
+#define uvalue(o)	(&rawuvalue(o)->uv)
+#define clvalue(o)	check_exp(ttisclosure(o), &val_(o).gc->cl)
+#define clLvalue(o)	check_exp(ttisLclosure(o), &val_(o).gc->cl.l)
+#define clCvalue(o)	check_exp(ttisCclosure(o), &val_(o).gc->cl.c)
+#define fvalue(o)	check_exp(ttislcf(o), val_(o).f)
+#define hvalue(o)	check_exp(ttistable(o), &val_(o).gc->h)
+#define bvalue(o)	check_exp(ttisboolean(o), val_(o).b)
+#define thvalue(o)	check_exp(ttisthread(o), &val_(o).gc->th)
+/* a dead value may get the 'gc' field, but cannot access its contents */
+#define deadvalue(o)	check_exp(ttisdeadkey(o), cast(void *, val_(o).gc))
+
+#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
+
+
+#define iscollectable(o)	(rttype(o) & BIT_ISCOLLECTABLE)
+
+
+/* Macros for internal tests */
+#define righttt(obj)		(ttype(obj) == gcvalue(obj)->gch.tt)
+
+#define checkliveness(g,obj) \
+	lua_longassert(!iscollectable(obj) || \
+			(righttt(obj) && !isdead(g,gcvalue(obj))))
+
+
+/* Macros to set values */
+#define settt_(o,t)	((o)->tt_=(t))
+
+#define setnvalue(obj,x) \
+  { TValue *io=(obj); num_(io)=(x); settt_(io, LUA_TNUMBER); }
+
+#define changenvalue(o,x)	check_exp(ttisnumber(o), num_(o)=(x))
+
+#define setnilvalue(obj) settt_(obj, LUA_TNIL)
+
+#define setfvalue(obj,x) \
+  { TValue *io=(obj); val_(io).f=(x); settt_(io, LUA_TLCF); }
+
+#define setpvalue(obj,x) \
+  { TValue *io=(obj); val_(io).p=(x); settt_(io, LUA_TLIGHTUSERDATA); }
+
+#define setbvalue(obj,x) \
+  { TValue *io=(obj); val_(io).b=(x); settt_(io, LUA_TBOOLEAN); }
+
+#define setgcovalue(L,obj,x) \
+  { TValue *io=(obj); GCObject *i_g=(x); \
+    val_(io).gc=i_g; settt_(io, ctb(gch(i_g)->tt)); }
+
+#define setsvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    TString *x_ = (x); \
+    val_(io).gc=cast(GCObject *, x_); settt_(io, ctb(x_->tsv.tt)); \
+    checkliveness(G(L),io); }
+
+#define setuvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TUSERDATA)); \
+    checkliveness(G(L),io); }
+
+#define setthvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTHREAD)); \
+    checkliveness(G(L),io); }
+
+#define setclLvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TLCL)); \
+    checkliveness(G(L),io); }
+
+#define setclCvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TCCL)); \
+    checkliveness(G(L),io); }
+
+#define sethvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTABLE)); \
+    checkliveness(G(L),io); }
+
+#define setdeadvalue(obj)	settt_(obj, LUA_TDEADKEY)
+
+
+
+#define setobj(L,obj1,obj2) \
+	{ const TValue *io2=(obj2); TValue *io1=(obj1); \
+	  io1->value_ = io2->value_; io1->tt_ = io2->tt_; \
+	  checkliveness(G(L),io1); }
+
+
+/*
+** different types of assignments, according to destination
+*/
+
+/* from stack to (same) stack */
+#define setobjs2s	setobj
+/* to stack (not from same stack) */
+#define setobj2s	setobj
+#define setsvalue2s	setsvalue
+#define sethvalue2s	sethvalue
+#define setptvalue2s	setptvalue
+/* from table to same table */
+#define setobjt2t	setobj
+/* to table */
+#define setobj2t	setobj
+/* to new object */
+#define setobj2n	setobj
+#define setsvalue2n	setsvalue
+
+
+/* check whether a number is valid (useful only for NaN trick) */
+#define luai_checknum(L,o,c)	{ /* empty */ }
+
+
+/*
+** {======================================================
+** NaN Trick
+** =======================================================
+*/
+#if defined(LUA_NANTRICK)
+
+/*
+** numbers are represented in the 'd_' field. All other values have the
+** value (NNMARK | tag) in 'tt__'. A number with such pattern would be
+** a "signaled NaN", which is never generated by regular operations by
+** the CPU (nor by 'strtod')
+*/
+
+/* allows for external implementation for part of the trick */
+#if !defined(NNMARK)	/* { */
+
+
+#if !defined(LUA_IEEEENDIAN)
+#error option 'LUA_NANTRICK' needs 'LUA_IEEEENDIAN'
+#endif
+
+
+#define NNMARK		0x7FF7A500
+#define NNMASK		0x7FFFFF00
+
+#undef TValuefields
+#undef NILCONSTANT
+
+#if (LUA_IEEEENDIAN == 0)	/* { */
+
+/* little endian */
+#define TValuefields  \
+	union { struct { Value v__; int tt__; } i; double d__; } u
+#define NILCONSTANT	{{{NULL}, tag2tt(LUA_TNIL)}}
+/* field-access macros */
+#define v_(o)		((o)->u.i.v__)
+#define d_(o)		((o)->u.d__)
+#define tt_(o)		((o)->u.i.tt__)
+
+#else				/* }{ */
+
+/* big endian */
+#define TValuefields  \
+	union { struct { int tt__; Value v__; } i; double d__; } u
+#define NILCONSTANT	{{tag2tt(LUA_TNIL), {NULL}}}
+/* field-access macros */
+#define v_(o)		((o)->u.i.v__)
+#define d_(o)		((o)->u.d__)
+#define tt_(o)		((o)->u.i.tt__)
+
+#endif				/* } */
+
+#endif			/* } */
+
+
+/* correspondence with standard representation */
+#undef val_
+#define val_(o)		v_(o)
+#undef num_
+#define num_(o)		d_(o)
+
+
+#undef numfield
+#define numfield	/* no such field; numbers are the entire struct */
+
+/* basic check to distinguish numbers from non-numbers */
+#undef ttisnumber
+#define ttisnumber(o)	((tt_(o) & NNMASK) != NNMARK)
+
+#define tag2tt(t)	(NNMARK | (t))
+
+#undef rttype
+#define rttype(o)	(ttisnumber(o) ? LUA_TNUMBER : tt_(o) & 0xff)
+
+#undef settt_
+#define settt_(o,t)	(tt_(o) = tag2tt(t))
+
+#undef setnvalue
+#define setnvalue(obj,x) \
+	{ TValue *io_=(obj); num_(io_)=(x); lua_assert(ttisnumber(io_)); }
+
+#undef setobj
+#define setobj(L,obj1,obj2) \
+	{ const TValue *o2_=(obj2); TValue *o1_=(obj1); \
+	  o1_->u = o2_->u; \
+	  checkliveness(G(L),o1_); }
+
+
+/*
+** these redefinitions are not mandatory, but these forms are more efficient
+*/
+
+#undef checktag
+#undef checktype
+#define checktag(o,t)	(tt_(o) == tag2tt(t))
+#define checktype(o,t)	(ctb(tt_(o) | VARBITS) == ctb(tag2tt(t) | VARBITS))
+
+#undef ttisequal
+#define ttisequal(o1,o2)  \
+	(ttisnumber(o1) ? ttisnumber(o2) : (tt_(o1) == tt_(o2)))
+
+
+#undef luai_checknum
+#define luai_checknum(L,o,c)	{ if (!ttisnumber(o)) c; }
+
+#endif
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** types and prototypes
+** =======================================================
+*/
+
+
+union Value {
+  GCObject *gc;    /* collectable objects */
+  void *p;         /* light userdata */
+  int b;           /* booleans */
+  lua_CFunction f; /* light C functions */
+  numfield         /* numbers */
+};
+
+
+struct lua_TValue {
+  TValuefields;
+};
+
+
+typedef TValue *StkId;  /* index to stack elements */
+
+
+
+
+/*
+** Header for string value; string bytes follow the end of this structure
+*/
+typedef union TString {
+  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
+  struct {
+    CommonHeader;
+    lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
+    unsigned int hash;
+    size_t len;  /* number of characters in string */
+  } tsv;
+} TString;
+
+
+/* get the actual string (array of bytes) from a TString */
+#define getstr(ts)	cast(const char *, (ts) + 1)
+
+/* get the actual string (array of bytes) from a Lua value */
+#define svalue(o)       getstr(rawtsvalue(o))
+
+
+/*
+** Header for userdata; memory area follows the end of this structure
+*/
+typedef union Udata {
+  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
+  struct {
+    CommonHeader;
+    struct Table *metatable;
+    struct Table *env;
+    size_t len;  /* number of bytes */
+  } uv;
+} Udata;
+
+
+
+/*
+** Description of an upvalue for function prototypes
+*/
+typedef struct Upvaldesc {
+  TString *name;  /* upvalue name (for debug information) */
+  lu_byte instack;  /* whether it is in stack */
+  lu_byte idx;  /* index of upvalue (in stack or in outer function's list) */
+} Upvaldesc;
+
+
+/*
+** Description of a local variable for function prototypes
+** (used for debug information)
+*/
+typedef struct LocVar {
+  TString *varname;
+  int startpc;  /* first point where variable is active */
+  int endpc;    /* first point where variable is dead */
+} LocVar;
+
+
+/*
+** Function Prototypes
+*/
+typedef struct Proto {
+  CommonHeader;
+  TValue *k;  /* constants used by the function */
+  Instruction *code;
+  struct Proto **p;  /* functions defined inside the function */
+  int *lineinfo;  /* map from opcodes to source lines (debug information) */
+  LocVar *locvars;  /* information about local variables (debug information) */
+  Upvaldesc *upvalues;  /* upvalue information */
+  union Closure *cache;  /* last created closure with this prototype */
+  TString  *source;  /* used for debug information */
+  int sizeupvalues;  /* size of 'upvalues' */
+  int sizek;  /* size of `k' */
+  int sizecode;
+  int sizelineinfo;
+  int sizep;  /* size of `p' */
+  int sizelocvars;
+  int linedefined;
+  int lastlinedefined;
+  GCObject *gclist;
+  lu_byte numparams;  /* number of fixed parameters */
+  lu_byte is_vararg;
+  lu_byte maxstacksize;  /* maximum stack used by this function */
+} Proto;
+
+
+
+/*
+** Lua Upvalues
+*/
+typedef struct UpVal {
+  CommonHeader;
+  TValue *v;  /* points to stack or to its own value */
+  union {
+    TValue value;  /* the value (when closed) */
+    struct {  /* double linked list (when open) */
+      struct UpVal *prev;
+      struct UpVal *next;
+    } l;
+  } u;
+} UpVal;
+
+
+/*
+** Closures
+*/
+
+#define ClosureHeader \
+	CommonHeader; lu_byte nupvalues; GCObject *gclist
+
+typedef struct CClosure {
+  ClosureHeader;
+  lua_CFunction f;
+  TValue upvalue[1];  /* list of upvalues */
+} CClosure;
+
+
+typedef struct LClosure {
+  ClosureHeader;
+  struct Proto *p;
+  UpVal *upvals[1];  /* list of upvalues */
+} LClosure;
+
+
+typedef union Closure {
+  CClosure c;
+  LClosure l;
+} Closure;
+
+
+#define isLfunction(o)	ttisLclosure(o)
+
+#define getproto(o)	(clLvalue(o)->p)
+
+
+/*
+** Tables
+*/
+
+typedef union TKey {
+  struct {
+    TValuefields;
+    struct Node *next;  /* for chaining */
+  } nk;
+  TValue tvk;
+} TKey;
+
+
+typedef struct Node {
+  TValue i_val;
+  TKey i_key;
+} Node;
+
+
+typedef struct Table {
+  CommonHeader;
+  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
+  lu_byte lsizenode;  /* log2 of size of `node' array */
+  struct Table *metatable;
+  TValue *array;  /* array part */
+  Node *node;
+  Node *lastfree;  /* any free position is before this position */
+  GCObject *gclist;
+  int sizearray;  /* size of `array' array */
+} Table;
+
+
+
+/*
+** `module' operation for hashing (size is always a power of 2)
+*/
+#define lmod(s,size) \
+	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
+
+
+#define twoto(x)	(1<<(x))
+#define sizenode(t)	(twoto((t)->lsizenode))
+
+
+/*
+** (address of) a fixed nil value
+*/
+#define luaO_nilobject		(&luaO_nilobject_)
+
+
+LUAI_DDEC const TValue luaO_nilobject_;
+
+
+LUAI_FUNC int luaO_int2fb (unsigned int x);
+LUAI_FUNC int luaO_fb2int (int x);
+LUAI_FUNC int luaO_ceillog2 (unsigned int x);
+LUAI_FUNC lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2);
+LUAI_FUNC int luaO_str2d (const char *s, size_t len, lua_Number *result);
+LUAI_FUNC int luaO_hexavalue (int c);
+LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
+                                                       va_list argp);
+LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
+LUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);
+
+
+#endif
+
diff --git a/dep/lualib/lopcodes.c b/dep/lualib/lopcodes.c
new file mode 100644
index 0000000..ef73692
--- /dev/null
+++ b/dep/lualib/lopcodes.c
@@ -0,0 +1,107 @@
+/*
+** $Id: lopcodes.c,v 1.49 2012/05/14 13:34:18 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#define lopcodes_c
+#define LUA_CORE
+
+
+#include "lopcodes.h"
+
+
+/* ORDER OP */
+
+LUAI_DDEF const char *const luaP_opnames[NUM_OPCODES+1] = {
+  "MOVE",
+  "LOADK",
+  "LOADKX",
+  "LOADBOOL",
+  "LOADNIL",
+  "GETUPVAL",
+  "GETTABUP",
+  "GETTABLE",
+  "SETTABUP",
+  "SETUPVAL",
+  "SETTABLE",
+  "NEWTABLE",
+  "SELF",
+  "ADD",
+  "SUB",
+  "MUL",
+  "DIV",
+  "MOD",
+  "POW",
+  "UNM",
+  "NOT",
+  "LEN",
+  "CONCAT",
+  "JMP",
+  "EQ",
+  "LT",
+  "LE",
+  "TEST",
+  "TESTSET",
+  "CALL",
+  "TAILCALL",
+  "RETURN",
+  "FORLOOP",
+  "FORPREP",
+  "TFORCALL",
+  "TFORLOOP",
+  "SETLIST",
+  "CLOSURE",
+  "VARARG",
+  "EXTRAARG",
+  NULL
+};
+
+
+#define opmode(t,a,b,c,m) (((t)<<7) | ((a)<<6) | ((b)<<4) | ((c)<<2) | (m))
+
+LUAI_DDEF const lu_byte luaP_opmodes[NUM_OPCODES] = {
+/*       T  A    B       C     mode		   opcode	*/
+  opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_MOVE */
+ ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_LOADK */
+ ,opmode(0, 1, OpArgN, OpArgN, iABx)		/* OP_LOADKX */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_LOADBOOL */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_LOADNIL */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_GETUPVAL */
+ ,opmode(0, 1, OpArgU, OpArgK, iABC)		/* OP_GETTABUP */
+ ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_GETTABLE */
+ ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABUP */
+ ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_SETUPVAL */
+ ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABLE */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_NEWTABLE */
+ ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_SELF */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
+ ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
+ ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_JMP */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_EQ */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LT */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LE */
+ ,opmode(1, 0, OpArgN, OpArgU, iABC)		/* OP_TEST */
+ ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TESTSET */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_CALL */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_TAILCALL */
+ ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_RETURN */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORLOOP */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORPREP */
+ ,opmode(0, 0, OpArgN, OpArgU, iABC)		/* OP_TFORCALL */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_TFORLOOP */
+ ,opmode(0, 0, OpArgU, OpArgU, iABC)		/* OP_SETLIST */
+ ,opmode(0, 1, OpArgU, OpArgN, iABx)		/* OP_CLOSURE */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_VARARG */
+ ,opmode(0, 0, OpArgU, OpArgU, iAx)		/* OP_EXTRAARG */
+};
+
diff --git a/dep/lualib/lopcodes.h b/dep/lualib/lopcodes.h
new file mode 100644
index 0000000..07d2b3f
--- /dev/null
+++ b/dep/lualib/lopcodes.h
@@ -0,0 +1,288 @@
+/*
+** $Id: lopcodes.h,v 1.142 2011/07/15 12:50:29 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lopcodes_h
+#define lopcodes_h
+
+#include "llimits.h"
+
+
+/*===========================================================================
+  We assume that instructions are unsigned numbers.
+  All instructions have an opcode in the first 6 bits.
+  Instructions can have the following fields:
+	`A' : 8 bits
+	`B' : 9 bits
+	`C' : 9 bits
+	'Ax' : 26 bits ('A', 'B', and 'C' together)
+	`Bx' : 18 bits (`B' and `C' together)
+	`sBx' : signed Bx
+
+  A signed argument is represented in excess K; that is, the number
+  value is the unsigned value minus K. K is exactly the maximum value
+  for that argument (so that -max is represented by 0, and +max is
+  represented by 2*max), which is half the maximum for the corresponding
+  unsigned argument.
+===========================================================================*/
+
+
+enum OpMode {iABC, iABx, iAsBx, iAx};  /* basic instruction format */
+
+
+/*
+** size and position of opcode arguments.
+*/
+#define SIZE_C		9
+#define SIZE_B		9
+#define SIZE_Bx		(SIZE_C + SIZE_B)
+#define SIZE_A		8
+#define SIZE_Ax		(SIZE_C + SIZE_B + SIZE_A)
+
+#define SIZE_OP		6
+
+#define POS_OP		0
+#define POS_A		(POS_OP + SIZE_OP)
+#define POS_C		(POS_A + SIZE_A)
+#define POS_B		(POS_C + SIZE_C)
+#define POS_Bx		POS_C
+#define POS_Ax		POS_A
+
+
+/*
+** limits for opcode arguments.
+** we use (signed) int to manipulate most arguments,
+** so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
+*/
+#if SIZE_Bx < LUAI_BITSINT-1
+#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
+#define MAXARG_sBx        (MAXARG_Bx>>1)         /* `sBx' is signed */
+#else
+#define MAXARG_Bx        MAX_INT
+#define MAXARG_sBx        MAX_INT
+#endif
+
+#if SIZE_Ax < LUAI_BITSINT-1
+#define MAXARG_Ax	((1<<SIZE_Ax)-1)
+#else
+#define MAXARG_Ax	MAX_INT
+#endif
+
+
+#define MAXARG_A        ((1<<SIZE_A)-1)
+#define MAXARG_B        ((1<<SIZE_B)-1)
+#define MAXARG_C        ((1<<SIZE_C)-1)
+
+
+/* creates a mask with `n' 1 bits at position `p' */
+#define MASK1(n,p)	((~((~(Instruction)0)<<(n)))<<(p))
+
+/* creates a mask with `n' 0 bits at position `p' */
+#define MASK0(n,p)	(~MASK1(n,p))
+
+/*
+** the following macros help to manipulate instructions
+*/
+
+#define GET_OPCODE(i)	(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
+#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
+		((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))
+
+#define getarg(i,pos,size)	(cast(int, ((i)>>pos) & MASK1(size,0)))
+#define setarg(i,v,pos,size)	((i) = (((i)&MASK0(size,pos)) | \
+                ((cast(Instruction, v)<<pos)&MASK1(size,pos))))
+
+#define GETARG_A(i)	getarg(i, POS_A, SIZE_A)
+#define SETARG_A(i,v)	setarg(i, v, POS_A, SIZE_A)
+
+#define GETARG_B(i)	getarg(i, POS_B, SIZE_B)
+#define SETARG_B(i,v)	setarg(i, v, POS_B, SIZE_B)
+
+#define GETARG_C(i)	getarg(i, POS_C, SIZE_C)
+#define SETARG_C(i,v)	setarg(i, v, POS_C, SIZE_C)
+
+#define GETARG_Bx(i)	getarg(i, POS_Bx, SIZE_Bx)
+#define SETARG_Bx(i,v)	setarg(i, v, POS_Bx, SIZE_Bx)
+
+#define GETARG_Ax(i)	getarg(i, POS_Ax, SIZE_Ax)
+#define SETARG_Ax(i,v)	setarg(i, v, POS_Ax, SIZE_Ax)
+
+#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
+#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
+
+
+#define CREATE_ABC(o,a,b,c)	((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, b)<<POS_B) \
+			| (cast(Instruction, c)<<POS_C))
+
+#define CREATE_ABx(o,a,bc)	((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, bc)<<POS_Bx))
+
+#define CREATE_Ax(o,a)		((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_Ax))
+
+
+/*
+** Macros to operate RK indices
+*/
+
+/* this bit 1 means constant (0 means register) */
+#define BITRK		(1 << (SIZE_B - 1))
+
+/* test whether value is a constant */
+#define ISK(x)		((x) & BITRK)
+
+/* gets the index of the constant */
+#define INDEXK(r)	((int)(r) & ~BITRK)
+
+#define MAXINDEXRK	(BITRK - 1)
+
+/* code a constant index as a RK value */
+#define RKASK(x)	((x) | BITRK)
+
+
+/*
+** invalid register that fits in 8 bits
+*/
+#define NO_REG		MAXARG_A
+
+
+/*
+** R(x) - register
+** Kst(x) - constant (in constant table)
+** RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
+*/
+
+
+/*
+** grep "ORDER OP" if you change these enums
+*/
+
+typedef enum {
+/*----------------------------------------------------------------------
+name		args	description
+------------------------------------------------------------------------*/
+OP_MOVE,/*	A B	R(A) := R(B)					*/
+OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
+OP_LOADKX,/*	A 	R(A) := Kst(extra arg)				*/
+OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) pc++			*/
+OP_LOADNIL,/*	A B	R(A), R(A+1), ..., R(A+B) := nil		*/
+OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/
+
+OP_GETTABUP,/*	A B C	R(A) := UpValue[B][RK(C)]			*/
+OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/
+
+OP_SETTABUP,/*	A B C	UpValue[A][RK(B)] := RK(C)			*/
+OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
+OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/
+
+OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
+
+OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
+
+OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
+OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
+OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
+OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
+OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
+OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_UNM,/*	A B	R(A) := -R(B)					*/
+OP_NOT,/*	A B	R(A) := not R(B)				*/
+OP_LEN,/*	A B	R(A) := length of R(B)				*/
+
+OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
+
+OP_JMP,/*	A sBx	pc+=sBx; if (A) close all upvalues >= R(A) + 1	*/
+OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
+OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++		*/
+OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++		*/
+
+OP_TEST,/*	A C	if not (R(A) <=> C) then pc++			*/
+OP_TESTSET,/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*/
+
+OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
+OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
+OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
+
+OP_FORLOOP,/*	A sBx	R(A)+=R(A+2);
+			if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/
+OP_FORPREP,/*	A sBx	R(A)-=R(A+2); pc+=sBx				*/
+
+OP_TFORCALL,/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));	*/
+OP_TFORLOOP,/*	A sBx	if R(A+1) ~= nil then { R(A)=R(A+1); pc += sBx }*/
+
+OP_SETLIST,/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B	*/
+
+OP_CLOSURE,/*	A Bx	R(A) := closure(KPROTO[Bx])			*/
+
+OP_VARARG,/*	A B	R(A), R(A+1), ..., R(A+B-2) = vararg		*/
+
+OP_EXTRAARG/*	Ax	extra (larger) argument for previous opcode	*/
+} OpCode;
+
+
+#define NUM_OPCODES	(cast(int, OP_EXTRAARG) + 1)
+
+
+
+/*===========================================================================
+  Notes:
+  (*) In OP_CALL, if (B == 0) then B = top. If (C == 0), then `top' is
+  set to last_result+1, so next open instruction (OP_CALL, OP_RETURN,
+  OP_SETLIST) may use `top'.
+
+  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
+  set top (like in OP_CALL with C == 0).
+
+  (*) In OP_RETURN, if (B == 0) then return up to `top'.
+
+  (*) In OP_SETLIST, if (B == 0) then B = `top'; if (C == 0) then next
+  'instruction' is EXTRAARG(real C).
+
+  (*) In OP_LOADKX, the next 'instruction' is always EXTRAARG.
+
+  (*) For comparisons, A specifies what condition the test should accept
+  (true or false).
+
+  (*) All `skips' (pc++) assume that next instruction is a jump.
+
+===========================================================================*/
+
+
+/*
+** masks for instruction properties. The format is:
+** bits 0-1: op mode
+** bits 2-3: C arg mode
+** bits 4-5: B arg mode
+** bit 6: instruction set register A
+** bit 7: operator is a test (next instruction must be a jump)
+*/
+
+enum OpArgMask {
+  OpArgN,  /* argument is not used */
+  OpArgU,  /* argument is used */
+  OpArgR,  /* argument is a register or a jump offset */
+  OpArgK   /* argument is a constant or register/constant */
+};
+
+LUAI_DDEC const lu_byte luaP_opmodes[NUM_OPCODES];
+
+#define getOpMode(m)	(cast(enum OpMode, luaP_opmodes[m] & 3))
+#define getBMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
+#define getCMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
+#define testAMode(m)	(luaP_opmodes[m] & (1 << 6))
+#define testTMode(m)	(luaP_opmodes[m] & (1 << 7))
+
+
+LUAI_DDEC const char *const luaP_opnames[NUM_OPCODES+1];  /* opcode names */
+
+
+/* number of list items to accumulate before a SETLIST instruction */
+#define LFIELDS_PER_FLUSH	50
+
+
+#endif
diff --git a/dep/lualib/loslib.c b/dep/lualib/loslib.c
new file mode 100644
index 0000000..489755b
--- /dev/null
+++ b/dep/lualib/loslib.c
@@ -0,0 +1,323 @@
+/*
+** $Id: loslib.c,v 1.39 2012/05/23 15:37:09 roberto Exp $
+** Standard Operating System library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <locale.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#define loslib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** list of valid conversion specifiers for the 'strftime' function
+*/
+#if !defined(LUA_STRFTIMEOPTIONS)
+
+#if !defined(LUA_USE_POSIX)
+#define LUA_STRFTIMEOPTIONS	{ "aAbBcdHIjmMpSUwWxXyYz%", "" }
+#else
+#define LUA_STRFTIMEOPTIONS \
+	{ "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%", "" \
+	  "", "E", "cCxXyY",  \
+	  "O", "deHImMSuUVwWy" }
+#endif
+
+#endif
+
+
+
+/*
+** By default, Lua uses tmpnam except when POSIX is available, where it
+** uses mkstemp.
+*/
+#if defined(LUA_USE_MKSTEMP)
+#include <unistd.h>
+#define LUA_TMPNAMBUFSIZE	32
+#define lua_tmpnam(b,e) { \
+        strcpy(b, "/tmp/lua_XXXXXX"); \
+        e = mkstemp(b); \
+        if (e != -1) close(e); \
+        e = (e == -1); }
+
+#elif !defined(lua_tmpnam)
+
+#define LUA_TMPNAMBUFSIZE	L_tmpnam
+#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
+
+#endif
+
+
+/*
+** By default, Lua uses gmtime/localtime, except when POSIX is available,
+** where it uses gmtime_r/localtime_r
+*/
+#if defined(LUA_USE_GMTIME_R)
+
+#define l_gmtime(t,r)		gmtime_r(t,r)
+#define l_localtime(t,r)	localtime_r(t,r)
+
+#elif !defined(l_gmtime)
+
+#define l_gmtime(t,r)		((void)r, gmtime(t))
+#define l_localtime(t,r)  	((void)r, localtime(t))
+
+#endif
+
+
+
+static int os_execute (lua_State *L) {
+  const char *cmd = luaL_optstring(L, 1, NULL);
+  int stat = system(cmd);
+  if (cmd != NULL)
+    return luaL_execresult(L, stat);
+  else {
+    lua_pushboolean(L, stat);  /* true if there is a shell */
+    return 1;
+  }
+}
+
+
+static int os_remove (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  return luaL_fileresult(L, remove(filename) == 0, filename);
+}
+
+
+static int os_rename (lua_State *L) {
+  const char *fromname = luaL_checkstring(L, 1);
+  const char *toname = luaL_checkstring(L, 2);
+  return luaL_fileresult(L, rename(fromname, toname) == 0, fromname);
+}
+
+
+static int os_tmpname (lua_State *L) {
+  char buff[LUA_TMPNAMBUFSIZE];
+  int err;
+  lua_tmpnam(buff, err);
+  if (err)
+    return luaL_error(L, "unable to generate a unique filename");
+  lua_pushstring(L, buff);
+  return 1;
+}
+
+
+static int os_getenv (lua_State *L) {
+  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  return 1;
+}
+
+
+static int os_clock (lua_State *L) {
+  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Time/Date operations
+** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
+**   wday=%w+1, yday=%j, isdst=? }
+** =======================================================
+*/
+
+static void setfield (lua_State *L, const char *key, int value) {
+  lua_pushinteger(L, value);
+  lua_setfield(L, -2, key);
+}
+
+static void setboolfield (lua_State *L, const char *key, int value) {
+  if (value < 0)  /* undefined? */
+    return;  /* does not set field */
+  lua_pushboolean(L, value);
+  lua_setfield(L, -2, key);
+}
+
+static int getboolfield (lua_State *L, const char *key) {
+  int res;
+  lua_getfield(L, -1, key);
+  res = lua_isnil(L, -1) ? -1 : lua_toboolean(L, -1);
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int getfield (lua_State *L, const char *key, int d) {
+  int res, isnum;
+  lua_getfield(L, -1, key);
+  res = (int)lua_tointegerx(L, -1, &isnum);
+  if (!isnum) {
+    if (d < 0)
+      return luaL_error(L, "field " LUA_QS " missing in date table", key);
+    res = d;
+  }
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static const char *checkoption (lua_State *L, const char *conv, char *buff) {
+  static const char *const options[] = LUA_STRFTIMEOPTIONS;
+  unsigned int i;
+  for (i = 0; i < sizeof(options)/sizeof(options[0]); i += 2) {
+    if (*conv != '\0' && strchr(options[i], *conv) != NULL) {
+      buff[1] = *conv;
+      if (*options[i + 1] == '\0') {  /* one-char conversion specifier? */
+        buff[2] = '\0';  /* end buffer */
+        return conv + 1;
+      }
+      else if (*(conv + 1) != '\0' &&
+               strchr(options[i + 1], *(conv + 1)) != NULL) {
+        buff[2] = *(conv + 1);  /* valid two-char conversion specifier */
+        buff[3] = '\0';  /* end buffer */
+        return conv + 2;
+      }
+    }
+  }
+  luaL_argerror(L, 1,
+    lua_pushfstring(L, "invalid conversion specifier '%%%s'", conv));
+  return conv;  /* to avoid warnings */
+}
+
+
+static int os_date (lua_State *L) {
+  const char *s = luaL_optstring(L, 1, "%c");
+  time_t t = luaL_opt(L, (time_t)luaL_checknumber, 2, time(NULL));
+  struct tm tmr, *stm;
+  if (*s == '!') {  /* UTC? */
+    stm = l_gmtime(&t, &tmr);
+    s++;  /* skip `!' */
+  }
+  else
+    stm = l_localtime(&t, &tmr);
+  if (stm == NULL)  /* invalid date? */
+    lua_pushnil(L);
+  else if (strcmp(s, "*t") == 0) {
+    lua_createtable(L, 0, 9);  /* 9 = number of fields */
+    setfield(L, "sec", stm->tm_sec);
+    setfield(L, "min", stm->tm_min);
+    setfield(L, "hour", stm->tm_hour);
+    setfield(L, "day", stm->tm_mday);
+    setfield(L, "month", stm->tm_mon+1);
+    setfield(L, "year", stm->tm_year+1900);
+    setfield(L, "wday", stm->tm_wday+1);
+    setfield(L, "yday", stm->tm_yday+1);
+    setboolfield(L, "isdst", stm->tm_isdst);
+  }
+  else {
+    char cc[4];
+    luaL_Buffer b;
+    cc[0] = '%';
+    luaL_buffinit(L, &b);
+    while (*s) {
+      if (*s != '%')  /* no conversion specifier? */
+        luaL_addchar(&b, *s++);
+      else {
+        size_t reslen;
+        char buff[200];  /* should be big enough for any conversion result */
+        s = checkoption(L, s + 1, cc);
+        reslen = strftime(buff, sizeof(buff), cc, stm);
+        luaL_addlstring(&b, buff, reslen);
+      }
+    }
+    luaL_pushresult(&b);
+  }
+  return 1;
+}
+
+
+static int os_time (lua_State *L) {
+  time_t t;
+  if (lua_isnoneornil(L, 1))  /* called without args? */
+    t = time(NULL);  /* get current time */
+  else {
+    struct tm ts;
+    luaL_checktype(L, 1, LUA_TTABLE);
+    lua_settop(L, 1);  /* make sure table is at the top */
+    ts.tm_sec = getfield(L, "sec", 0);
+    ts.tm_min = getfield(L, "min", 0);
+    ts.tm_hour = getfield(L, "hour", 12);
+    ts.tm_mday = getfield(L, "day", -1);
+    ts.tm_mon = getfield(L, "month", -1) - 1;
+    ts.tm_year = getfield(L, "year", -1) - 1900;
+    ts.tm_isdst = getboolfield(L, "isdst");
+    t = mktime(&ts);
+  }
+  if (t == (time_t)(-1))
+    lua_pushnil(L);
+  else
+    lua_pushnumber(L, (lua_Number)t);
+  return 1;
+}
+
+
+static int os_difftime (lua_State *L) {
+  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
+                             (time_t)(luaL_optnumber(L, 2, 0))));
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static int os_setlocale (lua_State *L) {
+  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
+                      LC_NUMERIC, LC_TIME};
+  static const char *const catnames[] = {"all", "collate", "ctype", "monetary",
+     "numeric", "time", NULL};
+  const char *l = luaL_optstring(L, 1, NULL);
+  int op = luaL_checkoption(L, 2, "all", catnames);
+  lua_pushstring(L, setlocale(cat[op], l));
+  return 1;
+}
+
+
+static int os_exit (lua_State *L) {
+  int status;
+  if (lua_isboolean(L, 1))
+    status = (lua_toboolean(L, 1) ? EXIT_SUCCESS : EXIT_FAILURE);
+  else
+    status = luaL_optint(L, 1, EXIT_SUCCESS);
+  if (lua_toboolean(L, 2))
+    lua_close(L);
+  if (L) exit(status);  /* 'if' to avoid warnings for unreachable 'return' */
+  return 0;
+}
+
+
+static const luaL_Reg syslib[] = {
+  {"clock",     os_clock},
+  {"date",      os_date},
+  {"difftime",  os_difftime},
+  {"execute",   os_execute},
+  {"exit",      os_exit},
+  {"getenv",    os_getenv},
+  {"remove",    os_remove},
+  {"rename",    os_rename},
+  {"setlocale", os_setlocale},
+  {"time",      os_time},
+  {"tmpname",   os_tmpname},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+LUAMOD_API int luaopen_os (lua_State *L) {
+  luaL_newlib(L, syslib);
+  return 1;
+}
+
diff --git a/dep/lualib/lparser.c b/dep/lualib/lparser.c
new file mode 100644
index 0000000..b3eb3ca
--- /dev/null
+++ b/dep/lualib/lparser.c
@@ -0,0 +1,1635 @@
+/*
+** $Id: lparser.c,v 2.128 2012/05/20 14:51:23 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lparser_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+
+
+
+/* maximum number of local variables per function (must be smaller
+   than 250, due to the bytecode format) */
+#define MAXVARS		200
+
+
+#define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
+
+
+
+/*
+** nodes for block list (list of active blocks)
+*/
+typedef struct BlockCnt {
+  struct BlockCnt *previous;  /* chain */
+  short firstlabel;  /* index of first label in this block */
+  short firstgoto;  /* index of first pending goto in this block */
+  lu_byte nactvar;  /* # active locals outside the block */
+  lu_byte upval;  /* true if some variable in the block is an upvalue */
+  lu_byte isloop;  /* true if `block' is a loop */
+} BlockCnt;
+
+
+
+/*
+** prototypes for recursive non-terminal functions
+*/
+static void statement (LexState *ls);
+static void expr (LexState *ls, expdesc *v);
+
+
+static void anchor_token (LexState *ls) {
+  /* last token from outer function must be EOS */
+  lua_assert(ls->fs != NULL || ls->t.token == TK_EOS);
+  if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {
+    TString *ts = ls->t.seminfo.ts;
+    luaX_newstring(ls, getstr(ts), ts->tsv.len);
+  }
+}
+
+
+/* semantic error */
+static l_noret semerror (LexState *ls, const char *msg) {
+  ls->t.token = 0;  /* remove 'near to' from final message */
+  luaX_syntaxerror(ls, msg);
+}
+
+
+static l_noret error_expected (LexState *ls, int token) {
+  luaX_syntaxerror(ls,
+      luaO_pushfstring(ls->L, "%s expected", luaX_token2str(ls, token)));
+}
+
+
+static l_noret errorlimit (FuncState *fs, int limit, const char *what) {
+  lua_State *L = fs->ls->L;
+  const char *msg;
+  int line = fs->f->linedefined;
+  const char *where = (line == 0)
+                      ? "main function"
+                      : luaO_pushfstring(L, "function at line %d", line);
+  msg = luaO_pushfstring(L, "too many %s (limit is %d) in %s",
+                             what, limit, where);
+  luaX_syntaxerror(fs->ls, msg);
+}
+
+
+static void checklimit (FuncState *fs, int v, int l, const char *what) {
+  if (v > l) errorlimit(fs, l, what);
+}
+
+
+static int testnext (LexState *ls, int c) {
+  if (ls->t.token == c) {
+    luaX_next(ls);
+    return 1;
+  }
+  else return 0;
+}
+
+
+static void check (LexState *ls, int c) {
+  if (ls->t.token != c)
+    error_expected(ls, c);
+}
+
+
+static void checknext (LexState *ls, int c) {
+  check(ls, c);
+  luaX_next(ls);
+}
+
+
+#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
+
+
+
+static void check_match (LexState *ls, int what, int who, int where) {
+  if (!testnext(ls, what)) {
+    if (where == ls->linenumber)
+      error_expected(ls, what);
+    else {
+      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
+             "%s expected (to close %s at line %d)",
+              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
+    }
+  }
+}
+
+
+static TString *str_checkname (LexState *ls) {
+  TString *ts;
+  check(ls, TK_NAME);
+  ts = ls->t.seminfo.ts;
+  luaX_next(ls);
+  return ts;
+}
+
+
+static void init_exp (expdesc *e, expkind k, int i) {
+  e->f = e->t = NO_JUMP;
+  e->k = k;
+  e->u.info = i;
+}
+
+
+static void codestring (LexState *ls, expdesc *e, TString *s) {
+  init_exp(e, VK, luaK_stringK(ls->fs, s));
+}
+
+
+static void checkname (LexState *ls, expdesc *e) {
+  codestring(ls, e, str_checkname(ls));
+}
+
+
+static int registerlocalvar (LexState *ls, TString *varname) {
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int oldsize = f->sizelocvars;
+  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
+                  LocVar, SHRT_MAX, "local variables");
+  while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;
+  f->locvars[fs->nlocvars].varname = varname;
+  luaC_objbarrier(ls->L, f, varname);
+  return fs->nlocvars++;
+}
+
+
+static void new_localvar (LexState *ls, TString *name) {
+  FuncState *fs = ls->fs;
+  Dyndata *dyd = ls->dyd;
+  int reg = registerlocalvar(ls, name);
+  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,
+                  MAXVARS, "local variables");
+  luaM_growvector(ls->L, dyd->actvar.arr, dyd->actvar.n + 1,
+                  dyd->actvar.size, Vardesc, MAX_INT, "local variables");
+  dyd->actvar.arr[dyd->actvar.n++].idx = cast(short, reg);
+}
+
+
+static void new_localvarliteral_ (LexState *ls, const char *name, size_t sz) {
+  new_localvar(ls, luaX_newstring(ls, name, sz));
+}
+
+#define new_localvarliteral(ls,v) \
+	new_localvarliteral_(ls, "" v, (sizeof(v)/sizeof(char))-1)
+
+
+static LocVar *getlocvar (FuncState *fs, int i) {
+  int idx = fs->ls->dyd->actvar.arr[fs->firstlocal + i].idx;
+  lua_assert(idx < fs->nlocvars);
+  return &fs->f->locvars[idx];
+}
+
+
+static void adjustlocalvars (LexState *ls, int nvars) {
+  FuncState *fs = ls->fs;
+  fs->nactvar = cast_byte(fs->nactvar + nvars);
+  for (; nvars; nvars--) {
+    getlocvar(fs, fs->nactvar - nvars)->startpc = fs->pc;
+  }
+}
+
+
+static void removevars (FuncState *fs, int tolevel) {
+  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);
+  while (fs->nactvar > tolevel)
+    getlocvar(fs, --fs->nactvar)->endpc = fs->pc;
+}
+
+
+static int searchupvalue (FuncState *fs, TString *name) {
+  int i;
+  Upvaldesc *up = fs->f->upvalues;
+  for (i = 0; i < fs->nups; i++) {
+    if (luaS_eqstr(up[i].name, name)) return i;
+  }
+  return -1;  /* not found */
+}
+
+
+static int newupvalue (FuncState *fs, TString *name, expdesc *v) {
+  Proto *f = fs->f;
+  int oldsize = f->sizeupvalues;
+  checklimit(fs, fs->nups + 1, MAXUPVAL, "upvalues");
+  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,
+                  Upvaldesc, MAXUPVAL, "upvalues");
+  while (oldsize < f->sizeupvalues) f->upvalues[oldsize++].name = NULL;
+  f->upvalues[fs->nups].instack = (v->k == VLOCAL);
+  f->upvalues[fs->nups].idx = cast_byte(v->u.info);
+  f->upvalues[fs->nups].name = name;
+  luaC_objbarrier(fs->ls->L, f, name);
+  return fs->nups++;
+}
+
+
+static int searchvar (FuncState *fs, TString *n) {
+  int i;
+  for (i=fs->nactvar-1; i >= 0; i--) {
+    if (luaS_eqstr(n, getlocvar(fs, i)->varname))
+      return i;
+  }
+  return -1;  /* not found */
+}
+
+
+/*
+  Mark block where variable at given level was defined
+  (to emit close instructions later).
+*/
+static void markupval (FuncState *fs, int level) {
+  BlockCnt *bl = fs->bl;
+  while (bl->nactvar > level) bl = bl->previous;
+  bl->upval = 1;
+}
+
+
+/*
+  Find variable with given name 'n'. If it is an upvalue, add this
+  upvalue into all intermediate functions.
+*/
+static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
+  if (fs == NULL)  /* no more levels? */
+    return VVOID;  /* default is global */
+  else {
+    int v = searchvar(fs, n);  /* look up locals at current level */
+    if (v >= 0) {  /* found? */
+      init_exp(var, VLOCAL, v);  /* variable is local */
+      if (!base)
+        markupval(fs, v);  /* local will be used as an upval */
+      return VLOCAL;
+    }
+    else {  /* not found as local at current level; try upvalues */
+      int idx = searchupvalue(fs, n);  /* try existing upvalues */
+      if (idx < 0) {  /* not found? */
+        if (singlevaraux(fs->prev, n, var, 0) == VVOID) /* try upper levels */
+          return VVOID;  /* not found; is a global */
+        /* else was LOCAL or UPVAL */
+        idx  = newupvalue(fs, n, var);  /* will be a new upvalue */
+      }
+      init_exp(var, VUPVAL, idx);
+      return VUPVAL;
+    }
+  }
+}
+
+
+static void singlevar (LexState *ls, expdesc *var) {
+  TString *varname = str_checkname(ls);
+  FuncState *fs = ls->fs;
+  if (singlevaraux(fs, varname, var, 1) == VVOID) {  /* global name? */
+    expdesc key;
+    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */
+    lua_assert(var->k == VLOCAL || var->k == VUPVAL);
+    codestring(ls, &key, varname);  /* key is variable name */
+    luaK_indexed(fs, var, &key);  /* env[varname] */
+  }
+}
+
+
+static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
+  FuncState *fs = ls->fs;
+  int extra = nvars - nexps;
+  if (hasmultret(e->k)) {
+    extra++;  /* includes call itself */
+    if (extra < 0) extra = 0;
+    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */
+    if (extra > 1) luaK_reserveregs(fs, extra-1);
+  }
+  else {
+    if (e->k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
+    if (extra > 0) {
+      int reg = fs->freereg;
+      luaK_reserveregs(fs, extra);
+      luaK_nil(fs, reg, extra);
+    }
+  }
+}
+
+
+static void enterlevel (LexState *ls) {
+  lua_State *L = ls->L;
+  ++L->nCcalls;
+  checklimit(ls->fs, L->nCcalls, LUAI_MAXCCALLS, "C levels");
+}
+
+
+#define leavelevel(ls)	((ls)->L->nCcalls--)
+
+
+static void closegoto (LexState *ls, int g, Labeldesc *label) {
+  int i;
+  FuncState *fs = ls->fs;
+  Labellist *gl = &ls->dyd->gt;
+  Labeldesc *gt = &gl->arr[g];
+  lua_assert(luaS_eqstr(gt->name, label->name));
+  if (gt->nactvar < label->nactvar) {
+    TString *vname = getlocvar(fs, gt->nactvar)->varname;
+    const char *msg = luaO_pushfstring(ls->L,
+      "<goto %s> at line %d jumps into the scope of local " LUA_QS,
+      getstr(gt->name), gt->line, getstr(vname));
+    semerror(ls, msg);
+  }
+  luaK_patchlist(fs, gt->pc, label->pc);
+  /* remove goto from pending list */
+  for (i = g; i < gl->n - 1; i++)
+    gl->arr[i] = gl->arr[i + 1];
+  gl->n--;
+}
+
+
+/*
+** try to close a goto with existing labels; this solves backward jumps
+*/
+static int findlabel (LexState *ls, int g) {
+  int i;
+  BlockCnt *bl = ls->fs->bl;
+  Dyndata *dyd = ls->dyd;
+  Labeldesc *gt = &dyd->gt.arr[g];
+  /* check labels in current block for a match */
+  for (i = bl->firstlabel; i < dyd->label.n; i++) {
+    Labeldesc *lb = &dyd->label.arr[i];
+    if (luaS_eqstr(lb->name, gt->name)) {  /* correct label? */
+      if (gt->nactvar > lb->nactvar &&
+          (bl->upval || dyd->label.n > bl->firstlabel))
+        luaK_patchclose(ls->fs, gt->pc, lb->nactvar);
+      closegoto(ls, g, lb);  /* close it */
+      return 1;
+    }
+  }
+  return 0;  /* label not found; cannot close goto */
+}
+
+
+static int newlabelentry (LexState *ls, Labellist *l, TString *name,
+                          int line, int pc) {
+  int n = l->n;
+  luaM_growvector(ls->L, l->arr, n, l->size,
+                  Labeldesc, SHRT_MAX, "labels/gotos");
+  l->arr[n].name = name;
+  l->arr[n].line = line;
+  l->arr[n].nactvar = ls->fs->nactvar;
+  l->arr[n].pc = pc;
+  l->n++;
+  return n;
+}
+
+
+/*
+** check whether new label 'lb' matches any pending gotos in current
+** block; solves forward jumps
+*/
+static void findgotos (LexState *ls, Labeldesc *lb) {
+  Labellist *gl = &ls->dyd->gt;
+  int i = ls->fs->bl->firstgoto;
+  while (i < gl->n) {
+    if (luaS_eqstr(gl->arr[i].name, lb->name))
+      closegoto(ls, i, lb);
+    else
+      i++;
+  }
+}
+
+
+/*
+** "export" pending gotos to outer level, to check them against
+** outer labels; if the block being exited has upvalues, and
+** the goto exits the scope of any variable (which can be the
+** upvalue), close those variables being exited.
+*/
+static void movegotosout (FuncState *fs, BlockCnt *bl) {
+  int i = bl->firstgoto;
+  Labellist *gl = &fs->ls->dyd->gt;
+  /* correct pending gotos to current block and try to close it
+     with visible labels */
+  while (i < gl->n) {
+    Labeldesc *gt = &gl->arr[i];
+    if (gt->nactvar > bl->nactvar) {
+      if (bl->upval)
+        luaK_patchclose(fs, gt->pc, bl->nactvar);
+      gt->nactvar = bl->nactvar;
+    }
+    if (!findlabel(fs->ls, i))
+      i++;  /* move to next one */
+  }
+}
+
+
+static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {
+  bl->isloop = isloop;
+  bl->nactvar = fs->nactvar;
+  bl->firstlabel = fs->ls->dyd->label.n;
+  bl->firstgoto = fs->ls->dyd->gt.n;
+  bl->upval = 0;
+  bl->previous = fs->bl;
+  fs->bl = bl;
+  lua_assert(fs->freereg == fs->nactvar);
+}
+
+
+/*
+** create a label named "break" to resolve break statements
+*/
+static void breaklabel (LexState *ls) {
+  TString *n = luaS_new(ls->L, "break");
+  int l = newlabelentry(ls, &ls->dyd->label, n, 0, ls->fs->pc);
+  findgotos(ls, &ls->dyd->label.arr[l]);
+}
+
+/*
+** generates an error for an undefined 'goto'; choose appropriate
+** message when label name is a reserved word (which can only be 'break')
+*/
+static l_noret undefgoto (LexState *ls, Labeldesc *gt) {
+  const char *msg = isreserved(gt->name)
+                    ? "<%s> at line %d not inside a loop"
+                    : "no visible label " LUA_QS " for <goto> at line %d";
+  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);
+  semerror(ls, msg);
+}
+
+
+static void leaveblock (FuncState *fs) {
+  BlockCnt *bl = fs->bl;
+  LexState *ls = fs->ls;
+  if (bl->previous && bl->upval) {
+    /* create a 'jump to here' to close upvalues */
+    int j = luaK_jump(fs);
+    luaK_patchclose(fs, j, bl->nactvar);
+    luaK_patchtohere(fs, j);
+  }
+  if (bl->isloop)
+    breaklabel(ls);  /* close pending breaks */
+  fs->bl = bl->previous;
+  removevars(fs, bl->nactvar);
+  lua_assert(bl->nactvar == fs->nactvar);
+  fs->freereg = fs->nactvar;  /* free registers */
+  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */
+  if (bl->previous)  /* inner block? */
+    movegotosout(fs, bl);  /* update pending gotos to outer block */
+  else if (bl->firstgoto < ls->dyd->gt.n)  /* pending gotos in outer block? */
+    undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */
+}
+
+
+/*
+** adds a new prototype into list of prototypes
+*/
+static Proto *addprototype (LexState *ls) {
+  Proto *clp;
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;  /* prototype of current function */
+  if (fs->np >= f->sizep) {
+    int oldsize = f->sizep;
+    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, "functions");
+    while (oldsize < f->sizep) f->p[oldsize++] = NULL;
+  }
+  f->p[fs->np++] = clp = luaF_newproto(L);
+  luaC_objbarrier(L, f, clp);
+  return clp;
+}
+
+
+/*
+** codes instruction to create new closure in parent function
+*/
+static void codeclosure (LexState *ls, expdesc *v) {
+  FuncState *fs = ls->fs->prev;
+  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));
+  luaK_exp2nextreg(fs, v);  /* fix it at stack top (for GC) */
+}
+
+
+static void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {
+  lua_State *L = ls->L;
+  Proto *f;
+  fs->prev = ls->fs;  /* linked list of funcstates */
+  fs->ls = ls;
+  ls->fs = fs;
+  fs->pc = 0;
+  fs->lasttarget = 0;
+  fs->jpc = NO_JUMP;
+  fs->freereg = 0;
+  fs->nk = 0;
+  fs->np = 0;
+  fs->nups = 0;
+  fs->nlocvars = 0;
+  fs->nactvar = 0;
+  fs->firstlocal = ls->dyd->actvar.n;
+  fs->bl = NULL;
+  f = fs->f;
+  f->source = ls->source;
+  f->maxstacksize = 2;  /* registers 0/1 are always valid */
+  fs->h = luaH_new(L);
+  /* anchor table of constants (to avoid being collected) */
+  sethvalue2s(L, L->top, fs->h);
+  incr_top(L);
+  enterblock(fs, bl, 0);
+}
+
+
+static void close_func (LexState *ls) {
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  luaK_ret(fs, 0, 0);  /* final return */
+  leaveblock(fs);
+  luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);
+  f->sizecode = fs->pc;
+  luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);
+  f->sizelineinfo = fs->pc;
+  luaM_reallocvector(L, f->k, f->sizek, fs->nk, TValue);
+  f->sizek = fs->nk;
+  luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);
+  f->sizep = fs->np;
+  luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);
+  f->sizelocvars = fs->nlocvars;
+  luaM_reallocvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);
+  f->sizeupvalues = fs->nups;
+  lua_assert(fs->bl == NULL);
+  ls->fs = fs->prev;
+  /* last token read was anchored in defunct function; must re-anchor it */
+  anchor_token(ls);
+  L->top--;  /* pop table of constants */
+  luaC_checkGC(L);
+}
+
+
+
+/*============================================================*/
+/* GRAMMAR RULES */
+/*============================================================*/
+
+
+/*
+** check whether current token is in the follow set of a block.
+** 'until' closes syntactical blocks, but do not close scope,
+** so it handled in separate.
+*/
+static int block_follow (LexState *ls, int withuntil) {
+  switch (ls->t.token) {
+    case TK_ELSE: case TK_ELSEIF:
+    case TK_END: case TK_EOS:
+      return 1;
+    case TK_UNTIL: return withuntil;
+    default: return 0;
+  }
+}
+
+
+static void statlist (LexState *ls) {
+  /* statlist -> { stat [`;'] } */
+  while (!block_follow(ls, 1)) {
+    if (ls->t.token == TK_RETURN) {
+      statement(ls);
+      return;  /* 'return' must be last statement */
+    }
+    statement(ls);
+  }
+}
+
+
+static void fieldsel (LexState *ls, expdesc *v) {
+  /* fieldsel -> ['.' | ':'] NAME */
+  FuncState *fs = ls->fs;
+  expdesc key;
+  luaK_exp2anyregup(fs, v);
+  luaX_next(ls);  /* skip the dot or colon */
+  checkname(ls, &key);
+  luaK_indexed(fs, v, &key);
+}
+
+
+static void yindex (LexState *ls, expdesc *v) {
+  /* index -> '[' expr ']' */
+  luaX_next(ls);  /* skip the '[' */
+  expr(ls, v);
+  luaK_exp2val(ls->fs, v);
+  checknext(ls, ']');
+}
+
+
+/*
+** {======================================================================
+** Rules for Constructors
+** =======================================================================
+*/
+
+
+struct ConsControl {
+  expdesc v;  /* last list item read */
+  expdesc *t;  /* table descriptor */
+  int nh;  /* total number of `record' elements */
+  int na;  /* total number of array elements */
+  int tostore;  /* number of array elements pending to be stored */
+};
+
+
+static void recfield (LexState *ls, struct ConsControl *cc) {
+  /* recfield -> (NAME | `['exp1`]') = exp1 */
+  FuncState *fs = ls->fs;
+  int reg = ls->fs->freereg;
+  expdesc key, val;
+  int rkkey;
+  if (ls->t.token == TK_NAME) {
+    checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
+    checkname(ls, &key);
+  }
+  else  /* ls->t.token == '[' */
+    yindex(ls, &key);
+  cc->nh++;
+  checknext(ls, '=');
+  rkkey = luaK_exp2RK(fs, &key);
+  expr(ls, &val);
+  luaK_codeABC(fs, OP_SETTABLE, cc->t->u.info, rkkey, luaK_exp2RK(fs, &val));
+  fs->freereg = reg;  /* free registers */
+}
+
+
+static void closelistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->v.k == VVOID) return;  /* there is no list item */
+  luaK_exp2nextreg(fs, &cc->v);
+  cc->v.k = VVOID;
+  if (cc->tostore == LFIELDS_PER_FLUSH) {
+    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */
+    cc->tostore = 0;  /* no more items pending */
+  }
+}
+
+
+static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->tostore == 0) return;
+  if (hasmultret(cc->v.k)) {
+    luaK_setmultret(fs, &cc->v);
+    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
+    cc->na--;  /* do not count last expression (unknown number of elements) */
+  }
+  else {
+    if (cc->v.k != VVOID)
+      luaK_exp2nextreg(fs, &cc->v);
+    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
+  }
+}
+
+
+static void listfield (LexState *ls, struct ConsControl *cc) {
+  /* listfield -> exp */
+  expr(ls, &cc->v);
+  checklimit(ls->fs, cc->na, MAX_INT, "items in a constructor");
+  cc->na++;
+  cc->tostore++;
+}
+
+
+static void field (LexState *ls, struct ConsControl *cc) {
+  /* field -> listfield | recfield */
+  switch(ls->t.token) {
+    case TK_NAME: {  /* may be 'listfield' or 'recfield' */
+      if (luaX_lookahead(ls) != '=')  /* expression? */
+        listfield(ls, cc);
+      else
+        recfield(ls, cc);
+      break;
+    }
+    case '[': {
+      recfield(ls, cc);
+      break;
+    }
+    default: {
+      listfield(ls, cc);
+      break;
+    }
+  }
+}
+
+
+static void constructor (LexState *ls, expdesc *t) {
+  /* constructor -> '{' [ field { sep field } [sep] ] '}'
+     sep -> ',' | ';' */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
+  struct ConsControl cc;
+  cc.na = cc.nh = cc.tostore = 0;
+  cc.t = t;
+  init_exp(t, VRELOCABLE, pc);
+  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */
+  luaK_exp2nextreg(ls->fs, t);  /* fix it at stack top */
+  checknext(ls, '{');
+  do {
+    lua_assert(cc.v.k == VVOID || cc.tostore > 0);
+    if (ls->t.token == '}') break;
+    closelistfield(fs, &cc);
+    field(ls, &cc);
+  } while (testnext(ls, ',') || testnext(ls, ';'));
+  check_match(ls, '}', '{', line);
+  lastlistfield(fs, &cc);
+  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
+  SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
+}
+
+/* }====================================================================== */
+
+
+
+static void parlist (LexState *ls) {
+  /* parlist -> [ param { `,' param } ] */
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int nparams = 0;
+  f->is_vararg = 0;
+  if (ls->t.token != ')') {  /* is `parlist' not empty? */
+    do {
+      switch (ls->t.token) {
+        case TK_NAME: {  /* param -> NAME */
+          new_localvar(ls, str_checkname(ls));
+          nparams++;
+          break;
+        }
+        case TK_DOTS: {  /* param -> `...' */
+          luaX_next(ls);
+          f->is_vararg = 1;
+          break;
+        }
+        default: luaX_syntaxerror(ls, "<name> or " LUA_QL("...") " expected");
+      }
+    } while (!f->is_vararg && testnext(ls, ','));
+  }
+  adjustlocalvars(ls, nparams);
+  f->numparams = cast_byte(fs->nactvar);
+  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */
+}
+
+
+static void body (LexState *ls, expdesc *e, int ismethod, int line) {
+  /* body ->  `(' parlist `)' block END */
+  FuncState new_fs;
+  BlockCnt bl;
+  new_fs.f = addprototype(ls);
+  new_fs.f->linedefined = line;
+  open_func(ls, &new_fs, &bl);
+  checknext(ls, '(');
+  if (ismethod) {
+    new_localvarliteral(ls, "self");  /* create 'self' parameter */
+    adjustlocalvars(ls, 1);
+  }
+  parlist(ls);
+  checknext(ls, ')');
+  statlist(ls);
+  new_fs.f->lastlinedefined = ls->linenumber;
+  check_match(ls, TK_END, TK_FUNCTION, line);
+  codeclosure(ls, e);
+  close_func(ls);
+}
+
+
+static int explist (LexState *ls, expdesc *v) {
+  /* explist -> expr { `,' expr } */
+  int n = 1;  /* at least one expression */
+  expr(ls, v);
+  while (testnext(ls, ',')) {
+    luaK_exp2nextreg(ls->fs, v);
+    expr(ls, v);
+    n++;
+  }
+  return n;
+}
+
+
+static void funcargs (LexState *ls, expdesc *f, int line) {
+  FuncState *fs = ls->fs;
+  expdesc args;
+  int base, nparams;
+  switch (ls->t.token) {
+    case '(': {  /* funcargs -> `(' [ explist ] `)' */
+      luaX_next(ls);
+      if (ls->t.token == ')')  /* arg list is empty? */
+        args.k = VVOID;
+      else {
+        explist(ls, &args);
+        luaK_setmultret(fs, &args);
+      }
+      check_match(ls, ')', '(', line);
+      break;
+    }
+    case '{': {  /* funcargs -> constructor */
+      constructor(ls, &args);
+      break;
+    }
+    case TK_STRING: {  /* funcargs -> STRING */
+      codestring(ls, &args, ls->t.seminfo.ts);
+      luaX_next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    default: {
+      luaX_syntaxerror(ls, "function arguments expected");
+    }
+  }
+  lua_assert(f->k == VNONRELOC);
+  base = f->u.info;  /* base register for call */
+  if (hasmultret(args.k))
+    nparams = LUA_MULTRET;  /* open call */
+  else {
+    if (args.k != VVOID)
+      luaK_exp2nextreg(fs, &args);  /* close last argument */
+    nparams = fs->freereg - (base+1);
+  }
+  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
+  luaK_fixline(fs, line);
+  fs->freereg = base+1;  /* call remove function and arguments and leaves
+                            (unless changed) one result */
+}
+
+
+
+
+/*
+** {======================================================================
+** Expression parsing
+** =======================================================================
+*/
+
+
+static void primaryexp (LexState *ls, expdesc *v) {
+  /* primaryexp -> NAME | '(' expr ')' */
+  switch (ls->t.token) {
+    case '(': {
+      int line = ls->linenumber;
+      luaX_next(ls);
+      expr(ls, v);
+      check_match(ls, ')', '(', line);
+      luaK_dischargevars(ls->fs, v);
+      return;
+    }
+    case TK_NAME: {
+      singlevar(ls, v);
+      return;
+    }
+    default: {
+      luaX_syntaxerror(ls, "unexpected symbol");
+    }
+  }
+}
+
+
+static void suffixedexp (LexState *ls, expdesc *v) {
+  /* suffixedexp ->
+       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  primaryexp(ls, v);
+  for (;;) {
+    switch (ls->t.token) {
+      case '.': {  /* fieldsel */
+        fieldsel(ls, v);
+        break;
+      }
+      case '[': {  /* `[' exp1 `]' */
+        expdesc key;
+        luaK_exp2anyregup(fs, v);
+        yindex(ls, &key);
+        luaK_indexed(fs, v, &key);
+        break;
+      }
+      case ':': {  /* `:' NAME funcargs */
+        expdesc key;
+        luaX_next(ls);
+        checkname(ls, &key);
+        luaK_self(fs, v, &key);
+        funcargs(ls, v, line);
+        break;
+      }
+      case '(': case TK_STRING: case '{': {  /* funcargs */
+        luaK_exp2nextreg(fs, v);
+        funcargs(ls, v, line);
+        break;
+      }
+      default: return;
+    }
+  }
+}
+
+
+static void simpleexp (LexState *ls, expdesc *v) {
+  /* simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |
+                  constructor | FUNCTION body | suffixedexp */
+  switch (ls->t.token) {
+    case TK_NUMBER: {
+      init_exp(v, VKNUM, 0);
+      v->u.nval = ls->t.seminfo.r;
+      break;
+    }
+    case TK_STRING: {
+      codestring(ls, v, ls->t.seminfo.ts);
+      break;
+    }
+    case TK_NIL: {
+      init_exp(v, VNIL, 0);
+      break;
+    }
+    case TK_TRUE: {
+      init_exp(v, VTRUE, 0);
+      break;
+    }
+    case TK_FALSE: {
+      init_exp(v, VFALSE, 0);
+      break;
+    }
+    case TK_DOTS: {  /* vararg */
+      FuncState *fs = ls->fs;
+      check_condition(ls, fs->f->is_vararg,
+                      "cannot use " LUA_QL("...") " outside a vararg function");
+      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
+      break;
+    }
+    case '{': {  /* constructor */
+      constructor(ls, v);
+      return;
+    }
+    case TK_FUNCTION: {
+      luaX_next(ls);
+      body(ls, v, 0, ls->linenumber);
+      return;
+    }
+    default: {
+      suffixedexp(ls, v);
+      return;
+    }
+  }
+  luaX_next(ls);
+}
+
+
+static UnOpr getunopr (int op) {
+  switch (op) {
+    case TK_NOT: return OPR_NOT;
+    case '-': return OPR_MINUS;
+    case '#': return OPR_LEN;
+    default: return OPR_NOUNOPR;
+  }
+}
+
+
+static BinOpr getbinopr (int op) {
+  switch (op) {
+    case '+': return OPR_ADD;
+    case '-': return OPR_SUB;
+    case '*': return OPR_MUL;
+    case '/': return OPR_DIV;
+    case '%': return OPR_MOD;
+    case '^': return OPR_POW;
+    case TK_CONCAT: return OPR_CONCAT;
+    case TK_NE: return OPR_NE;
+    case TK_EQ: return OPR_EQ;
+    case '<': return OPR_LT;
+    case TK_LE: return OPR_LE;
+    case '>': return OPR_GT;
+    case TK_GE: return OPR_GE;
+    case TK_AND: return OPR_AND;
+    case TK_OR: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static const struct {
+  lu_byte left;  /* left priority for each binary operator */
+  lu_byte right; /* right priority */
+} priority[] = {  /* ORDER OPR */
+   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `*' `/' `%' */
+   {10, 9}, {5, 4},                 /* ^, .. (right associative) */
+   {3, 3}, {3, 3}, {3, 3},          /* ==, <, <= */
+   {3, 3}, {3, 3}, {3, 3},          /* ~=, >, >= */
+   {2, 2}, {1, 1}                   /* and, or */
+};
+
+#define UNARY_PRIORITY	8  /* priority for unary operators */
+
+
+/*
+** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
+** where `binop' is any binary operator with a priority higher than `limit'
+*/
+static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
+  BinOpr op;
+  UnOpr uop;
+  enterlevel(ls);
+  uop = getunopr(ls->t.token);
+  if (uop != OPR_NOUNOPR) {
+    int line = ls->linenumber;
+    luaX_next(ls);
+    subexpr(ls, v, UNARY_PRIORITY);
+    luaK_prefix(ls->fs, uop, v, line);
+  }
+  else simpleexp(ls, v);
+  /* expand while operators have priorities higher than `limit' */
+  op = getbinopr(ls->t.token);
+  while (op != OPR_NOBINOPR && priority[op].left > limit) {
+    expdesc v2;
+    BinOpr nextop;
+    int line = ls->linenumber;
+    luaX_next(ls);
+    luaK_infix(ls->fs, op, v);
+    /* read sub-expression with higher priority */
+    nextop = subexpr(ls, &v2, priority[op].right);
+    luaK_posfix(ls->fs, op, v, &v2, line);
+    op = nextop;
+  }
+  leavelevel(ls);
+  return op;  /* return first untreated operator */
+}
+
+
+static void expr (LexState *ls, expdesc *v) {
+  subexpr(ls, v, 0);
+}
+
+/* }==================================================================== */
+
+
+
+/*
+** {======================================================================
+** Rules for Statements
+** =======================================================================
+*/
+
+
+static void block (LexState *ls) {
+  /* block -> statlist */
+  FuncState *fs = ls->fs;
+  BlockCnt bl;
+  enterblock(fs, &bl, 0);
+  statlist(ls);
+  leaveblock(fs);
+}
+
+
+/*
+** structure to chain all variables in the left-hand side of an
+** assignment
+*/
+struct LHS_assign {
+  struct LHS_assign *prev;
+  expdesc v;  /* variable (global, local, upvalue, or indexed) */
+};
+
+
+/*
+** check whether, in an assignment to an upvalue/local variable, the
+** upvalue/local variable is begin used in a previous assignment to a
+** table. If so, save original upvalue/local value in a safe place and
+** use this safe copy in the previous assignment.
+*/
+static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
+  FuncState *fs = ls->fs;
+  int extra = fs->freereg;  /* eventual position to save local variable */
+  int conflict = 0;
+  for (; lh; lh = lh->prev) {  /* check all previous assignments */
+    if (lh->v.k == VINDEXED) {  /* assigning to a table? */
+      /* table is the upvalue/local being assigned now? */
+      if (lh->v.u.ind.vt == v->k && lh->v.u.ind.t == v->u.info) {
+        conflict = 1;
+        lh->v.u.ind.vt = VLOCAL;
+        lh->v.u.ind.t = extra;  /* previous assignment will use safe copy */
+      }
+      /* index is the local being assigned? (index cannot be upvalue) */
+      if (v->k == VLOCAL && lh->v.u.ind.idx == v->u.info) {
+        conflict = 1;
+        lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */
+      }
+    }
+  }
+  if (conflict) {
+    /* copy upvalue/local value to a temporary (in position 'extra') */
+    OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
+    luaK_codeABC(fs, op, extra, v->u.info, 0);
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
+  expdesc e;
+  check_condition(ls, vkisvar(lh->v.k), "syntax error");
+  if (testnext(ls, ',')) {  /* assignment -> ',' suffixedexp assignment */
+    struct LHS_assign nv;
+    nv.prev = lh;
+    suffixedexp(ls, &nv.v);
+    if (nv.v.k != VINDEXED)
+      check_conflict(ls, lh, &nv.v);
+    checklimit(ls->fs, nvars + ls->L->nCcalls, LUAI_MAXCCALLS,
+                    "C levels");
+    assignment(ls, &nv, nvars+1);
+  }
+  else {  /* assignment -> `=' explist */
+    int nexps;
+    checknext(ls, '=');
+    nexps = explist(ls, &e);
+    if (nexps != nvars) {
+      adjust_assign(ls, nvars, nexps, &e);
+      if (nexps > nvars)
+        ls->fs->freereg -= nexps - nvars;  /* remove extra values */
+    }
+    else {
+      luaK_setoneret(ls->fs, &e);  /* close last expression */
+      luaK_storevar(ls->fs, &lh->v, &e);
+      return;  /* avoid default */
+    }
+  }
+  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
+  luaK_storevar(ls->fs, &lh->v, &e);
+}
+
+
+static int cond (LexState *ls) {
+  /* cond -> exp */
+  expdesc v;
+  expr(ls, &v);  /* read condition */
+  if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */
+  luaK_goiftrue(ls->fs, &v);
+  return v.f;
+}
+
+
+static void gotostat (LexState *ls, int pc) {
+  int line = ls->linenumber;
+  TString *label;
+  int g;
+  if (testnext(ls, TK_GOTO))
+    label = str_checkname(ls);
+  else {
+    luaX_next(ls);  /* skip break */
+    label = luaS_new(ls->L, "break");
+  }
+  g = newlabelentry(ls, &ls->dyd->gt, label, line, pc);
+  findlabel(ls, g);  /* close it if label already defined */
+}
+
+
+/* check for repeated labels on the same block */
+static void checkrepeated (FuncState *fs, Labellist *ll, TString *label) {
+  int i;
+  for (i = fs->bl->firstlabel; i < ll->n; i++) {
+    if (luaS_eqstr(label, ll->arr[i].name)) {
+      const char *msg = luaO_pushfstring(fs->ls->L,
+                          "label " LUA_QS " already defined on line %d",
+                          getstr(label), ll->arr[i].line);
+      semerror(fs->ls, msg);
+    }
+  }
+}
+
+
+/* skip no-op statements */
+static void skipnoopstat (LexState *ls) {
+  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)
+    statement(ls);
+}
+
+
+static void labelstat (LexState *ls, TString *label, int line) {
+  /* label -> '::' NAME '::' */
+  FuncState *fs = ls->fs;
+  Labellist *ll = &ls->dyd->label;
+  int l;  /* index of new label being created */
+  checkrepeated(fs, ll, label);  /* check for repeated labels */
+  checknext(ls, TK_DBCOLON);  /* skip double colon */
+  /* create new entry for this label */
+  l = newlabelentry(ls, ll, label, line, fs->pc);
+  skipnoopstat(ls);  /* skip other no-op statements */
+  if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */
+    /* assume that locals are already out of scope */
+    ll->arr[l].nactvar = fs->bl->nactvar;
+  }
+  findgotos(ls, &ll->arr[l]);
+}
+
+
+static void whilestat (LexState *ls, int line) {
+  /* whilestat -> WHILE cond DO block END */
+  FuncState *fs = ls->fs;
+  int whileinit;
+  int condexit;
+  BlockCnt bl;
+  luaX_next(ls);  /* skip WHILE */
+  whileinit = luaK_getlabel(fs);
+  condexit = cond(ls);
+  enterblock(fs, &bl, 1);
+  checknext(ls, TK_DO);
+  block(ls);
+  luaK_jumpto(fs, whileinit);
+  check_match(ls, TK_END, TK_WHILE, line);
+  leaveblock(fs);
+  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
+}
+
+
+static void repeatstat (LexState *ls, int line) {
+  /* repeatstat -> REPEAT block UNTIL cond */
+  int condexit;
+  FuncState *fs = ls->fs;
+  int repeat_init = luaK_getlabel(fs);
+  BlockCnt bl1, bl2;
+  enterblock(fs, &bl1, 1);  /* loop block */
+  enterblock(fs, &bl2, 0);  /* scope block */
+  luaX_next(ls);  /* skip REPEAT */
+  statlist(ls);
+  check_match(ls, TK_UNTIL, TK_REPEAT, line);
+  condexit = cond(ls);  /* read condition (inside scope block) */
+  if (bl2.upval)  /* upvalues? */
+    luaK_patchclose(fs, condexit, bl2.nactvar);
+  leaveblock(fs);  /* finish scope */
+  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */
+  leaveblock(fs);  /* finish loop */
+}
+
+
+static int exp1 (LexState *ls) {
+  expdesc e;
+  int reg;
+  expr(ls, &e);
+  luaK_exp2nextreg(ls->fs, &e);
+  lua_assert(e.k == VNONRELOC);
+  reg = e.u.info;
+  return reg;
+}
+
+
+static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
+  /* forbody -> DO block */
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  int prep, endfor;
+  adjustlocalvars(ls, 3);  /* control variables */
+  checknext(ls, TK_DO);
+  prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
+  enterblock(fs, &bl, 0);  /* scope for declared variables */
+  adjustlocalvars(ls, nvars);
+  luaK_reserveregs(fs, nvars);
+  block(ls);
+  leaveblock(fs);  /* end of scope for declared variables */
+  luaK_patchtohere(fs, prep);
+  if (isnum)  /* numeric for? */
+    endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);
+  else {  /* generic for */
+    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);
+    luaK_fixline(fs, line);
+    endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);
+  }
+  luaK_patchlist(fs, endfor, prep + 1);
+  luaK_fixline(fs, line);
+}
+
+
+static void fornum (LexState *ls, TString *varname, int line) {
+  /* fornum -> NAME = exp1,exp1[,exp1] forbody */
+  FuncState *fs = ls->fs;
+  int base = fs->freereg;
+  new_localvarliteral(ls, "(for index)");
+  new_localvarliteral(ls, "(for limit)");
+  new_localvarliteral(ls, "(for step)");
+  new_localvar(ls, varname);
+  checknext(ls, '=');
+  exp1(ls);  /* initial value */
+  checknext(ls, ',');
+  exp1(ls);  /* limit */
+  if (testnext(ls, ','))
+    exp1(ls);  /* optional step */
+  else {  /* default step = 1 */
+    luaK_codek(fs, fs->freereg, luaK_numberK(fs, 1));
+    luaK_reserveregs(fs, 1);
+  }
+  forbody(ls, base, line, 1, 1);
+}
+
+
+static void forlist (LexState *ls, TString *indexname) {
+  /* forlist -> NAME {,NAME} IN explist forbody */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int nvars = 4;  /* gen, state, control, plus at least one declared var */
+  int line;
+  int base = fs->freereg;
+  /* create control variables */
+  new_localvarliteral(ls, "(for generator)");
+  new_localvarliteral(ls, "(for state)");
+  new_localvarliteral(ls, "(for control)");
+  /* create declared variables */
+  new_localvar(ls, indexname);
+  while (testnext(ls, ',')) {
+    new_localvar(ls, str_checkname(ls));
+    nvars++;
+  }
+  checknext(ls, TK_IN);
+  line = ls->linenumber;
+  adjust_assign(ls, 3, explist(ls, &e), &e);
+  luaK_checkstack(fs, 3);  /* extra space to call generator */
+  forbody(ls, base, line, nvars - 3, 0);
+}
+
+
+static void forstat (LexState *ls, int line) {
+  /* forstat -> FOR (fornum | forlist) END */
+  FuncState *fs = ls->fs;
+  TString *varname;
+  BlockCnt bl;
+  enterblock(fs, &bl, 1);  /* scope for loop and control variables */
+  luaX_next(ls);  /* skip `for' */
+  varname = str_checkname(ls);  /* first variable name */
+  switch (ls->t.token) {
+    case '=': fornum(ls, varname, line); break;
+    case ',': case TK_IN: forlist(ls, varname); break;
+    default: luaX_syntaxerror(ls, LUA_QL("=") " or " LUA_QL("in") " expected");
+  }
+  check_match(ls, TK_END, TK_FOR, line);
+  leaveblock(fs);  /* loop scope (`break' jumps to this point) */
+}
+
+
+static void test_then_block (LexState *ls, int *escapelist) {
+  /* test_then_block -> [IF | ELSEIF] cond THEN block */
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  expdesc v;
+  int jf;  /* instruction to skip 'then' code (if condition is false) */
+  luaX_next(ls);  /* skip IF or ELSEIF */
+  expr(ls, &v);  /* read condition */
+  checknext(ls, TK_THEN);
+  if (ls->t.token == TK_GOTO || ls->t.token == TK_BREAK) {
+    luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */
+    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */
+    gotostat(ls, v.t);  /* handle goto/break */
+    skipnoopstat(ls);  /* skip other no-op statements */
+    if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */
+      leaveblock(fs);
+      return;  /* and that is it */
+    }
+    else  /* must skip over 'then' part if condition is false */
+      jf = luaK_jump(fs);
+  }
+  else {  /* regular case (not goto/break) */
+    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */
+    enterblock(fs, &bl, 0);
+    jf = v.f;
+  }
+  statlist(ls);  /* `then' part */
+  leaveblock(fs);
+  if (ls->t.token == TK_ELSE ||
+      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */
+    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */
+  luaK_patchtohere(fs, jf);
+}
+
+
+static void ifstat (LexState *ls, int line) {
+  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
+  FuncState *fs = ls->fs;
+  int escapelist = NO_JUMP;  /* exit list for finished parts */
+  test_then_block(ls, &escapelist);  /* IF cond THEN block */
+  while (ls->t.token == TK_ELSEIF)
+    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */
+  if (testnext(ls, TK_ELSE))
+    block(ls);  /* `else' part */
+  check_match(ls, TK_END, TK_IF, line);
+  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */
+}
+
+
+static void localfunc (LexState *ls) {
+  expdesc b;
+  FuncState *fs = ls->fs;
+  new_localvar(ls, str_checkname(ls));  /* new local variable */
+  adjustlocalvars(ls, 1);  /* enter its scope */
+  body(ls, &b, 0, ls->linenumber);  /* function created in next register */
+  /* debug information will only see the variable after this point! */
+  getlocvar(fs, b.u.info)->startpc = fs->pc;
+}
+
+
+static void localstat (LexState *ls) {
+  /* stat -> LOCAL NAME {`,' NAME} [`=' explist] */
+  int nvars = 0;
+  int nexps;
+  expdesc e;
+  do {
+    new_localvar(ls, str_checkname(ls));
+    nvars++;
+  } while (testnext(ls, ','));
+  if (testnext(ls, '='))
+    nexps = explist(ls, &e);
+  else {
+    e.k = VVOID;
+    nexps = 0;
+  }
+  adjust_assign(ls, nvars, nexps, &e);
+  adjustlocalvars(ls, nvars);
+}
+
+
+static int funcname (LexState *ls, expdesc *v) {
+  /* funcname -> NAME {fieldsel} [`:' NAME] */
+  int ismethod = 0;
+  singlevar(ls, v);
+  while (ls->t.token == '.')
+    fieldsel(ls, v);
+  if (ls->t.token == ':') {
+    ismethod = 1;
+    fieldsel(ls, v);
+  }
+  return ismethod;
+}
+
+
+static void funcstat (LexState *ls, int line) {
+  /* funcstat -> FUNCTION funcname body */
+  int ismethod;
+  expdesc v, b;
+  luaX_next(ls);  /* skip FUNCTION */
+  ismethod = funcname(ls, &v);
+  body(ls, &b, ismethod, line);
+  luaK_storevar(ls->fs, &v, &b);
+  luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */
+}
+
+
+static void exprstat (LexState *ls) {
+  /* stat -> func | assignment */
+  FuncState *fs = ls->fs;
+  struct LHS_assign v;
+  suffixedexp(ls, &v.v);
+  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */
+    v.prev = NULL;
+    assignment(ls, &v, 1);
+  }
+  else {  /* stat -> func */
+    check_condition(ls, v.v.k == VCALL, "syntax error");
+    SETARG_C(getcode(fs, &v.v), 1);  /* call statement uses no results */
+  }
+}
+
+
+static void retstat (LexState *ls) {
+  /* stat -> RETURN [explist] [';'] */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int first, nret;  /* registers with returned values */
+  if (block_follow(ls, 1) || ls->t.token == ';')
+    first = nret = 0;  /* return no values */
+  else {
+    nret = explist(ls, &e);  /* optional return values */
+    if (hasmultret(e.k)) {
+      luaK_setmultret(fs, &e);
+      if (e.k == VCALL && nret == 1) {  /* tail call? */
+        SET_OPCODE(getcode(fs,&e), OP_TAILCALL);
+        lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);
+      }
+      first = fs->nactvar;
+      nret = LUA_MULTRET;  /* return all values */
+    }
+    else {
+      if (nret == 1)  /* only one single value? */
+        first = luaK_exp2anyreg(fs, &e);
+      else {
+        luaK_exp2nextreg(fs, &e);  /* values must go to the `stack' */
+        first = fs->nactvar;  /* return all `active' values */
+        lua_assert(nret == fs->freereg - first);
+      }
+    }
+  }
+  luaK_ret(fs, first, nret);
+  testnext(ls, ';');  /* skip optional semicolon */
+}
+
+
+static void statement (LexState *ls) {
+  int line = ls->linenumber;  /* may be needed for error messages */
+  enterlevel(ls);
+  switch (ls->t.token) {
+    case ';': {  /* stat -> ';' (empty statement) */
+      luaX_next(ls);  /* skip ';' */
+      break;
+    }
+    case TK_IF: {  /* stat -> ifstat */
+      ifstat(ls, line);
+      break;
+    }
+    case TK_WHILE: {  /* stat -> whilestat */
+      whilestat(ls, line);
+      break;
+    }
+    case TK_DO: {  /* stat -> DO block END */
+      luaX_next(ls);  /* skip DO */
+      block(ls);
+      check_match(ls, TK_END, TK_DO, line);
+      break;
+    }
+    case TK_FOR: {  /* stat -> forstat */
+      forstat(ls, line);
+      break;
+    }
+    case TK_REPEAT: {  /* stat -> repeatstat */
+      repeatstat(ls, line);
+      break;
+    }
+    case TK_FUNCTION: {  /* stat -> funcstat */
+      funcstat(ls, line);
+      break;
+    }
+    case TK_LOCAL: {  /* stat -> localstat */
+      luaX_next(ls);  /* skip LOCAL */
+      if (testnext(ls, TK_FUNCTION))  /* local function? */
+        localfunc(ls);
+      else
+        localstat(ls);
+      break;
+    }
+    case TK_DBCOLON: {  /* stat -> label */
+      luaX_next(ls);  /* skip double colon */
+      labelstat(ls, str_checkname(ls), line);
+      break;
+    }
+    case TK_RETURN: {  /* stat -> retstat */
+      luaX_next(ls);  /* skip RETURN */
+      retstat(ls);
+      break;
+    }
+    case TK_BREAK:   /* stat -> breakstat */
+    case TK_GOTO: {  /* stat -> 'goto' NAME */
+      gotostat(ls, luaK_jump(ls->fs));
+      break;
+    }
+    default: {  /* stat -> func | assignment */
+      exprstat(ls);
+      break;
+    }
+  }
+  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&
+             ls->fs->freereg >= ls->fs->nactvar);
+  ls->fs->freereg = ls->fs->nactvar;  /* free registers */
+  leavelevel(ls);
+}
+
+/* }====================================================================== */
+
+
+/*
+** compiles the main function, which is a regular vararg function with an
+** upvalue named LUA_ENV
+*/
+static void mainfunc (LexState *ls, FuncState *fs) {
+  BlockCnt bl;
+  expdesc v;
+  open_func(ls, fs, &bl);
+  fs->f->is_vararg = 1;  /* main function is always vararg */
+  init_exp(&v, VLOCAL, 0);  /* create and... */
+  newupvalue(fs, ls->envn, &v);  /* ...set environment upvalue */
+  luaX_next(ls);  /* read first token */
+  statlist(ls);  /* parse main body */
+  check(ls, TK_EOS);
+  close_func(ls);
+}
+
+
+Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                      Dyndata *dyd, const char *name, int firstchar) {
+  LexState lexstate;
+  FuncState funcstate;
+  Closure *cl = luaF_newLclosure(L, 1);  /* create main closure */
+  /* anchor closure (to avoid being collected) */
+  setclLvalue(L, L->top, cl);
+  incr_top(L);
+  funcstate.f = cl->l.p = luaF_newproto(L);
+  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */
+  lexstate.buff = buff;
+  lexstate.dyd = dyd;
+  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
+  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);
+  mainfunc(&lexstate, &funcstate);
+  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);
+  /* all scopes should be correctly finished */
+  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);
+  return cl;  /* it's on the stack too */
+}
+
diff --git a/dep/lualib/lparser.h b/dep/lualib/lparser.h
new file mode 100644
index 0000000..301167d
--- /dev/null
+++ b/dep/lualib/lparser.h
@@ -0,0 +1,119 @@
+/*
+** $Id: lparser.h,v 1.70 2012/05/08 13:53:33 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lparser_h
+#define lparser_h
+
+#include "llimits.h"
+#include "lobject.h"
+#include "lzio.h"
+
+
+/*
+** Expression descriptor
+*/
+
+typedef enum {
+  VVOID,	/* no value */
+  VNIL,
+  VTRUE,
+  VFALSE,
+  VK,		/* info = index of constant in `k' */
+  VKNUM,	/* nval = numerical value */
+  VNONRELOC,	/* info = result register */
+  VLOCAL,	/* info = local register */
+  VUPVAL,       /* info = index of upvalue in 'upvalues' */
+  VINDEXED,	/* t = table register/upvalue; idx = index R/K */
+  VJMP,		/* info = instruction pc */
+  VRELOCABLE,	/* info = instruction pc */
+  VCALL,	/* info = instruction pc */
+  VVARARG	/* info = instruction pc */
+} expkind;
+
+
+#define vkisvar(k)	(VLOCAL <= (k) && (k) <= VINDEXED)
+#define vkisinreg(k)	((k) == VNONRELOC || (k) == VLOCAL)
+
+typedef struct expdesc {
+  expkind k;
+  union {
+    struct {  /* for indexed variables (VINDEXED) */
+      short idx;  /* index (R/K) */
+      lu_byte t;  /* table (register or upvalue) */
+      lu_byte vt;  /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */
+    } ind;
+    int info;  /* for generic use */
+    lua_Number nval;  /* for VKNUM */
+  } u;
+  int t;  /* patch list of `exit when true' */
+  int f;  /* patch list of `exit when false' */
+} expdesc;
+
+
+/* description of active local variable */
+typedef struct Vardesc {
+  short idx;  /* variable index in stack */
+} Vardesc;
+
+
+/* description of pending goto statements and label statements */
+typedef struct Labeldesc {
+  TString *name;  /* label identifier */
+  int pc;  /* position in code */
+  int line;  /* line where it appeared */
+  lu_byte nactvar;  /* local level where it appears in current block */
+} Labeldesc;
+
+
+/* list of labels or gotos */
+typedef struct Labellist {
+  Labeldesc *arr;  /* array */
+  int n;  /* number of entries in use */
+  int size;  /* array size */
+} Labellist;
+
+
+/* dynamic structures used by the parser */
+typedef struct Dyndata {
+  struct {  /* list of active local variables */
+    Vardesc *arr;
+    int n;
+    int size;
+  } actvar;
+  Labellist gt;  /* list of pending gotos */
+  Labellist label;   /* list of active labels */
+} Dyndata;
+
+
+/* control of blocks */
+struct BlockCnt;  /* defined in lparser.c */
+
+
+/* state needed to generate code for a given function */
+typedef struct FuncState {
+  Proto *f;  /* current function header */
+  Table *h;  /* table to find (and reuse) elements in `k' */
+  struct FuncState *prev;  /* enclosing function */
+  struct LexState *ls;  /* lexical state */
+  struct BlockCnt *bl;  /* chain of current blocks */
+  int pc;  /* next position to code (equivalent to `ncode') */
+  int lasttarget;   /* 'label' of last 'jump label' */
+  int jpc;  /* list of pending jumps to `pc' */
+  int nk;  /* number of elements in `k' */
+  int np;  /* number of elements in `p' */
+  int firstlocal;  /* index of first local var (in Dyndata array) */
+  short nlocvars;  /* number of elements in 'f->locvars' */
+  lu_byte nactvar;  /* number of active local variables */
+  lu_byte nups;  /* number of upvalues */
+  lu_byte freereg;  /* first free register */
+} FuncState;
+
+
+LUAI_FUNC Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                                Dyndata *dyd, const char *name, int firstchar);
+
+
+#endif
diff --git a/dep/lualib/lstate.c b/dep/lualib/lstate.c
new file mode 100644
index 0000000..3c00c28
--- /dev/null
+++ b/dep/lualib/lstate.c
@@ -0,0 +1,322 @@
+/*
+** $Id: lstate.c,v 2.98 2012/05/30 12:33:44 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+#include <string.h>
+
+#define lstate_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+#if !defined(LUAI_GCPAUSE)
+#define LUAI_GCPAUSE	200  /* 200% */
+#endif
+
+#if !defined(LUAI_GCMAJOR)
+#define LUAI_GCMAJOR	200  /* 200% */
+#endif
+
+#if !defined(LUAI_GCMUL)
+#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */
+#endif
+
+
+#define MEMERRMSG	"not enough memory"
+
+
+/*
+** a macro to help the creation of a unique random seed when a state is
+** created; the seed is used to randomize hashes.
+*/
+#if !defined(luai_makeseed)
+#include <time.h>
+#define luai_makeseed()		cast(size_t, time(NULL))
+#endif
+
+
+
+/*
+** thread state + extra space
+*/
+typedef struct LX {
+#if defined(LUAI_EXTRASPACE)
+  char buff[LUAI_EXTRASPACE];
+#endif
+  lua_State l;
+} LX;
+
+
+/*
+** Main thread combines a thread state and the global state
+*/
+typedef struct LG {
+  LX l;
+  global_State g;
+} LG;
+
+
+
+#define fromstate(L)	(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))
+
+
+/*
+** Compute an initial seed as random as possible. In ANSI, rely on
+** Address Space Layout Randomization (if present) to increase
+** randomness..
+*/
+#define addbuff(b,p,e) \
+  { size_t t = cast(size_t, e); \
+    memcpy(buff + p, &t, sizeof(t)); p += sizeof(t); }
+
+static unsigned int makeseed (lua_State *L) {
+  char buff[4 * sizeof(size_t)];
+  unsigned int h = luai_makeseed();
+  int p = 0;
+  addbuff(buff, p, L);  /* heap variable */
+  addbuff(buff, p, &h);  /* local variable */
+  addbuff(buff, p, luaO_nilobject);  /* global variable */
+  addbuff(buff, p, &lua_newstate);  /* public function */
+  lua_assert(p == sizeof(buff));
+  return luaS_hash(buff, p, h);
+}
+
+
+/*
+** set GCdebt to a new value keeping the value (totalbytes + GCdebt)
+** invariant
+*/
+void luaE_setdebt (global_State *g, l_mem debt) {
+  g->totalbytes -= (debt - g->GCdebt);
+  g->GCdebt = debt;
+}
+
+
+CallInfo *luaE_extendCI (lua_State *L) {
+  CallInfo *ci = luaM_new(L, CallInfo);
+  lua_assert(L->ci->next == NULL);
+  L->ci->next = ci;
+  ci->previous = L->ci;
+  ci->next = NULL;
+  return ci;
+}
+
+
+void luaE_freeCI (lua_State *L) {
+  CallInfo *ci = L->ci;
+  CallInfo *next = ci->next;
+  ci->next = NULL;
+  while ((ci = next) != NULL) {
+    next = ci->next;
+    luaM_free(L, ci);
+  }
+}
+
+
+static void stack_init (lua_State *L1, lua_State *L) {
+  int i; CallInfo *ci;
+  /* initialize stack array */
+  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE, TValue);
+  L1->stacksize = BASIC_STACK_SIZE;
+  for (i = 0; i < BASIC_STACK_SIZE; i++)
+    setnilvalue(L1->stack + i);  /* erase new stack */
+  L1->top = L1->stack;
+  L1->stack_last = L1->stack + L1->stacksize - EXTRA_STACK;
+  /* initialize first ci */
+  ci = &L1->base_ci;
+  ci->next = ci->previous = NULL;
+  ci->callstatus = 0;
+  ci->func = L1->top;
+  setnilvalue(L1->top++);  /* 'function' entry for this 'ci' */
+  ci->top = L1->top + LUA_MINSTACK;
+  L1->ci = ci;
+}
+
+
+static void freestack (lua_State *L) {
+  if (L->stack == NULL)
+    return;  /* stack not completely built yet */
+  L->ci = &L->base_ci;  /* free the entire 'ci' list */
+  luaE_freeCI(L);
+  luaM_freearray(L, L->stack, L->stacksize);  /* free stack array */
+}
+
+
+/*
+** Create registry table and its predefined values
+*/
+static void init_registry (lua_State *L, global_State *g) {
+  TValue mt;
+  /* create registry */
+  Table *registry = luaH_new(L);
+  sethvalue(L, &g->l_registry, registry);
+  luaH_resize(L, registry, LUA_RIDX_LAST, 0);
+  /* registry[LUA_RIDX_MAINTHREAD] = L */
+  setthvalue(L, &mt, L);
+  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &mt);
+  /* registry[LUA_RIDX_GLOBALS] = table of globals */
+  sethvalue(L, &mt, luaH_new(L));
+  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &mt);
+}
+
+
+/*
+** open parts of the state that may cause memory-allocation errors
+*/
+static void f_luaopen (lua_State *L, void *ud) {
+  global_State *g = G(L);
+  UNUSED(ud);
+  stack_init(L, L);  /* init stack */
+  init_registry(L, g);
+  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
+  luaT_init(L);
+  luaX_init(L);
+  /* pre-create memory-error message */
+  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);
+  luaS_fix(g->memerrmsg);  /* it should never be collected */
+  g->gcrunning = 1;  /* allow gc */
+}
+
+
+/*
+** preinitialize a state with consistent values without allocating
+** any memory (to avoid errors)
+*/
+static void preinit_state (lua_State *L, global_State *g) {
+  G(L) = g;
+  L->stack = NULL;
+  L->ci = NULL;
+  L->stacksize = 0;
+  L->errorJmp = NULL;
+  L->nCcalls = 0;
+  L->hook = NULL;
+  L->hookmask = 0;
+  L->basehookcount = 0;
+  L->allowhook = 1;
+  resethookcount(L);
+  L->openupval = NULL;
+  L->nny = 1;
+  L->status = LUA_OK;
+  L->errfunc = 0;
+}
+
+
+static void close_state (lua_State *L) {
+  global_State *g = G(L);
+  luaF_close(L, L->stack);  /* close all upvalues for this thread */
+  luaC_freeallobjects(L);  /* collect all objects */
+  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);
+  luaZ_freebuffer(L, &g->buff);
+  freestack(L);
+  lua_assert(gettotalbytes(g) == sizeof(LG));
+  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */
+}
+
+
+LUA_API lua_State *lua_newthread (lua_State *L) {
+  lua_State *L1;
+  lua_lock(L);
+  luaC_checkGC(L);
+  L1 = &luaC_newobj(L, LUA_TTHREAD, sizeof(LX), NULL, offsetof(LX, l))->th;
+  setthvalue(L, L->top, L1);
+  api_incr_top(L);
+  preinit_state(L1, G(L));
+  L1->hookmask = L->hookmask;
+  L1->basehookcount = L->basehookcount;
+  L1->hook = L->hook;
+  resethookcount(L1);
+  luai_userstatethread(L, L1);
+  stack_init(L1, L);  /* init stack */
+  lua_unlock(L);
+  return L1;
+}
+
+
+void luaE_freethread (lua_State *L, lua_State *L1) {
+  LX *l = fromstate(L1);
+  luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
+  lua_assert(L1->openupval == NULL);
+  luai_userstatefree(L, L1);
+  freestack(L1);
+  luaM_free(L, l);
+}
+
+
+LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
+  int i;
+  lua_State *L;
+  global_State *g;
+  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
+  if (l == NULL) return NULL;
+  L = &l->l.l;
+  g = &l->g;
+  L->next = NULL;
+  L->tt = LUA_TTHREAD;
+  g->currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);
+  L->marked = luaC_white(g);
+  g->gckind = KGC_NORMAL;
+  preinit_state(L, g);
+  g->frealloc = f;
+  g->ud = ud;
+  g->mainthread = L;
+  g->seed = makeseed(L);
+  g->uvhead.u.l.prev = &g->uvhead;
+  g->uvhead.u.l.next = &g->uvhead;
+  g->gcrunning = 0;  /* no GC while building state */
+  g->GCestimate = 0;
+  g->strt.size = 0;
+  g->strt.nuse = 0;
+  g->strt.hash = NULL;
+  setnilvalue(&g->l_registry);
+  luaZ_initbuffer(L, &g->buff);
+  g->panic = NULL;
+  g->version = lua_version(NULL);
+  g->gcstate = GCSpause;
+  g->allgc = NULL;
+  g->finobj = NULL;
+  g->tobefnz = NULL;
+  g->sweepgc = g->sweepfin = NULL;
+  g->gray = g->grayagain = NULL;
+  g->weak = g->ephemeron = g->allweak = NULL;
+  g->totalbytes = sizeof(LG);
+  g->GCdebt = 0;
+  g->gcpause = LUAI_GCPAUSE;
+  g->gcmajorinc = LUAI_GCMAJOR;
+  g->gcstepmul = LUAI_GCMUL;
+  for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;
+  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
+    /* memory allocation error: free partial state */
+    close_state(L);
+    L = NULL;
+  }
+  else
+    luai_userstateopen(L);
+  return L;
+}
+
+
+LUA_API void lua_close (lua_State *L) {
+  L = G(L)->mainthread;  /* only the main thread can be closed */
+  lua_lock(L);
+  luai_userstateclose(L);
+  close_state(L);
+}
+
+
diff --git a/dep/lualib/lstate.h b/dep/lualib/lstate.h
new file mode 100644
index 0000000..29f810b
--- /dev/null
+++ b/dep/lualib/lstate.h
@@ -0,0 +1,228 @@
+/*
+** $Id: lstate.h,v 2.81 2012/06/08 15:14:04 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstate_h
+#define lstate_h
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "ltm.h"
+#include "lzio.h"
+
+
+/*
+
+** Some notes about garbage-collected objects:  All objects in Lua must
+** be kept somehow accessible until being freed.
+**
+** Lua keeps most objects linked in list g->allgc. The link uses field
+** 'next' of the CommonHeader.
+**
+** Strings are kept in several lists headed by the array g->strt.hash.
+**
+** Open upvalues are not subject to independent garbage collection. They
+** are collected together with their respective threads. Lua keeps a
+** double-linked list with all open upvalues (g->uvhead) so that it can
+** mark objects referred by them. (They are always gray, so they must
+** be remarked in the atomic step. Usually their contents would be marked
+** when traversing the respective threads, but the thread may already be
+** dead, while the upvalue is still accessible through closures.)
+**
+** Objects with finalizers are kept in the list g->finobj.
+**
+** The list g->tobefnz links all objects being finalized.
+
+*/
+
+
+struct lua_longjmp;  /* defined in ldo.c */
+
+
+
+/* extra stack space to handle TM calls and some other extras */
+#define EXTRA_STACK   5
+
+
+#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
+
+
+/* kinds of Garbage Collection */
+#define KGC_NORMAL	0
+#define KGC_EMERGENCY	1	/* gc was forced by an allocation failure */
+#define KGC_GEN		2	/* generational collection */
+
+
+typedef struct stringtable {
+  GCObject **hash;
+  lu_int32 nuse;  /* number of elements */
+  int size;
+} stringtable;
+
+
+/*
+** information about a call
+*/
+typedef struct CallInfo {
+  StkId func;  /* function index in the stack */
+  StkId	top;  /* top for this function */
+  struct CallInfo *previous, *next;  /* dynamic call link */
+  short nresults;  /* expected number of results from this function */
+  lu_byte callstatus;
+  ptrdiff_t extra;
+  union {
+    struct {  /* only for Lua functions */
+      StkId base;  /* base for this function */
+      const Instruction *savedpc;
+    } l;
+    struct {  /* only for C functions */
+      int ctx;  /* context info. in case of yields */
+      lua_CFunction k;  /* continuation in case of yields */
+      ptrdiff_t old_errfunc;
+      lu_byte old_allowhook;
+      lu_byte status;
+    } c;
+  } u;
+} CallInfo;
+
+
+/*
+** Bits in CallInfo status
+*/
+#define CIST_LUA	(1<<0)	/* call is running a Lua function */
+#define CIST_HOOKED	(1<<1)	/* call is running a debug hook */
+#define CIST_REENTRY	(1<<2)	/* call is running on same invocation of
+                                   luaV_execute of previous call */
+#define CIST_YIELDED	(1<<3)	/* call reentered after suspension */
+#define CIST_YPCALL	(1<<4)	/* call is a yieldable protected call */
+#define CIST_STAT	(1<<5)	/* call has an error status (pcall) */
+#define CIST_TAIL	(1<<6)	/* call was tail called */
+#define CIST_HOOKYIELD	(1<<7)	/* last hook called yielded */
+
+
+#define isLua(ci)	((ci)->callstatus & CIST_LUA)
+
+
+/*
+** `global state', shared by all threads of this state
+*/
+typedef struct global_State {
+  lua_Alloc frealloc;  /* function to reallocate memory */
+  void *ud;         /* auxiliary data to `frealloc' */
+  lu_mem totalbytes;  /* number of bytes currently allocated - GCdebt */
+  l_mem GCdebt;  /* bytes allocated not yet compensated by the collector */
+  lu_mem GCmemtrav;  /* memory traversed by the GC */
+  lu_mem GCestimate;  /* an estimate of the non-garbage memory in use */
+  stringtable strt;  /* hash table for strings */
+  TValue l_registry;
+  unsigned int seed;  /* randomized seed for hashes */
+  lu_byte currentwhite;
+  lu_byte gcstate;  /* state of garbage collector */
+  lu_byte gckind;  /* kind of GC running */
+  lu_byte gcrunning;  /* true if GC is running */
+  int sweepstrgc;  /* position of sweep in `strt' */
+  GCObject *allgc;  /* list of all collectable objects */
+  GCObject *finobj;  /* list of collectable objects with finalizers */
+  GCObject **sweepgc;  /* current position of sweep in list 'allgc' */
+  GCObject **sweepfin;  /* current position of sweep in list 'finobj' */
+  GCObject *gray;  /* list of gray objects */
+  GCObject *grayagain;  /* list of objects to be traversed atomically */
+  GCObject *weak;  /* list of tables with weak values */
+  GCObject *ephemeron;  /* list of ephemeron tables (weak keys) */
+  GCObject *allweak;  /* list of all-weak tables */
+  GCObject *tobefnz;  /* list of userdata to be GC */
+  UpVal uvhead;  /* head of double-linked list of all open upvalues */
+  Mbuffer buff;  /* temporary buffer for string concatenation */
+  int gcpause;  /* size of pause between successive GCs */
+  int gcmajorinc;  /* how much to wait for a major GC (only in gen. mode) */
+  int gcstepmul;  /* GC `granularity' */
+  lua_CFunction panic;  /* to be called in unprotected errors */
+  struct lua_State *mainthread;
+  const lua_Number *version;  /* pointer to version number */
+  TString *memerrmsg;  /* memory-error message */
+  TString *tmname[TM_N];  /* array with tag-method names */
+  struct Table *mt[LUA_NUMTAGS];  /* metatables for basic types */
+} global_State;
+
+
+/*
+** `per thread' state
+*/
+struct lua_State {
+  CommonHeader;
+  lu_byte status;
+  StkId top;  /* first free slot in the stack */
+  global_State *l_G;
+  CallInfo *ci;  /* call info for current function */
+  const Instruction *oldpc;  /* last pc traced */
+  StkId stack_last;  /* last free slot in the stack */
+  StkId stack;  /* stack base */
+  int stacksize;
+  unsigned short nny;  /* number of non-yieldable calls in stack */
+  unsigned short nCcalls;  /* number of nested C calls */
+  lu_byte hookmask;
+  lu_byte allowhook;
+  int basehookcount;
+  int hookcount;
+  lua_Hook hook;
+  GCObject *openupval;  /* list of open upvalues in this stack */
+  GCObject *gclist;
+  struct lua_longjmp *errorJmp;  /* current error recover point */
+  ptrdiff_t errfunc;  /* current error handling function (stack index) */
+  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
+};
+
+
+#define G(L)	(L->l_G)
+
+
+/*
+** Union of all collectable objects
+*/
+union GCObject {
+  GCheader gch;  /* common header */
+  union TString ts;
+  union Udata u;
+  union Closure cl;
+  struct Table h;
+  struct Proto p;
+  struct UpVal uv;
+  struct lua_State th;  /* thread */
+};
+
+
+#define gch(o)		(&(o)->gch)
+
+/* macros to convert a GCObject into a specific value */
+#define rawgco2ts(o)  \
+	check_exp(novariant((o)->gch.tt) == LUA_TSTRING, &((o)->ts))
+#define gco2ts(o)	(&rawgco2ts(o)->tsv)
+#define rawgco2u(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
+#define gco2u(o)	(&rawgco2u(o)->uv)
+#define gco2lcl(o)	check_exp((o)->gch.tt == LUA_TLCL, &((o)->cl.l))
+#define gco2ccl(o)	check_exp((o)->gch.tt == LUA_TCCL, &((o)->cl.c))
+#define gco2cl(o)  \
+	check_exp(novariant((o)->gch.tt) == LUA_TFUNCTION, &((o)->cl))
+#define gco2t(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
+#define gco2p(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
+#define gco2uv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
+#define gco2th(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
+
+/* macro to convert any Lua object into a GCObject */
+#define obj2gco(v)	(cast(GCObject *, (v)))
+
+
+/* actual number of total bytes allocated */
+#define gettotalbytes(g)	((g)->totalbytes + (g)->GCdebt)
+
+LUAI_FUNC void luaE_setdebt (global_State *g, l_mem debt);
+LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);
+LUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);
+LUAI_FUNC void luaE_freeCI (lua_State *L);
+
+
+#endif
+
diff --git a/dep/lualib/lstring.c b/dep/lualib/lstring.c
new file mode 100644
index 0000000..8b959f1
--- /dev/null
+++ b/dep/lualib/lstring.c
@@ -0,0 +1,185 @@
+/*
+** $Id: lstring.c,v 2.24 2012/05/11 14:14:42 roberto Exp $
+** String table (keeps all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lstring_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+
+
+/*
+** Lua will use at most ~(2^LUAI_HASHLIMIT) bytes from a string to
+** compute its hash
+*/
+#if !defined(LUAI_HASHLIMIT)
+#define LUAI_HASHLIMIT		5
+#endif
+
+
+/*
+** equality for long strings
+*/
+int luaS_eqlngstr (TString *a, TString *b) {
+  size_t len = a->tsv.len;
+  lua_assert(a->tsv.tt == LUA_TLNGSTR && b->tsv.tt == LUA_TLNGSTR);
+  return (a == b) ||  /* same instance or... */
+    ((len == b->tsv.len) &&  /* equal length and ... */
+     (memcmp(getstr(a), getstr(b), len) == 0));  /* equal contents */
+}
+
+
+/*
+** equality for strings
+*/
+int luaS_eqstr (TString *a, TString *b) {
+  return (a->tsv.tt == b->tsv.tt) &&
+         (a->tsv.tt == LUA_TSHRSTR ? eqshrstr(a, b) : luaS_eqlngstr(a, b));
+}
+
+
+unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {
+  unsigned int h = seed ^ l;
+  size_t l1;
+  size_t step = (l >> LUAI_HASHLIMIT) + 1;
+  for (l1 = l; l1 >= step; l1 -= step)
+    h = h ^ ((h<<5) + (h>>2) + cast_byte(str[l1 - 1]));
+  return h;
+}
+
+
+/*
+** resizes the string table
+*/
+void luaS_resize (lua_State *L, int newsize) {
+  int i;
+  stringtable *tb = &G(L)->strt;
+  /* cannot resize while GC is traversing strings */
+  luaC_runtilstate(L, ~bitmask(GCSsweepstring));
+  if (newsize > tb->size) {
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+    for (i = tb->size; i < newsize; i++) tb->hash[i] = NULL;
+  }
+  /* rehash */
+  for (i=0; i<tb->size; i++) {
+    GCObject *p = tb->hash[i];
+    tb->hash[i] = NULL;
+    while (p) {  /* for each node in the list */
+      GCObject *next = gch(p)->next;  /* save next */
+      unsigned int h = lmod(gco2ts(p)->hash, newsize);  /* new position */
+      gch(p)->next = tb->hash[h];  /* chain it */
+      tb->hash[h] = p;
+      resetoldbit(p);  /* see MOVE OLD rule */
+      p = next;
+    }
+  }
+  if (newsize < tb->size) {
+    /* shrinking slice must be empty */
+    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+  }
+  tb->size = newsize;
+}
+
+
+/*
+** creates a new string object
+*/
+static TString *createstrobj (lua_State *L, const char *str, size_t l,
+                              int tag, unsigned int h, GCObject **list) {
+  TString *ts;
+  size_t totalsize;  /* total size of TString object */
+  totalsize = sizeof(TString) + ((l + 1) * sizeof(char));
+  ts = &luaC_newobj(L, tag, totalsize, list, 0)->ts;
+  ts->tsv.len = l;
+  ts->tsv.hash = h;
+  ts->tsv.extra = 0;
+  memcpy(ts+1, str, l*sizeof(char));
+  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
+  return ts;
+}
+
+
+/*
+** creates a new short string, inserting it into string table
+*/
+static TString *newshrstr (lua_State *L, const char *str, size_t l,
+                                       unsigned int h) {
+  GCObject **list;  /* (pointer to) list where it will be inserted */
+  stringtable *tb = &G(L)->strt;
+  TString *s;
+  if (tb->nuse >= cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
+    luaS_resize(L, tb->size*2);  /* too crowded */
+  list = &tb->hash[lmod(h, tb->size)];
+  s = createstrobj(L, str, l, LUA_TSHRSTR, h, list);
+  tb->nuse++;
+  return s;
+}
+
+
+/*
+** checks whether short string exists and reuses it or creates a new one
+*/
+static TString *internshrstr (lua_State *L, const char *str, size_t l) {
+  GCObject *o;
+  global_State *g = G(L);
+  unsigned int h = luaS_hash(str, l, g->seed);
+  for (o = g->strt.hash[lmod(h, g->strt.size)];
+       o != NULL;
+       o = gch(o)->next) {
+    TString *ts = rawgco2ts(o);
+    if (h == ts->tsv.hash &&
+        ts->tsv.len == l &&
+        (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {
+      if (isdead(G(L), o))  /* string is dead (but was not collected yet)? */
+        changewhite(o);  /* resurrect it */
+      return ts;
+    }
+  }
+  return newshrstr(L, str, l, h);  /* not found; create a new string */
+}
+
+
+/*
+** new string (with explicit length)
+*/
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
+  if (l <= LUAI_MAXSHORTLEN)  /* short string? */
+    return internshrstr(L, str, l);
+  else {
+    if (l + 1 > (MAX_SIZET - sizeof(TString))/sizeof(char))
+      luaM_toobig(L);
+    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed, NULL);
+  }
+}
+
+
+/*
+** new zero-terminated string
+*/
+TString *luaS_new (lua_State *L, const char *str) {
+  return luaS_newlstr(L, str, strlen(str));
+}
+
+
+Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
+  Udata *u;
+  if (s > MAX_SIZET - sizeof(Udata))
+    luaM_toobig(L);
+  u = &luaC_newobj(L, LUA_TUSERDATA, sizeof(Udata) + s, NULL, 0)->u;
+  u->uv.len = s;
+  u->uv.metatable = NULL;
+  u->uv.env = e;
+  return u;
+}
+
diff --git a/dep/lualib/lstring.h b/dep/lualib/lstring.h
new file mode 100644
index 0000000..d312ff3
--- /dev/null
+++ b/dep/lualib/lstring.h
@@ -0,0 +1,46 @@
+/*
+** $Id: lstring.h,v 1.49 2012/02/01 21:57:15 roberto Exp $
+** String table (keep all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstring_h
+#define lstring_h
+
+#include "lgc.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+#define sizestring(s)	(sizeof(union TString)+((s)->len+1)*sizeof(char))
+
+#define sizeudata(u)	(sizeof(union Udata)+(u)->len)
+
+#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
+                                 (sizeof(s)/sizeof(char))-1))
+
+#define luaS_fix(s)	l_setbit((s)->tsv.marked, FIXEDBIT)
+
+
+/*
+** test whether a string is a reserved word
+*/
+#define isreserved(s)	((s)->tsv.tt == LUA_TSHRSTR && (s)->tsv.extra > 0)
+
+
+/*
+** equality for short strings, which are always internalized
+*/
+#define eqshrstr(a,b)	check_exp((a)->tsv.tt == LUA_TSHRSTR, (a) == (b))
+
+
+LUAI_FUNC unsigned int luaS_hash (const char *str, size_t l, unsigned int seed);
+LUAI_FUNC int luaS_eqlngstr (TString *a, TString *b);
+LUAI_FUNC int luaS_eqstr (TString *a, TString *b);
+LUAI_FUNC void luaS_resize (lua_State *L, int newsize);
+LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, Table *e);
+LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
+LUAI_FUNC TString *luaS_new (lua_State *L, const char *str);
+
+
+#endif
diff --git a/dep/lualib/lstrlib.c b/dep/lualib/lstrlib.c
new file mode 100644
index 0000000..e13098b
--- /dev/null
+++ b/dep/lualib/lstrlib.c
@@ -0,0 +1,972 @@
+/*
+** $Id: lstrlib.c,v 1.176 2012/05/23 15:37:09 roberto Exp $
+** Standard library for string operations and pattern-matching
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lstrlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** maximum number of captures that a pattern can do during
+** pattern-matching. This limit is arbitrary.
+*/
+#if !defined(LUA_MAXCAPTURES)
+#define LUA_MAXCAPTURES		32
+#endif
+
+
+/* macro to `unsign' a character */
+#define uchar(c)	((unsigned char)(c))
+
+
+
+static int str_len (lua_State *L) {
+  size_t l;
+  luaL_checklstring(L, 1, &l);
+  lua_pushinteger(L, (lua_Integer)l);
+  return 1;
+}
+
+
+/* translate a relative string position: negative means back from end */
+static size_t posrelat (ptrdiff_t pos, size_t len) {
+  if (pos >= 0) return (size_t)pos;
+  else if (0u - (size_t)pos > len) return 0;
+  else return len - ((size_t)-pos) + 1;
+}
+
+
+static int str_sub (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  size_t start = posrelat(luaL_checkinteger(L, 2), l);
+  size_t end = posrelat(luaL_optinteger(L, 3, -1), l);
+  if (start < 1) start = 1;
+  if (end > l) end = l;
+  if (start <= end)
+    lua_pushlstring(L, s + start - 1, end - start + 1);
+  else lua_pushliteral(L, "");
+  return 1;
+}
+
+
+static int str_reverse (lua_State *L) {
+  size_t l, i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i = 0; i < l; i++)
+    p[i] = s[l - i - 1];
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+static int str_lower (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i=0; i<l; i++)
+    p[i] = tolower(uchar(s[i]));
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+static int str_upper (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i=0; i<l; i++)
+    p[i] = toupper(uchar(s[i]));
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+/* reasonable limit to avoid arithmetic overflow */
+#define MAXSIZE		((~(size_t)0) >> 1)
+
+static int str_rep (lua_State *L) {
+  size_t l, lsep;
+  const char *s = luaL_checklstring(L, 1, &l);
+  int n = luaL_checkint(L, 2);
+  const char *sep = luaL_optlstring(L, 3, "", &lsep);
+  if (n <= 0) lua_pushliteral(L, "");
+  else if (l + lsep < l || l + lsep >= MAXSIZE / n)  /* may overflow? */
+    return luaL_error(L, "resulting string too large");
+  else {
+    size_t totallen = n * l + (n - 1) * lsep;
+    luaL_Buffer b;
+    char *p = luaL_buffinitsize(L, &b, totallen);
+    while (n-- > 1) {  /* first n-1 copies (followed by separator) */
+      memcpy(p, s, l * sizeof(char)); p += l;
+      if (lsep > 0) {  /* avoid empty 'memcpy' (may be expensive) */
+        memcpy(p, sep, lsep * sizeof(char)); p += lsep;
+      }
+    }
+    memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */
+    luaL_pushresultsize(&b, totallen);
+  }
+  return 1;
+}
+
+
+static int str_byte (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  size_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
+  size_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
+  int n, i;
+  if (posi < 1) posi = 1;
+  if (pose > l) pose = l;
+  if (posi > pose) return 0;  /* empty interval; return no values */
+  n = (int)(pose -  posi + 1);
+  if (posi + n <= pose)  /* (size_t -> int) overflow? */
+    return luaL_error(L, "string slice too long");
+  luaL_checkstack(L, n, "string slice too long");
+  for (i=0; i<n; i++)
+    lua_pushinteger(L, uchar(s[posi+i-1]));
+  return n;
+}
+
+
+static int str_char (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  luaL_Buffer b;
+  char *p = luaL_buffinitsize(L, &b, n);
+  for (i=1; i<=n; i++) {
+    int c = luaL_checkint(L, i);
+    luaL_argcheck(L, uchar(c) == c, i, "value out of range");
+    p[i - 1] = uchar(c);
+  }
+  luaL_pushresultsize(&b, n);
+  return 1;
+}
+
+
+static int writer (lua_State *L, const void* b, size_t size, void* B) {
+  (void)L;
+  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  return 0;
+}
+
+
+static int str_dump (lua_State *L) {
+  luaL_Buffer b;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  lua_settop(L, 1);
+  luaL_buffinit(L,&b);
+  if (lua_dump(L, writer, &b) != 0)
+    return luaL_error(L, "unable to dump given function");
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** PATTERN MATCHING
+** =======================================================
+*/
+
+
+#define CAP_UNFINISHED	(-1)
+#define CAP_POSITION	(-2)
+
+typedef struct MatchState {
+  const char *src_init;  /* init of source string */
+  const char *src_end;  /* end ('\0') of source string */
+  const char *p_end;  /* end ('\0') of pattern */
+  lua_State *L;
+  int level;  /* total number of captures (finished or unfinished) */
+  struct {
+    const char *init;
+    ptrdiff_t len;
+  } capture[LUA_MAXCAPTURES];
+} MatchState;
+
+
+#define L_ESC		'%'
+#define SPECIALS	"^$*+?.([%-"
+
+
+static int check_capture (MatchState *ms, int l) {
+  l -= '1';
+  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
+    return luaL_error(ms->L, "invalid capture index %%%d", l + 1);
+  return l;
+}
+
+
+static int capture_to_close (MatchState *ms) {
+  int level = ms->level;
+  for (level--; level>=0; level--)
+    if (ms->capture[level].len == CAP_UNFINISHED) return level;
+  return luaL_error(ms->L, "invalid pattern capture");
+}
+
+
+static const char *classend (MatchState *ms, const char *p) {
+  switch (*p++) {
+    case L_ESC: {
+      if (p == ms->p_end)
+        luaL_error(ms->L, "malformed pattern (ends with " LUA_QL("%%") ")");
+      return p+1;
+    }
+    case '[': {
+      if (*p == '^') p++;
+      do {  /* look for a `]' */
+        if (p == ms->p_end)
+          luaL_error(ms->L, "malformed pattern (missing " LUA_QL("]") ")");
+        if (*(p++) == L_ESC && p < ms->p_end)
+          p++;  /* skip escapes (e.g. `%]') */
+      } while (*p != ']');
+      return p+1;
+    }
+    default: {
+      return p;
+    }
+  }
+}
+
+
+static int match_class (int c, int cl) {
+  int res;
+  switch (tolower(cl)) {
+    case 'a' : res = isalpha(c); break;
+    case 'c' : res = iscntrl(c); break;
+    case 'd' : res = isdigit(c); break;
+    case 'g' : res = isgraph(c); break;
+    case 'l' : res = islower(c); break;
+    case 'p' : res = ispunct(c); break;
+    case 's' : res = isspace(c); break;
+    case 'u' : res = isupper(c); break;
+    case 'w' : res = isalnum(c); break;
+    case 'x' : res = isxdigit(c); break;
+    case 'z' : res = (c == 0); break;  /* deprecated option */
+    default: return (cl == c);
+  }
+  return (islower(cl) ? res : !res);
+}
+
+
+static int matchbracketclass (int c, const char *p, const char *ec) {
+  int sig = 1;
+  if (*(p+1) == '^') {
+    sig = 0;
+    p++;  /* skip the `^' */
+  }
+  while (++p < ec) {
+    if (*p == L_ESC) {
+      p++;
+      if (match_class(c, uchar(*p)))
+        return sig;
+    }
+    else if ((*(p+1) == '-') && (p+2 < ec)) {
+      p+=2;
+      if (uchar(*(p-2)) <= c && c <= uchar(*p))
+        return sig;
+    }
+    else if (uchar(*p) == c) return sig;
+  }
+  return !sig;
+}
+
+
+static int singlematch (int c, const char *p, const char *ep) {
+  switch (*p) {
+    case '.': return 1;  /* matches any char */
+    case L_ESC: return match_class(c, uchar(*(p+1)));
+    case '[': return matchbracketclass(c, p, ep-1);
+    default:  return (uchar(*p) == c);
+  }
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p);
+
+
+static const char *matchbalance (MatchState *ms, const char *s,
+                                   const char *p) {
+  if (p >= ms->p_end - 1)
+    luaL_error(ms->L, "malformed pattern "
+                      "(missing arguments to " LUA_QL("%%b") ")");
+  if (*s != *p) return NULL;
+  else {
+    int b = *p;
+    int e = *(p+1);
+    int cont = 1;
+    while (++s < ms->src_end) {
+      if (*s == e) {
+        if (--cont == 0) return s+1;
+      }
+      else if (*s == b) cont++;
+    }
+  }
+  return NULL;  /* string ends out of balance */
+}
+
+
+static const char *max_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  ptrdiff_t i = 0;  /* counts maximum expand for item */
+  while ((s+i)<ms->src_end && singlematch(uchar(*(s+i)), p, ep))
+    i++;
+  /* keeps trying to match with the maximum repetitions */
+  while (i>=0) {
+    const char *res = match(ms, (s+i), ep+1);
+    if (res) return res;
+    i--;  /* else didn't match; reduce 1 repetition to try again */
+  }
+  return NULL;
+}
+
+
+static const char *min_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  for (;;) {
+    const char *res = match(ms, s, ep+1);
+    if (res != NULL)
+      return res;
+    else if (s<ms->src_end && singlematch(uchar(*s), p, ep))
+      s++;  /* try with one more repetition */
+    else return NULL;
+  }
+}
+
+
+static const char *start_capture (MatchState *ms, const char *s,
+                                    const char *p, int what) {
+  const char *res;
+  int level = ms->level;
+  if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, "too many captures");
+  ms->capture[level].init = s;
+  ms->capture[level].len = what;
+  ms->level = level+1;
+  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
+    ms->level--;  /* undo capture */
+  return res;
+}
+
+
+static const char *end_capture (MatchState *ms, const char *s,
+                                  const char *p) {
+  int l = capture_to_close(ms);
+  const char *res;
+  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
+  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
+    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  return res;
+}
+
+
+static const char *match_capture (MatchState *ms, const char *s, int l) {
+  size_t len;
+  l = check_capture(ms, l);
+  len = ms->capture[l].len;
+  if ((size_t)(ms->src_end-s) >= len &&
+      memcmp(ms->capture[l].init, s, len) == 0)
+    return s+len;
+  else return NULL;
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p) {
+  init: /* using goto's to optimize tail recursion */
+  if (p == ms->p_end)  /* end of pattern? */
+    return s;  /* match succeeded */
+  switch (*p) {
+    case '(': {  /* start capture */
+      if (*(p+1) == ')')  /* position capture? */
+        return start_capture(ms, s, p+2, CAP_POSITION);
+      else
+        return start_capture(ms, s, p+1, CAP_UNFINISHED);
+    }
+    case ')': {  /* end capture */
+      return end_capture(ms, s, p+1);
+    }
+    case '$': {
+      if ((p+1) == ms->p_end)  /* is the `$' the last char in pattern? */
+        return (s == ms->src_end) ? s : NULL;  /* check end of string */
+      else goto dflt;
+    }
+    case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */
+      switch (*(p+1)) {
+        case 'b': {  /* balanced string? */
+          s = matchbalance(ms, s, p+2);
+          if (s == NULL) return NULL;
+          p+=4; goto init;  /* else return match(ms, s, p+4); */
+        }
+        case 'f': {  /* frontier? */
+          const char *ep; char previous;
+          p += 2;
+          if (*p != '[')
+            luaL_error(ms->L, "missing " LUA_QL("[") " after "
+                               LUA_QL("%%f") " in pattern");
+          ep = classend(ms, p);  /* points to what is next */
+          previous = (s == ms->src_init) ? '\0' : *(s-1);
+          if (matchbracketclass(uchar(previous), p, ep-1) ||
+             !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
+          p=ep; goto init;  /* else return match(ms, s, ep); */
+        }
+        case '0': case '1': case '2': case '3':
+        case '4': case '5': case '6': case '7':
+        case '8': case '9': {  /* capture results (%0-%9)? */
+          s = match_capture(ms, s, uchar(*(p+1)));
+          if (s == NULL) return NULL;
+          p+=2; goto init;  /* else return match(ms, s, p+2) */
+        }
+        default: goto dflt;
+      }
+    }
+    default: dflt: {  /* pattern class plus optional suffix */
+      const char *ep = classend(ms, p);  /* points to what is next */
+      int m = s < ms->src_end && singlematch(uchar(*s), p, ep);
+      switch (*ep) {
+        case '?': {  /* optional */
+          const char *res;
+          if (m && ((res=match(ms, s+1, ep+1)) != NULL))
+            return res;
+          p=ep+1; goto init;  /* else return match(ms, s, ep+1); */
+        }
+        case '*': {  /* 0 or more repetitions */
+          return max_expand(ms, s, p, ep);
+        }
+        case '+': {  /* 1 or more repetitions */
+          return (m ? max_expand(ms, s+1, p, ep) : NULL);
+        }
+        case '-': {  /* 0 or more repetitions (minimum) */
+          return min_expand(ms, s, p, ep);
+        }
+        default: {
+          if (!m) return NULL;
+          s++; p=ep; goto init;  /* else return match(ms, s+1, ep); */
+        }
+      }
+    }
+  }
+}
+
+
+
+static const char *lmemfind (const char *s1, size_t l1,
+                               const char *s2, size_t l2) {
+  if (l2 == 0) return s1;  /* empty strings are everywhere */
+  else if (l2 > l1) return NULL;  /* avoids a negative `l1' */
+  else {
+    const char *init;  /* to search for a `*s2' inside `s1' */
+    l2--;  /* 1st char will be checked by `memchr' */
+    l1 = l1-l2;  /* `s2' cannot be found after that */
+    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
+      init++;   /* 1st char is already checked */
+      if (memcmp(init, s2+1, l2) == 0)
+        return init-1;
+      else {  /* correct `l1' and `s1' to try again */
+        l1 -= init-s1;
+        s1 = init;
+      }
+    }
+    return NULL;  /* not found */
+  }
+}
+
+
+static void push_onecapture (MatchState *ms, int i, const char *s,
+                                                    const char *e) {
+  if (i >= ms->level) {
+    if (i == 0)  /* ms->level == 0, too */
+      lua_pushlstring(ms->L, s, e - s);  /* add whole match */
+    else
+      luaL_error(ms->L, "invalid capture index");
+  }
+  else {
+    ptrdiff_t l = ms->capture[i].len;
+    if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
+    if (l == CAP_POSITION)
+      lua_pushinteger(ms->L, ms->capture[i].init - ms->src_init + 1);
+    else
+      lua_pushlstring(ms->L, ms->capture[i].init, l);
+  }
+}
+
+
+static int push_captures (MatchState *ms, const char *s, const char *e) {
+  int i;
+  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
+  luaL_checkstack(ms->L, nlevels, "too many captures");
+  for (i = 0; i < nlevels; i++)
+    push_onecapture(ms, i, s, e);
+  return nlevels;  /* number of strings pushed */
+}
+
+
+/* check whether pattern has no special characters */
+static int nospecials (const char *p, size_t l) {
+  size_t upto = 0;
+  do {
+    if (strpbrk(p + upto, SPECIALS))
+      return 0;  /* pattern has a special character */
+    upto += strlen(p + upto) + 1;  /* may have more after \0 */
+  } while (upto <= l);
+  return 1;  /* no special chars found */
+}
+
+
+static int str_find_aux (lua_State *L, int find) {
+  size_t ls, lp;
+  const char *s = luaL_checklstring(L, 1, &ls);
+  const char *p = luaL_checklstring(L, 2, &lp);
+  size_t init = posrelat(luaL_optinteger(L, 3, 1), ls);
+  if (init < 1) init = 1;
+  else if (init > ls + 1) {  /* start after string's end? */
+    lua_pushnil(L);  /* cannot find anything */
+    return 1;
+  }
+  /* explicit request or no special characters? */
+  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {
+    /* do a plain search */
+    const char *s2 = lmemfind(s + init - 1, ls - init + 1, p, lp);
+    if (s2) {
+      lua_pushinteger(L, s2 - s + 1);
+      lua_pushinteger(L, s2 - s + lp);
+      return 2;
+    }
+  }
+  else {
+    MatchState ms;
+    const char *s1 = s + init - 1;
+    int anchor = (*p == '^');
+    if (anchor) {
+      p++; lp--;  /* skip anchor character */
+    }
+    ms.L = L;
+    ms.src_init = s;
+    ms.src_end = s + ls;
+    ms.p_end = p + lp;
+    do {
+      const char *res;
+      ms.level = 0;
+      if ((res=match(&ms, s1, p)) != NULL) {
+        if (find) {
+          lua_pushinteger(L, s1 - s + 1);  /* start */
+          lua_pushinteger(L, res - s);   /* end */
+          return push_captures(&ms, NULL, 0) + 2;
+        }
+        else
+          return push_captures(&ms, s1, res);
+      }
+    } while (s1++ < ms.src_end && !anchor);
+  }
+  lua_pushnil(L);  /* not found */
+  return 1;
+}
+
+
+static int str_find (lua_State *L) {
+  return str_find_aux(L, 1);
+}
+
+
+static int str_match (lua_State *L) {
+  return str_find_aux(L, 0);
+}
+
+
+static int gmatch_aux (lua_State *L) {
+  MatchState ms;
+  size_t ls, lp;
+  const char *s = lua_tolstring(L, lua_upvalueindex(1), &ls);
+  const char *p = lua_tolstring(L, lua_upvalueindex(2), &lp);
+  const char *src;
+  ms.L = L;
+  ms.src_init = s;
+  ms.src_end = s+ls;
+  ms.p_end = p + lp;
+  for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));
+       src <= ms.src_end;
+       src++) {
+    const char *e;
+    ms.level = 0;
+    if ((e = match(&ms, src, p)) != NULL) {
+      lua_Integer newstart = e-s;
+      if (e == src) newstart++;  /* empty match? go at least one position */
+      lua_pushinteger(L, newstart);
+      lua_replace(L, lua_upvalueindex(3));
+      return push_captures(&ms, src, e);
+    }
+  }
+  return 0;  /* not found */
+}
+
+
+static int gmatch (lua_State *L) {
+  luaL_checkstring(L, 1);
+  luaL_checkstring(L, 2);
+  lua_settop(L, 2);
+  lua_pushinteger(L, 0);
+  lua_pushcclosure(L, gmatch_aux, 3);
+  return 1;
+}
+
+
+static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
+                                                   const char *e) {
+  size_t l, i;
+  const char *news = lua_tolstring(ms->L, 3, &l);
+  for (i = 0; i < l; i++) {
+    if (news[i] != L_ESC)
+      luaL_addchar(b, news[i]);
+    else {
+      i++;  /* skip ESC */
+      if (!isdigit(uchar(news[i]))) {
+        if (news[i] != L_ESC)
+          luaL_error(ms->L, "invalid use of " LUA_QL("%c")
+                           " in replacement string", L_ESC);
+        luaL_addchar(b, news[i]);
+      }
+      else if (news[i] == '0')
+          luaL_addlstring(b, s, e - s);
+      else {
+        push_onecapture(ms, news[i] - '1', s, e);
+        luaL_addvalue(b);  /* add capture to accumulated result */
+      }
+    }
+  }
+}
+
+
+static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
+                                       const char *e, int tr) {
+  lua_State *L = ms->L;
+  switch (tr) {
+    case LUA_TFUNCTION: {
+      int n;
+      lua_pushvalue(L, 3);
+      n = push_captures(ms, s, e);
+      lua_call(L, n, 1);
+      break;
+    }
+    case LUA_TTABLE: {
+      push_onecapture(ms, 0, s, e);
+      lua_gettable(L, 3);
+      break;
+    }
+    default: {  /* LUA_TNUMBER or LUA_TSTRING */
+      add_s(ms, b, s, e);
+      return;
+    }
+  }
+  if (!lua_toboolean(L, -1)) {  /* nil or false? */
+    lua_pop(L, 1);
+    lua_pushlstring(L, s, e - s);  /* keep original text */
+  }
+  else if (!lua_isstring(L, -1))
+    luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1));
+  luaL_addvalue(b);  /* add result to accumulator */
+}
+
+
+static int str_gsub (lua_State *L) {
+  size_t srcl, lp;
+  const char *src = luaL_checklstring(L, 1, &srcl);
+  const char *p = luaL_checklstring(L, 2, &lp);
+  int tr = lua_type(L, 3);
+  size_t max_s = luaL_optinteger(L, 4, srcl+1);
+  int anchor = (*p == '^');
+  size_t n = 0;
+  MatchState ms;
+  luaL_Buffer b;
+  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
+                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
+                      "string/function/table expected");
+  luaL_buffinit(L, &b);
+  if (anchor) {
+    p++; lp--;  /* skip anchor character */
+  }
+  ms.L = L;
+  ms.src_init = src;
+  ms.src_end = src+srcl;
+  ms.p_end = p + lp;
+  while (n < max_s) {
+    const char *e;
+    ms.level = 0;
+    e = match(&ms, src, p);
+    if (e) {
+      n++;
+      add_value(&ms, &b, src, e, tr);
+    }
+    if (e && e>src) /* non empty match? */
+      src = e;  /* skip it */
+    else if (src < ms.src_end)
+      luaL_addchar(&b, *src++);
+    else break;
+    if (anchor) break;
+  }
+  luaL_addlstring(&b, src, ms.src_end-src);
+  luaL_pushresult(&b);
+  lua_pushinteger(L, n);  /* number of substitutions */
+  return 2;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** STRING FORMAT
+** =======================================================
+*/
+
+/*
+** LUA_INTFRMLEN is the length modifier for integer conversions in
+** 'string.format'; LUA_INTFRM_T is the integer type corresponding to
+** the previous length
+*/
+#if !defined(LUA_INTFRMLEN)	/* { */
+#if defined(LUA_USE_LONGLONG)
+
+#define LUA_INTFRMLEN		"ll"
+#define LUA_INTFRM_T		long long
+
+#else
+
+#define LUA_INTFRMLEN		"l"
+#define LUA_INTFRM_T		long
+
+#endif
+#endif				/* } */
+
+
+/*
+** LUA_FLTFRMLEN is the length modifier for float conversions in
+** 'string.format'; LUA_FLTFRM_T is the float type corresponding to
+** the previous length
+*/
+#if !defined(LUA_FLTFRMLEN)
+
+#define LUA_FLTFRMLEN		""
+#define LUA_FLTFRM_T		double
+
+#endif
+
+
+/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
+#define MAX_ITEM	512
+/* valid flags in a format specification */
+#define FLAGS	"-+ #0"
+/*
+** maximum size of each format specification (such as '%-099.99d')
+** (+10 accounts for %99.99x plus margin of error)
+*/
+#define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
+
+
+static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
+  size_t l;
+  const char *s = luaL_checklstring(L, arg, &l);
+  luaL_addchar(b, '"');
+  while (l--) {
+    if (*s == '"' || *s == '\\' || *s == '\n') {
+      luaL_addchar(b, '\\');
+      luaL_addchar(b, *s);
+    }
+    else if (*s == '\0' || iscntrl(uchar(*s))) {
+      char buff[10];
+      if (!isdigit(uchar(*(s+1))))
+        sprintf(buff, "\\%d", (int)uchar(*s));
+      else
+        sprintf(buff, "\\%03d", (int)uchar(*s));
+      luaL_addstring(b, buff);
+    }
+    else
+      luaL_addchar(b, *s);
+    s++;
+  }
+  luaL_addchar(b, '"');
+}
+
+static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
+  const char *p = strfrmt;
+  while (*p != '\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */
+  if ((size_t)(p - strfrmt) >= sizeof(FLAGS)/sizeof(char))
+    luaL_error(L, "invalid format (repeated flags)");
+  if (isdigit(uchar(*p))) p++;  /* skip width */
+  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  if (*p == '.') {
+    p++;
+    if (isdigit(uchar(*p))) p++;  /* skip precision */
+    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  }
+  if (isdigit(uchar(*p)))
+    luaL_error(L, "invalid format (width or precision too long)");
+  *(form++) = '%';
+  memcpy(form, strfrmt, (p - strfrmt + 1) * sizeof(char));
+  form += p - strfrmt + 1;
+  *form = '\0';
+  return p;
+}
+
+
+/*
+** add length modifier into formats
+*/
+static void addlenmod (char *form, const char *lenmod) {
+  size_t l = strlen(form);
+  size_t lm = strlen(lenmod);
+  char spec = form[l - 1];
+  strcpy(form + l - 1, lenmod);
+  form[l + lm - 1] = spec;
+  form[l + lm] = '\0';
+}
+
+
+static int str_format (lua_State *L) {
+  int top = lua_gettop(L);
+  int arg = 1;
+  size_t sfl;
+  const char *strfrmt = luaL_checklstring(L, arg, &sfl);
+  const char *strfrmt_end = strfrmt+sfl;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (strfrmt < strfrmt_end) {
+    if (*strfrmt != L_ESC)
+      luaL_addchar(&b, *strfrmt++);
+    else if (*++strfrmt == L_ESC)
+      luaL_addchar(&b, *strfrmt++);  /* %% */
+    else { /* format item */
+      char form[MAX_FORMAT];  /* to store the format (`%...') */
+      char *buff = luaL_prepbuffsize(&b, MAX_ITEM);  /* to put formatted item */
+      int nb = 0;  /* number of bytes in added item */
+      if (++arg > top)
+        luaL_argerror(L, arg, "no value");
+      strfrmt = scanformat(L, strfrmt, form);
+      switch (*strfrmt++) {
+        case 'c': {
+          nb = sprintf(buff, form, luaL_checkint(L, arg));
+          break;
+        }
+        case 'd':  case 'i': {
+          lua_Number n = luaL_checknumber(L, arg);
+          LUA_INTFRM_T ni = (LUA_INTFRM_T)n;
+          lua_Number diff = n - (lua_Number)ni;
+          luaL_argcheck(L, -1 < diff && diff < 1, arg,
+                        "not a number in proper range");
+          addlenmod(form, LUA_INTFRMLEN);
+          nb = sprintf(buff, form, ni);
+          break;
+        }
+        case 'o':  case 'u':  case 'x':  case 'X': {
+          lua_Number n = luaL_checknumber(L, arg);
+          unsigned LUA_INTFRM_T ni = (unsigned LUA_INTFRM_T)n;
+          lua_Number diff = n - (lua_Number)ni;
+          luaL_argcheck(L, -1 < diff && diff < 1, arg,
+                        "not a non-negative number in proper range");
+          addlenmod(form, LUA_INTFRMLEN);
+          nb = sprintf(buff, form, ni);
+          break;
+        }
+        case 'e':  case 'E': case 'f':
+#if defined(LUA_USE_AFORMAT)
+        case 'a': case 'A':
+#endif
+        case 'g': case 'G': {
+          addlenmod(form, LUA_FLTFRMLEN);
+          nb = sprintf(buff, form, (LUA_FLTFRM_T)luaL_checknumber(L, arg));
+          break;
+        }
+        case 'q': {
+          addquoted(L, &b, arg);
+          break;
+        }
+        case 's': {
+          size_t l;
+          const char *s = luaL_tolstring(L, arg, &l);
+          if (!strchr(form, '.') && l >= 100) {
+            /* no precision and string is too long to be formatted;
+               keep original string */
+            luaL_addvalue(&b);
+            break;
+          }
+          else {
+            nb = sprintf(buff, form, s);
+            lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */
+            break;
+          }
+        }
+        default: {  /* also treat cases `pnLlh' */
+          return luaL_error(L, "invalid option " LUA_QL("%%%c") " to "
+                               LUA_QL("format"), *(strfrmt - 1));
+        }
+      }
+      luaL_addsize(&b, nb);
+    }
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static const luaL_Reg strlib[] = {
+  {"byte", str_byte},
+  {"char", str_char},
+  {"dump", str_dump},
+  {"find", str_find},
+  {"format", str_format},
+  {"gmatch", gmatch},
+  {"gsub", str_gsub},
+  {"len", str_len},
+  {"lower", str_lower},
+  {"match", str_match},
+  {"rep", str_rep},
+  {"reverse", str_reverse},
+  {"sub", str_sub},
+  {"upper", str_upper},
+  {NULL, NULL}
+};
+
+
+static void createmetatable (lua_State *L) {
+  lua_createtable(L, 0, 1);  /* table to be metatable for strings */
+  lua_pushliteral(L, "");  /* dummy string */
+  lua_pushvalue(L, -2);  /* copy table */
+  lua_setmetatable(L, -2);  /* set table as metatable for strings */
+  lua_pop(L, 1);  /* pop dummy string */
+  lua_pushvalue(L, -2);  /* get string library */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = string */
+  lua_pop(L, 1);  /* pop metatable */
+}
+
+
+/*
+** Open string library
+*/
+LUAMOD_API int luaopen_string (lua_State *L) {
+  luaL_newlib(L, strlib);
+  createmetatable(L);
+  return 1;
+}
+
diff --git a/dep/lualib/ltable.c b/dep/lualib/ltable.c
new file mode 100644
index 0000000..ffa5ecb
--- /dev/null
+++ b/dep/lualib/ltable.c
@@ -0,0 +1,588 @@
+/*
+** $Id: ltable.c,v 2.71 2012/05/23 15:37:09 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** Implementation of tables (aka arrays, objects, or hash tables).
+** Tables keep its elements in two parts: an array part and a hash part.
+** Non-negative integer keys are all candidates to be kept in the array
+** part. The actual size of the array is the largest `n' such that at
+** least half the slots between 0 and n are in use.
+** Hash uses a mix of chained scatter table with Brent's variation.
+** A main invariant of these tables is that, if an element is not
+** in its main position (i.e. the `original' position that its hash gives
+** to it), then the colliding element is in its own main position.
+** Hence even when the load factor reaches 100%, performance remains good.
+*/
+
+#include <string.h>
+
+#define ltable_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lvm.h"
+
+
+/*
+** max size of array part is 2^MAXBITS
+*/
+#if LUAI_BITSINT >= 32
+#define MAXBITS		30
+#else
+#define MAXBITS		(LUAI_BITSINT-2)
+#endif
+
+#define MAXASIZE	(1 << MAXBITS)
+
+
+#define hashpow2(t,n)		(gnode(t, lmod((n), sizenode(t))))
+
+#define hashstr(t,str)		hashpow2(t, (str)->tsv.hash)
+#define hashboolean(t,p)	hashpow2(t, p)
+
+
+/*
+** for some types, it is better to avoid modulus by power of 2, as
+** they tend to have many 2 factors.
+*/
+#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
+
+
+#define hashpointer(t,p)	hashmod(t, IntPoint(p))
+
+
+#define dummynode		(&dummynode_)
+
+#define isdummy(n)		((n) == dummynode)
+
+static const Node dummynode_ = {
+  {NILCONSTANT},  /* value */
+  {{NILCONSTANT, NULL}}  /* key */
+};
+
+
+/*
+** hash for lua_Numbers
+*/
+static Node *hashnum (const Table *t, lua_Number n) {
+  int i;
+  luai_hashnum(i, n);
+  if (i < 0) {
+    if (cast(unsigned int, i) == 0u - i)  /* use unsigned to avoid overflows */
+      i = 0;  /* handle INT_MIN */
+    i = -i;  /* must be a positive value */
+  }
+  return hashmod(t, i);
+}
+
+
+
+/*
+** returns the `main' position of an element in a table (that is, the index
+** of its hash value)
+*/
+static Node *mainposition (const Table *t, const TValue *key) {
+  switch (ttype(key)) {
+    case LUA_TNUMBER:
+      return hashnum(t, nvalue(key));
+    case LUA_TLNGSTR: {
+      TString *s = rawtsvalue(key);
+      if (s->tsv.extra == 0) {  /* no hash? */
+        s->tsv.hash = luaS_hash(getstr(s), s->tsv.len, s->tsv.hash);
+        s->tsv.extra = 1;  /* now it has its hash */
+      }
+      return hashstr(t, rawtsvalue(key));
+    }
+    case LUA_TSHRSTR:
+      return hashstr(t, rawtsvalue(key));
+    case LUA_TBOOLEAN:
+      return hashboolean(t, bvalue(key));
+    case LUA_TLIGHTUSERDATA:
+      return hashpointer(t, pvalue(key));
+    case LUA_TLCF:
+      return hashpointer(t, fvalue(key));
+    default:
+      return hashpointer(t, gcvalue(key));
+  }
+}
+
+
+/*
+** returns the index for `key' if `key' is an appropriate key to live in
+** the array part of the table, -1 otherwise.
+*/
+static int arrayindex (const TValue *key) {
+  if (ttisnumber(key)) {
+    lua_Number n = nvalue(key);
+    int k;
+    lua_number2int(k, n);
+    if (luai_numeq(cast_num(k), n))
+      return k;
+  }
+  return -1;  /* `key' did not match some condition */
+}
+
+
+/*
+** returns the index of a `key' for table traversals. First goes all
+** elements in the array part, then elements in the hash part. The
+** beginning of a traversal is signaled by -1.
+*/
+static int findindex (lua_State *L, Table *t, StkId key) {
+  int i;
+  if (ttisnil(key)) return -1;  /* first iteration */
+  i = arrayindex(key);
+  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */
+    return i-1;  /* yes; that's the index (corrected to C) */
+  else {
+    Node *n = mainposition(t, key);
+    for (;;) {  /* check whether `key' is somewhere in the chain */
+      /* key may be dead already, but it is ok to use it in `next' */
+      if (luaV_rawequalobj(gkey(n), key) ||
+            (ttisdeadkey(gkey(n)) && iscollectable(key) &&
+             deadvalue(gkey(n)) == gcvalue(key))) {
+        i = cast_int(n - gnode(t, 0));  /* key index in hash table */
+        /* hash elements are numbered after array ones */
+        return i + t->sizearray;
+      }
+      else n = gnext(n);
+      if (n == NULL)
+        luaG_runerror(L, "invalid key to " LUA_QL("next"));  /* key not found */
+    }
+  }
+}
+
+
+int luaH_next (lua_State *L, Table *t, StkId key) {
+  int i = findindex(L, t, key);  /* find original element */
+  for (i++; i < t->sizearray; i++) {  /* try first array part */
+    if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
+      setnvalue(key, cast_num(i+1));
+      setobj2s(L, key+1, &t->array[i]);
+      return 1;
+    }
+  }
+  for (i -= t->sizearray; i < sizenode(t); i++) {  /* then hash part */
+    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
+      setobj2s(L, key, gkey(gnode(t, i)));
+      setobj2s(L, key+1, gval(gnode(t, i)));
+      return 1;
+    }
+  }
+  return 0;  /* no more elements */
+}
+
+
+/*
+** {=============================================================
+** Rehash
+** ==============================================================
+*/
+
+
+static int computesizes (int nums[], int *narray) {
+  int i;
+  int twotoi;  /* 2^i */
+  int a = 0;  /* number of elements smaller than 2^i */
+  int na = 0;  /* number of elements to go to array part */
+  int n = 0;  /* optimal size for array part */
+  for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {
+    if (nums[i] > 0) {
+      a += nums[i];
+      if (a > twotoi/2) {  /* more than half elements present? */
+        n = twotoi;  /* optimal size (till now) */
+        na = a;  /* all elements smaller than n will go to array part */
+      }
+    }
+    if (a == *narray) break;  /* all elements already counted */
+  }
+  *narray = n;
+  lua_assert(*narray/2 <= na && na <= *narray);
+  return na;
+}
+
+
+static int countint (const TValue *key, int *nums) {
+  int k = arrayindex(key);
+  if (0 < k && k <= MAXASIZE) {  /* is `key' an appropriate array index? */
+    nums[luaO_ceillog2(k)]++;  /* count as such */
+    return 1;
+  }
+  else
+    return 0;
+}
+
+
+static int numusearray (const Table *t, int *nums) {
+  int lg;
+  int ttlg;  /* 2^lg */
+  int ause = 0;  /* summation of `nums' */
+  int i = 1;  /* count to traverse all array keys */
+  for (lg=0, ttlg=1; lg<=MAXBITS; lg++, ttlg*=2) {  /* for each slice */
+    int lc = 0;  /* counter */
+    int lim = ttlg;
+    if (lim > t->sizearray) {
+      lim = t->sizearray;  /* adjust upper limit */
+      if (i > lim)
+        break;  /* no more elements to count */
+    }
+    /* count elements in range (2^(lg-1), 2^lg] */
+    for (; i <= lim; i++) {
+      if (!ttisnil(&t->array[i-1]))
+        lc++;
+    }
+    nums[lg] += lc;
+    ause += lc;
+  }
+  return ause;
+}
+
+
+static int numusehash (const Table *t, int *nums, int *pnasize) {
+  int totaluse = 0;  /* total number of elements */
+  int ause = 0;  /* summation of `nums' */
+  int i = sizenode(t);
+  while (i--) {
+    Node *n = &t->node[i];
+    if (!ttisnil(gval(n))) {
+      ause += countint(gkey(n), nums);
+      totaluse++;
+    }
+  }
+  *pnasize += ause;
+  return totaluse;
+}
+
+
+static void setarrayvector (lua_State *L, Table *t, int size) {
+  int i;
+  luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
+  for (i=t->sizearray; i<size; i++)
+     setnilvalue(&t->array[i]);
+  t->sizearray = size;
+}
+
+
+static void setnodevector (lua_State *L, Table *t, int size) {
+  int lsize;
+  if (size == 0) {  /* no elements to hash part? */
+    t->node = cast(Node *, dummynode);  /* use common `dummynode' */
+    lsize = 0;
+  }
+  else {
+    int i;
+    lsize = luaO_ceillog2(size);
+    if (lsize > MAXBITS)
+      luaG_runerror(L, "table overflow");
+    size = twoto(lsize);
+    t->node = luaM_newvector(L, size, Node);
+    for (i=0; i<size; i++) {
+      Node *n = gnode(t, i);
+      gnext(n) = NULL;
+      setnilvalue(gkey(n));
+      setnilvalue(gval(n));
+    }
+  }
+  t->lsizenode = cast_byte(lsize);
+  t->lastfree = gnode(t, size);  /* all positions are free */
+}
+
+
+void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize) {
+  int i;
+  int oldasize = t->sizearray;
+  int oldhsize = t->lsizenode;
+  Node *nold = t->node;  /* save old hash ... */
+  if (nasize > oldasize)  /* array part must grow? */
+    setarrayvector(L, t, nasize);
+  /* create new hash part with appropriate size */
+  setnodevector(L, t, nhsize);
+  if (nasize < oldasize) {  /* array part must shrink? */
+    t->sizearray = nasize;
+    /* re-insert elements from vanishing slice */
+    for (i=nasize; i<oldasize; i++) {
+      if (!ttisnil(&t->array[i]))
+        luaH_setint(L, t, i + 1, &t->array[i]);
+    }
+    /* shrink array */
+    luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
+  }
+  /* re-insert elements from hash part */
+  for (i = twoto(oldhsize) - 1; i >= 0; i--) {
+    Node *old = nold+i;
+    if (!ttisnil(gval(old))) {
+      /* doesn't need barrier/invalidate cache, as entry was
+         already present in the table */
+      setobjt2t(L, luaH_set(L, t, gkey(old)), gval(old));
+    }
+  }
+  if (!isdummy(nold))
+    luaM_freearray(L, nold, cast(size_t, twoto(oldhsize))); /* free old array */
+}
+
+
+void luaH_resizearray (lua_State *L, Table *t, int nasize) {
+  int nsize = isdummy(t->node) ? 0 : sizenode(t);
+  luaH_resize(L, t, nasize, nsize);
+}
+
+
+static void rehash (lua_State *L, Table *t, const TValue *ek) {
+  int nasize, na;
+  int nums[MAXBITS+1];  /* nums[i] = number of keys with 2^(i-1) < k <= 2^i */
+  int i;
+  int totaluse;
+  for (i=0; i<=MAXBITS; i++) nums[i] = 0;  /* reset counts */
+  nasize = numusearray(t, nums);  /* count keys in array part */
+  totaluse = nasize;  /* all those keys are integer keys */
+  totaluse += numusehash(t, nums, &nasize);  /* count keys in hash part */
+  /* count extra key */
+  nasize += countint(ek, nums);
+  totaluse++;
+  /* compute new size for array part */
+  na = computesizes(nums, &nasize);
+  /* resize the table to new computed sizes */
+  luaH_resize(L, t, nasize, totaluse - na);
+}
+
+
+
+/*
+** }=============================================================
+*/
+
+
+Table *luaH_new (lua_State *L) {
+  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;
+  t->metatable = NULL;
+  t->flags = cast_byte(~0);
+  t->array = NULL;
+  t->sizearray = 0;
+  setnodevector(L, t, 0);
+  return t;
+}
+
+
+void luaH_free (lua_State *L, Table *t) {
+  if (!isdummy(t->node))
+    luaM_freearray(L, t->node, cast(size_t, sizenode(t)));
+  luaM_freearray(L, t->array, t->sizearray);
+  luaM_free(L, t);
+}
+
+
+static Node *getfreepos (Table *t) {
+  while (t->lastfree > t->node) {
+    t->lastfree--;
+    if (ttisnil(gkey(t->lastfree)))
+      return t->lastfree;
+  }
+  return NULL;  /* could not find a free place */
+}
+
+
+
+/*
+** inserts a new key into a hash table; first, check whether key's main
+** position is free. If not, check whether colliding node is in its main
+** position or not: if it is not, move colliding node to an empty place and
+** put new key in its main position; otherwise (colliding node is in its main
+** position), new key goes to an empty position.
+*/
+TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
+  Node *mp;
+  if (ttisnil(key)) luaG_runerror(L, "table index is nil");
+  else if (ttisnumber(key) && luai_numisnan(L, nvalue(key)))
+    luaG_runerror(L, "table index is NaN");
+  mp = mainposition(t, key);
+  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */
+    Node *othern;
+    Node *n = getfreepos(t);  /* get a free place */
+    if (n == NULL) {  /* cannot find a free place? */
+      rehash(L, t, key);  /* grow table */
+      /* whatever called 'newkey' take care of TM cache and GC barrier */
+      return luaH_set(L, t, key);  /* insert key into grown table */
+    }
+    lua_assert(!isdummy(n));
+    othern = mainposition(t, gkey(mp));
+    if (othern != mp) {  /* is colliding node out of its main position? */
+      /* yes; move colliding node into free position */
+      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
+      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
+      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
+      gnext(mp) = NULL;  /* now `mp' is free */
+      setnilvalue(gval(mp));
+    }
+    else {  /* colliding node is in its own main position */
+      /* new node will go into free position */
+      gnext(n) = gnext(mp);  /* chain new position */
+      gnext(mp) = n;
+      mp = n;
+    }
+  }
+  setobj2t(L, gkey(mp), key);
+  luaC_barrierback(L, obj2gco(t), key);
+  lua_assert(ttisnil(gval(mp)));
+  return gval(mp);
+}
+
+
+/*
+** search function for integers
+*/
+const TValue *luaH_getint (Table *t, int key) {
+  /* (1 <= key && key <= t->sizearray) */
+  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
+    return &t->array[key-1];
+  else {
+    lua_Number nk = cast_num(key);
+    Node *n = hashnum(t, nk);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
+        return gval(n);  /* that's it */
+      else n = gnext(n);
+    } while (n);
+    return luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for short strings
+*/
+const TValue *luaH_getstr (Table *t, TString *key) {
+  Node *n = hashstr(t, key);
+  lua_assert(key->tsv.tt == LUA_TSHRSTR);
+  do {  /* check whether `key' is somewhere in the chain */
+    if (ttisshrstring(gkey(n)) && eqshrstr(rawtsvalue(gkey(n)), key))
+      return gval(n);  /* that's it */
+    else n = gnext(n);
+  } while (n);
+  return luaO_nilobject;
+}
+
+
+/*
+** main search function
+*/
+const TValue *luaH_get (Table *t, const TValue *key) {
+  switch (ttype(key)) {
+    case LUA_TNIL: return luaO_nilobject;
+    case LUA_TSHRSTR: return luaH_getstr(t, rawtsvalue(key));
+    case LUA_TNUMBER: {
+      int k;
+      lua_Number n = nvalue(key);
+      lua_number2int(k, n);
+      if (luai_numeq(cast_num(k), nvalue(key))) /* index is int? */
+        return luaH_getint(t, k);  /* use specialized version */
+      /* else go through */
+    }
+    default: {
+      Node *n = mainposition(t, key);
+      do {  /* check whether `key' is somewhere in the chain */
+        if (luaV_rawequalobj(gkey(n), key))
+          return gval(n);  /* that's it */
+        else n = gnext(n);
+      } while (n);
+      return luaO_nilobject;
+    }
+  }
+}
+
+
+/*
+** beware: when using this function you probably need to check a GC
+** barrier and invalidate the TM cache.
+*/
+TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {
+  const TValue *p = luaH_get(t, key);
+  if (p != luaO_nilobject)
+    return cast(TValue *, p);
+  else return luaH_newkey(L, t, key);
+}
+
+
+void luaH_setint (lua_State *L, Table *t, int key, TValue *value) {
+  const TValue *p = luaH_getint(t, key);
+  TValue *cell;
+  if (p != luaO_nilobject)
+    cell = cast(TValue *, p);
+  else {
+    TValue k;
+    setnvalue(&k, cast_num(key));
+    cell = luaH_newkey(L, t, &k);
+  }
+  setobj2t(L, cell, value);
+}
+
+
+static int unbound_search (Table *t, unsigned int j) {
+  unsigned int i = j;  /* i is zero or a present index */
+  j++;
+  /* find `i' and `j' such that i is present and j is not */
+  while (!ttisnil(luaH_getint(t, j))) {
+    i = j;
+    j *= 2;
+    if (j > cast(unsigned int, MAX_INT)) {  /* overflow? */
+      /* table was built with bad purposes: resort to linear search */
+      i = 1;
+      while (!ttisnil(luaH_getint(t, i))) i++;
+      return i - 1;
+    }
+  }
+  /* now do a binary search between them */
+  while (j - i > 1) {
+    unsigned int m = (i+j)/2;
+    if (ttisnil(luaH_getint(t, m))) j = m;
+    else i = m;
+  }
+  return i;
+}
+
+
+/*
+** Try to find a boundary in table `t'. A `boundary' is an integer index
+** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
+*/
+int luaH_getn (Table *t) {
+  unsigned int j = t->sizearray;
+  if (j > 0 && ttisnil(&t->array[j - 1])) {
+    /* there is a boundary in the array part: (binary) search for it */
+    unsigned int i = 0;
+    while (j - i > 1) {
+      unsigned int m = (i+j)/2;
+      if (ttisnil(&t->array[m - 1])) j = m;
+      else i = m;
+    }
+    return i;
+  }
+  /* else must find a boundary in hash part */
+  else if (isdummy(t->node))  /* hash part is empty? */
+    return j;  /* that is easy... */
+  else return unbound_search(t, j);
+}
+
+
+
+#if defined(LUA_DEBUG)
+
+Node *luaH_mainposition (const Table *t, const TValue *key) {
+  return mainposition(t, key);
+}
+
+int luaH_isdummy (Node *n) { return isdummy(n); }
+
+#endif
diff --git a/dep/lualib/ltable.h b/dep/lualib/ltable.h
new file mode 100644
index 0000000..2f6f5c2
--- /dev/null
+++ b/dep/lualib/ltable.h
@@ -0,0 +1,41 @@
+/*
+** $Id: ltable.h,v 2.16 2011/08/17 20:26:47 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltable_h
+#define ltable_h
+
+#include "lobject.h"
+
+
+#define gnode(t,i)	(&(t)->node[i])
+#define gkey(n)		(&(n)->i_key.tvk)
+#define gval(n)		(&(n)->i_val)
+#define gnext(n)	((n)->i_key.nk.next)
+
+#define invalidateTMcache(t)	((t)->flags = 0)
+
+
+LUAI_FUNC const TValue *luaH_getint (Table *t, int key);
+LUAI_FUNC void luaH_setint (lua_State *L, Table *t, int key, TValue *value);
+LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);
+LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);
+LUAI_FUNC TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key);
+LUAI_FUNC TValue *luaH_set (lua_State *L, Table *t, const TValue *key);
+LUAI_FUNC Table *luaH_new (lua_State *L);
+LUAI_FUNC void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize);
+LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, int nasize);
+LUAI_FUNC void luaH_free (lua_State *L, Table *t);
+LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);
+LUAI_FUNC int luaH_getn (Table *t);
+
+
+#if defined(LUA_DEBUG)
+LUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);
+LUAI_FUNC int luaH_isdummy (Node *n);
+#endif
+
+
+#endif
diff --git a/dep/lualib/ltablib.c b/dep/lualib/ltablib.c
new file mode 100644
index 0000000..a52add0
--- /dev/null
+++ b/dep/lualib/ltablib.c
@@ -0,0 +1,283 @@
+/*
+** $Id: ltablib.c,v 1.63 2011/11/28 17:26:30 roberto Exp $
+** Library for Table Manipulation
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define ltablib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define aux_getn(L,n)  \
+	(luaL_checktype(L, n, LUA_TTABLE), luaL_len(L, n))
+
+
+#if defined(LUA_COMPAT_MAXN)
+static int maxn (lua_State *L) {
+  lua_Number max = 0;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_pushnil(L);  /* first key */
+  while (lua_next(L, 1)) {
+    lua_pop(L, 1);  /* remove value */
+    if (lua_type(L, -1) == LUA_TNUMBER) {
+      lua_Number v = lua_tonumber(L, -1);
+      if (v > max) max = v;
+    }
+  }
+  lua_pushnumber(L, max);
+  return 1;
+}
+#endif
+
+
+static int tinsert (lua_State *L) {
+  int e = aux_getn(L, 1) + 1;  /* first empty element */
+  int pos;  /* where to insert new element */
+  switch (lua_gettop(L)) {
+    case 2: {  /* called with only 2 arguments */
+      pos = e;  /* insert new element at the end */
+      break;
+    }
+    case 3: {
+      int i;
+      pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
+      if (pos > e) e = pos;  /* `grow' array if necessary */
+      for (i = e; i > pos; i--) {  /* move up elements */
+        lua_rawgeti(L, 1, i-1);
+        lua_rawseti(L, 1, i);  /* t[i] = t[i-1] */
+      }
+      break;
+    }
+    default: {
+      return luaL_error(L, "wrong number of arguments to " LUA_QL("insert"));
+    }
+  }
+  lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  return 0;
+}
+
+
+static int tremove (lua_State *L) {
+  int e = aux_getn(L, 1);
+  int pos = luaL_optint(L, 2, e);
+  if (!(1 <= pos && pos <= e))  /* position is outside bounds? */
+    return 0;  /* nothing to remove */
+  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
+  for ( ;pos<e; pos++) {
+    lua_rawgeti(L, 1, pos+1);
+    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
+  }
+  lua_pushnil(L);
+  lua_rawseti(L, 1, e);  /* t[e] = nil */
+  return 1;
+}
+
+
+static void addfield (lua_State *L, luaL_Buffer *b, int i) {
+  lua_rawgeti(L, 1, i);
+  if (!lua_isstring(L, -1))
+    luaL_error(L, "invalid value (%s) at index %d in table for "
+                  LUA_QL("concat"), luaL_typename(L, -1), i);
+  luaL_addvalue(b);
+}
+
+
+static int tconcat (lua_State *L) {
+  luaL_Buffer b;
+  size_t lsep;
+  int i, last;
+  const char *sep = luaL_optlstring(L, 2, "", &lsep);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i = luaL_optint(L, 3, 1);
+  last = luaL_opt(L, luaL_checkint, 4, luaL_len(L, 1));
+  luaL_buffinit(L, &b);
+  for (; i < last; i++) {
+    addfield(L, &b, i);
+    luaL_addlstring(&b, sep, lsep);
+  }
+  if (i == last)  /* add last value (if interval was not empty) */
+    addfield(L, &b, i);
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Pack/unpack
+** =======================================================
+*/
+
+static int pack (lua_State *L) {
+  int n = lua_gettop(L);  /* number of elements to pack */
+  lua_createtable(L, n, 1);  /* create result table */
+  lua_pushinteger(L, n);
+  lua_setfield(L, -2, "n");  /* t.n = number of elements */
+  if (n > 0) {  /* at least one element? */
+    int i;
+    lua_pushvalue(L, 1);
+    lua_rawseti(L, -2, 1);  /* insert first element */
+    lua_replace(L, 1);  /* move table into index 1 */
+    for (i = n; i >= 2; i--)  /* assign other elements */
+      lua_rawseti(L, 1, i);
+  }
+  return 1;  /* return table */
+}
+
+
+static int unpack (lua_State *L) {
+  int i, e, n;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i = luaL_optint(L, 2, 1);
+  e = luaL_opt(L, luaL_checkint, 3, luaL_len(L, 1));
+  if (i > e) return 0;  /* empty range */
+  n = e - i + 1;  /* number of elements */
+  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */
+    return luaL_error(L, "too many results to unpack");
+  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
+  while (i++ < e)  /* push arg[i + 1...e] */
+    lua_rawgeti(L, 1, i);
+  return n;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Quicksort
+** (based on `Algorithms in MODULA-3', Robert Sedgewick;
+**  Addison-Wesley, 1993.)
+** =======================================================
+*/
+
+
+static void set2 (lua_State *L, int i, int j) {
+  lua_rawseti(L, 1, i);
+  lua_rawseti(L, 1, j);
+}
+
+static int sort_comp (lua_State *L, int a, int b) {
+  if (!lua_isnil(L, 2)) {  /* function? */
+    int res;
+    lua_pushvalue(L, 2);
+    lua_pushvalue(L, a-1);  /* -1 to compensate function */
+    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+    lua_call(L, 2, 1);
+    res = lua_toboolean(L, -1);
+    lua_pop(L, 1);
+    return res;
+  }
+  else  /* a < b? */
+    return lua_compare(L, a, b, LUA_OPLT);
+}
+
+static void auxsort (lua_State *L, int l, int u) {
+  while (l < u) {  /* for tail recursion */
+    int i, j;
+    /* sort elements a[l], a[(l+u)/2] and a[u] */
+    lua_rawgeti(L, 1, l);
+    lua_rawgeti(L, 1, u);
+    if (sort_comp(L, -1, -2))  /* a[u] < a[l]? */
+      set2(L, l, u);  /* swap a[l] - a[u] */
+    else
+      lua_pop(L, 2);
+    if (u-l == 1) break;  /* only 2 elements */
+    i = (l+u)/2;
+    lua_rawgeti(L, 1, i);
+    lua_rawgeti(L, 1, l);
+    if (sort_comp(L, -2, -1))  /* a[i]<a[l]? */
+      set2(L, i, l);
+    else {
+      lua_pop(L, 1);  /* remove a[l] */
+      lua_rawgeti(L, 1, u);
+      if (sort_comp(L, -1, -2))  /* a[u]<a[i]? */
+        set2(L, i, u);
+      else
+        lua_pop(L, 2);
+    }
+    if (u-l == 2) break;  /* only 3 elements */
+    lua_rawgeti(L, 1, i);  /* Pivot */
+    lua_pushvalue(L, -1);
+    lua_rawgeti(L, 1, u-1);
+    set2(L, i, u-1);
+    /* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
+    i = l; j = u-1;
+    for (;;) {  /* invariant: a[l..i] <= P <= a[j..u] */
+      /* repeat ++i until a[i] >= P */
+      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
+        if (i>=u) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[i] */
+      }
+      /* repeat --j until a[j] <= P */
+      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
+        if (j<=l) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[j] */
+      }
+      if (j<i) {
+        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
+        break;
+      }
+      set2(L, i, j);
+    }
+    lua_rawgeti(L, 1, u-1);
+    lua_rawgeti(L, 1, i);
+    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
+    /* a[l..i-1] <= a[i] == P <= a[i+1..u] */
+    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
+    if (i-l < u-i) {
+      j=l; i=i-1; l=i+2;
+    }
+    else {
+      j=i+1; i=u; u=j-2;
+    }
+    auxsort(L, j, i);  /* call recursively the smaller one */
+  }  /* repeat the routine for the larger one */
+}
+
+static int sort (lua_State *L) {
+  int n = aux_getn(L, 1);
+  luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */
+  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
+    luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_settop(L, 2);  /* make sure there is two arguments */
+  auxsort(L, 1, n);
+  return 0;
+}
+
+/* }====================================================== */
+
+
+static const luaL_Reg tab_funcs[] = {
+  {"concat", tconcat},
+#if defined(LUA_COMPAT_MAXN)
+  {"maxn", maxn},
+#endif
+  {"insert", tinsert},
+  {"pack", pack},
+  {"unpack", unpack},
+  {"remove", tremove},
+  {"sort", sort},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_table (lua_State *L) {
+  luaL_newlib(L, tab_funcs);
+#if defined(LUA_COMPAT_UNPACK)
+  /* _G.unpack = table.unpack */
+  lua_getfield(L, -1, "unpack");
+  lua_setglobal(L, "unpack");
+#endif
+  return 1;
+}
+
diff --git a/dep/lualib/ltm.c b/dep/lualib/ltm.c
new file mode 100644
index 0000000..e70006d
--- /dev/null
+++ b/dep/lualib/ltm.c
@@ -0,0 +1,77 @@
+/*
+** $Id: ltm.c,v 2.14 2011/06/02 19:31:40 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define ltm_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+static const char udatatypename[] = "userdata";
+
+LUAI_DDEF const char *const luaT_typenames_[LUA_TOTALTAGS] = {
+  "no value",
+  "nil", "boolean", udatatypename, "number",
+  "string", "table", "function", udatatypename, "thread",
+  "proto", "upval"  /* these last two cases are used for tests only */
+};
+
+
+void luaT_init (lua_State *L) {
+  static const char *const luaT_eventname[] = {  /* ORDER TM */
+    "__index", "__newindex",
+    "__gc", "__mode", "__len", "__eq",
+    "__add", "__sub", "__mul", "__div", "__mod",
+    "__pow", "__unm", "__lt", "__le",
+    "__concat", "__call"
+  };
+  int i;
+  for (i=0; i<TM_N; i++) {
+    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
+    luaS_fix(G(L)->tmname[i]);  /* never collect these names */
+  }
+}
+
+
+/*
+** function to be used with macro "fasttm": optimized for absence of
+** tag methods
+*/
+const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
+  const TValue *tm = luaH_getstr(events, ename);
+  lua_assert(event <= TM_EQ);
+  if (ttisnil(tm)) {  /* no tag method? */
+    events->flags |= cast_byte(1u<<event);  /* cache this fact */
+    return NULL;
+  }
+  else return tm;
+}
+
+
+const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
+  Table *mt;
+  switch (ttypenv(o)) {
+    case LUA_TTABLE:
+      mt = hvalue(o)->metatable;
+      break;
+    case LUA_TUSERDATA:
+      mt = uvalue(o)->metatable;
+      break;
+    default:
+      mt = G(L)->mt[ttypenv(o)];
+  }
+  return (mt ? luaH_getstr(mt, G(L)->tmname[event]) : luaO_nilobject);
+}
+
diff --git a/dep/lualib/ltm.h b/dep/lualib/ltm.h
new file mode 100644
index 0000000..89bdc19
--- /dev/null
+++ b/dep/lualib/ltm.h
@@ -0,0 +1,57 @@
+/*
+** $Id: ltm.h,v 2.11 2011/02/28 17:32:10 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltm_h
+#define ltm_h
+
+
+#include "lobject.h"
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER TM"
+*/
+typedef enum {
+  TM_INDEX,
+  TM_NEWINDEX,
+  TM_GC,
+  TM_MODE,
+  TM_LEN,
+  TM_EQ,  /* last tag method with `fast' access */
+  TM_ADD,
+  TM_SUB,
+  TM_MUL,
+  TM_DIV,
+  TM_MOD,
+  TM_POW,
+  TM_UNM,
+  TM_LT,
+  TM_LE,
+  TM_CONCAT,
+  TM_CALL,
+  TM_N		/* number of elements in the enum */
+} TMS;
+
+
+
+#define gfasttm(g,et,e) ((et) == NULL ? NULL : \
+  ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
+
+#define fasttm(l,et,e)	gfasttm(G(l), et, e)
+
+#define ttypename(x)	luaT_typenames_[(x) + 1]
+#define objtypename(x)	ttypename(ttypenv(x))
+
+LUAI_DDEC const char *const luaT_typenames_[LUA_TOTALTAGS];
+
+
+LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
+LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
+                                                       TMS event);
+LUAI_FUNC void luaT_init (lua_State *L);
+
+#endif
diff --git a/dep/lualib/lua.c b/dep/lualib/lua.c
new file mode 100644
index 0000000..7614c70
--- /dev/null
+++ b/dep/lualib/lua.c
@@ -0,0 +1,496 @@
+/*
+** $Id: lua.c,v 1.205 2012/05/23 15:37:09 roberto Exp $
+** Lua stand-alone interpreter
+** See Copyright Notice in lua.h
+*/
+
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lua_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#if !defined(LUA_PROMPT)
+#define LUA_PROMPT		"> "
+#define LUA_PROMPT2		">> "
+#endif
+
+#if !defined(LUA_PROGNAME)
+#define LUA_PROGNAME		"lua"
+#endif
+
+#if !defined(LUA_MAXINPUT)
+#define LUA_MAXINPUT		512
+#endif
+
+#if !defined(LUA_INIT)
+#define LUA_INIT		"LUA_INIT"
+#endif
+
+#define LUA_INITVERSION  \
+	LUA_INIT "_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+
+
+/*
+** lua_stdin_is_tty detects whether the standard input is a 'tty' (that
+** is, whether we're running lua interactively).
+*/
+#if defined(LUA_USE_ISATTY)
+#include <unistd.h>
+#define lua_stdin_is_tty()	isatty(0)
+#elif defined(LUA_WIN)
+#include <io.h>
+#include <stdio.h>
+#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
+#else
+#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
+#endif
+
+
+/*
+** lua_readline defines how to show a prompt and then read a line from
+** the standard input.
+** lua_saveline defines how to "save" a read line in a "history".
+** lua_freeline defines how to free a line read by lua_readline.
+*/
+#if defined(LUA_USE_READLINE)
+
+#include <stdio.h>
+#include <readline/readline.h>
+#include <readline/history.h>
+#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
+#define lua_saveline(L,idx) \
+        if (lua_rawlen(L,idx) > 0)  /* non-empty line? */ \
+          add_history(lua_tostring(L, idx));  /* add it to history */
+#define lua_freeline(L,b)	((void)L, free(b))
+
+#elif !defined(lua_readline)
+
+#define lua_readline(L,b,p) \
+        ((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
+        fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
+#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
+#define lua_freeline(L,b)	{ (void)L; (void)b; }
+
+#endif
+
+
+
+
+static lua_State *globalL = NULL;
+
+static const char *progname = LUA_PROGNAME;
+
+
+
+static void lstop (lua_State *L, lua_Debug *ar) {
+  (void)ar;  /* unused arg. */
+  lua_sethook(L, NULL, 0, 0);
+  luaL_error(L, "interrupted!");
+}
+
+
+static void laction (int i) {
+  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
+                              terminate process (default action) */
+  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
+}
+
+
+static void print_usage (const char *badoption) {
+  luai_writestringerror("%s: ", progname);
+  if (badoption[1] == 'e' || badoption[1] == 'l')
+    luai_writestringerror("'%s' needs argument\n", badoption);
+  else
+    luai_writestringerror("unrecognized option '%s'\n", badoption);
+  luai_writestringerror(
+  "usage: %s [options] [script [args]]\n"
+  "Available options are:\n"
+  "  -e stat  execute string " LUA_QL("stat") "\n"
+  "  -i       enter interactive mode after executing " LUA_QL("script") "\n"
+  "  -l name  require library " LUA_QL("name") "\n"
+  "  -v       show version information\n"
+  "  -E       ignore environment variables\n"
+  "  --       stop handling options\n"
+  "  -        stop handling options and execute stdin\n"
+  ,
+  progname);
+}
+
+
+static void l_message (const char *pname, const char *msg) {
+  if (pname) luai_writestringerror("%s: ", pname);
+  luai_writestringerror("%s\n", msg);
+}
+
+
+static int report (lua_State *L, int status) {
+  if (status != LUA_OK && !lua_isnil(L, -1)) {
+    const char *msg = lua_tostring(L, -1);
+    if (msg == NULL) msg = "(error object is not a string)";
+    l_message(progname, msg);
+    lua_pop(L, 1);
+    /* force a complete garbage collection in case of errors */
+    lua_gc(L, LUA_GCCOLLECT, 0);
+  }
+  return status;
+}
+
+
+/* the next function is called unprotected, so it must avoid errors */
+static void finalreport (lua_State *L, int status) {
+  if (status != LUA_OK) {
+    const char *msg = (lua_type(L, -1) == LUA_TSTRING) ? lua_tostring(L, -1)
+                                                       : NULL;
+    if (msg == NULL) msg = "(error object is not a string)";
+    l_message(progname, msg);
+    lua_pop(L, 1);
+  }
+}
+
+
+static int traceback (lua_State *L) {
+  const char *msg = lua_tostring(L, 1);
+  if (msg)
+    luaL_traceback(L, L, msg, 1);
+  else if (!lua_isnoneornil(L, 1)) {  /* is there an error object? */
+    if (!luaL_callmeta(L, 1, "__tostring"))  /* try its 'tostring' metamethod */
+      lua_pushliteral(L, "(no error message)");
+  }
+  return 1;
+}
+
+
+static int docall (lua_State *L, int narg, int nres) {
+  int status;
+  int base = lua_gettop(L) - narg;  /* function index */
+  lua_pushcfunction(L, traceback);  /* push traceback function */
+  lua_insert(L, base);  /* put it under chunk and args */
+  globalL = L;  /* to be available to 'laction' */
+  signal(SIGINT, laction);
+  status = lua_pcall(L, narg, nres, base);
+  signal(SIGINT, SIG_DFL);
+  lua_remove(L, base);  /* remove traceback function */
+  return status;
+}
+
+
+static void print_version (void) {
+  luai_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
+  luai_writeline();
+}
+
+
+static int getargs (lua_State *L, char **argv, int n) {
+  int narg;
+  int i;
+  int argc = 0;
+  while (argv[argc]) argc++;  /* count total number of arguments */
+  narg = argc - (n + 1);  /* number of arguments to the script */
+  luaL_checkstack(L, narg + 3, "too many arguments to script");
+  for (i=n+1; i < argc; i++)
+    lua_pushstring(L, argv[i]);
+  lua_createtable(L, narg, n + 1);
+  for (i=0; i < argc; i++) {
+    lua_pushstring(L, argv[i]);
+    lua_rawseti(L, -2, i - n);
+  }
+  return narg;
+}
+
+
+static int dofile (lua_State *L, const char *name) {
+  int status = luaL_loadfile(L, name);
+  if (status == LUA_OK) status = docall(L, 0, 0);
+  return report(L, status);
+}
+
+
+static int dostring (lua_State *L, const char *s, const char *name) {
+  int status = luaL_loadbuffer(L, s, strlen(s), name);
+  if (status == LUA_OK) status = docall(L, 0, 0);
+  return report(L, status);
+}
+
+
+static int dolibrary (lua_State *L, const char *name) {
+  int status;
+  lua_getglobal(L, "require");
+  lua_pushstring(L, name);
+  status = docall(L, 1, 1);  /* call 'require(name)' */
+  if (status == LUA_OK)
+    lua_setglobal(L, name);  /* global[name] = require return */
+  return report(L, status);
+}
+
+
+static const char *get_prompt (lua_State *L, int firstline) {
+  const char *p;
+  lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2");
+  p = lua_tostring(L, -1);
+  if (p == NULL) p = (firstline ? LUA_PROMPT : LUA_PROMPT2);
+  lua_pop(L, 1);  /* remove global */
+  return p;
+}
+
+/* mark in error messages for incomplete statements */
+#define EOFMARK		"<eof>"
+#define marklen		(sizeof(EOFMARK)/sizeof(char) - 1)
+
+static int incomplete (lua_State *L, int status) {
+  if (status == LUA_ERRSYNTAX) {
+    size_t lmsg;
+    const char *msg = lua_tolstring(L, -1, &lmsg);
+    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
+      lua_pop(L, 1);
+      return 1;
+    }
+  }
+  return 0;  /* else... */
+}
+
+
+static int pushline (lua_State *L, int firstline) {
+  char buffer[LUA_MAXINPUT];
+  char *b = buffer;
+  size_t l;
+  const char *prmt = get_prompt(L, firstline);
+  if (lua_readline(L, b, prmt) == 0)
+    return 0;  /* no input */
+  l = strlen(b);
+  if (l > 0 && b[l-1] == '\n')  /* line ends with newline? */
+    b[l-1] = '\0';  /* remove it */
+  if (firstline && b[0] == '=')  /* first line starts with `=' ? */
+    lua_pushfstring(L, "return %s", b+1);  /* change it to `return' */
+  else
+    lua_pushstring(L, b);
+  lua_freeline(L, b);
+  return 1;
+}
+
+
+static int loadline (lua_State *L) {
+  int status;
+  lua_settop(L, 0);
+  if (!pushline(L, 1))
+    return -1;  /* no input */
+  for (;;) {  /* repeat until gets a complete line */
+    size_t l;
+    const char *line = lua_tolstring(L, 1, &l);
+    status = luaL_loadbuffer(L, line, l, "=stdin");
+    if (!incomplete(L, status)) break;  /* cannot try to add lines? */
+    if (!pushline(L, 0))  /* no more input? */
+      return -1;
+    lua_pushliteral(L, "\n");  /* add a new line... */
+    lua_insert(L, -2);  /* ...between the two lines */
+    lua_concat(L, 3);  /* join them */
+  }
+  lua_saveline(L, 1);
+  lua_remove(L, 1);  /* remove line */
+  return status;
+}
+
+
+static void dotty (lua_State *L) {
+  int status;
+  const char *oldprogname = progname;
+  progname = NULL;
+  while ((status = loadline(L)) != -1) {
+    if (status == LUA_OK) status = docall(L, 0, LUA_MULTRET);
+    report(L, status);
+    if (status == LUA_OK && lua_gettop(L) > 0) {  /* any result to print? */
+      luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
+      lua_getglobal(L, "print");
+      lua_insert(L, 1);
+      if (lua_pcall(L, lua_gettop(L)-1, 0, 0) != LUA_OK)
+        l_message(progname, lua_pushfstring(L,
+                               "error calling " LUA_QL("print") " (%s)",
+                               lua_tostring(L, -1)));
+    }
+  }
+  lua_settop(L, 0);  /* clear stack */
+  luai_writeline();
+  progname = oldprogname;
+}
+
+
+static int handle_script (lua_State *L, char **argv, int n) {
+  int status;
+  const char *fname;
+  int narg = getargs(L, argv, n);  /* collect arguments */
+  lua_setglobal(L, "arg");
+  fname = argv[n];
+  if (strcmp(fname, "-") == 0 && strcmp(argv[n-1], "--") != 0)
+    fname = NULL;  /* stdin */
+  status = luaL_loadfile(L, fname);
+  lua_insert(L, -(narg+1));
+  if (status == LUA_OK)
+    status = docall(L, narg, LUA_MULTRET);
+  else
+    lua_pop(L, narg);
+  return report(L, status);
+}
+
+
+/* check that argument has no extra characters at the end */
+#define noextrachars(x)		{if ((x)[2] != '\0') return -1;}
+
+
+/* indices of various argument indicators in array args */
+#define has_i		0	/* -i */
+#define has_v		1	/* -v */
+#define has_e		2	/* -e */
+#define has_E		3	/* -E */
+
+#define num_has		4	/* number of 'has_*' */
+
+
+static int collectargs (char **argv, int *args) {
+  int i;
+  for (i = 1; argv[i] != NULL; i++) {
+    if (argv[i][0] != '-')  /* not an option? */
+        return i;
+    switch (argv[i][1]) {  /* option */
+      case '-':
+        noextrachars(argv[i]);
+        return (argv[i+1] != NULL ? i+1 : 0);
+      case '\0':
+        return i;
+      case 'E':
+        args[has_E] = 1;
+        break;
+      case 'i':
+        noextrachars(argv[i]);
+        args[has_i] = 1;  /* go through */
+      case 'v':
+        noextrachars(argv[i]);
+        args[has_v] = 1;
+        break;
+      case 'e':
+        args[has_e] = 1;  /* go through */
+      case 'l':  /* both options need an argument */
+        if (argv[i][2] == '\0') {  /* no concatenated argument? */
+          i++;  /* try next 'argv' */
+          if (argv[i] == NULL || argv[i][0] == '-')
+            return -(i - 1);  /* no next argument or it is another option */
+        }
+        break;
+      default:  /* invalid option; return its index... */
+        return -i;  /* ...as a negative value */
+    }
+  }
+  return 0;
+}
+
+
+static int runargs (lua_State *L, char **argv, int n) {
+  int i;
+  for (i = 1; i < n; i++) {
+    lua_assert(argv[i][0] == '-');
+    switch (argv[i][1]) {  /* option */
+      case 'e': {
+        const char *chunk = argv[i] + 2;
+        if (*chunk == '\0') chunk = argv[++i];
+        lua_assert(chunk != NULL);
+        if (dostring(L, chunk, "=(command line)") != LUA_OK)
+          return 0;
+        break;
+      }
+      case 'l': {
+        const char *filename = argv[i] + 2;
+        if (*filename == '\0') filename = argv[++i];
+        lua_assert(filename != NULL);
+        if (dolibrary(L, filename) != LUA_OK)
+          return 0;  /* stop if file fails */
+        break;
+      }
+      default: break;
+    }
+  }
+  return 1;
+}
+
+
+static int handle_luainit (lua_State *L) {
+  const char *name = "=" LUA_INITVERSION;
+  const char *init = getenv(name + 1);
+  if (init == NULL) {
+    name = "=" LUA_INIT;
+    init = getenv(name + 1);  /* try alternative name */
+  }
+  if (init == NULL) return LUA_OK;
+  else if (init[0] == '@')
+    return dofile(L, init+1);
+  else
+    return dostring(L, init, name);
+}
+
+
+static int pmain (lua_State *L) {
+  int argc = (int)lua_tointeger(L, 1);
+  char **argv = (char **)lua_touserdata(L, 2);
+  int script;
+  int args[num_has];
+  args[has_i] = args[has_v] = args[has_e] = args[has_E] = 0;
+  if (argv[0] && argv[0][0]) progname = argv[0];
+  script = collectargs(argv, args);
+  if (script < 0) {  /* invalid arg? */
+    print_usage(argv[-script]);
+    return 0;
+  }
+  if (args[has_v]) print_version();
+  if (args[has_E]) {  /* option '-E'? */
+    lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
+    lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
+  }
+  /* open standard libraries */
+  luaL_checkversion(L);
+  lua_gc(L, LUA_GCSTOP, 0);  /* stop collector during initialization */
+  luaL_openlibs(L);  /* open libraries */
+  lua_gc(L, LUA_GCRESTART, 0);
+  if (!args[has_E] && handle_luainit(L) != LUA_OK)
+    return 0;  /* error running LUA_INIT */
+  /* execute arguments -e and -l */
+  if (!runargs(L, argv, (script > 0) ? script : argc)) return 0;
+  /* execute main script (if there is one) */
+  if (script && handle_script(L, argv, script) != LUA_OK) return 0;
+  if (args[has_i])  /* -i option? */
+    dotty(L);
+  else if (script == 0 && !args[has_e] && !args[has_v]) {  /* no arguments? */
+    if (lua_stdin_is_tty()) {
+      print_version();
+      dotty(L);
+    }
+    else dofile(L, NULL);  /* executes stdin as a file */
+  }
+  lua_pushboolean(L, 1);  /* signal no errors */
+  return 1;
+}
+
+
+int main (int argc, char **argv) {
+  int status, result;
+  lua_State *L = luaL_newstate();  /* create state */
+  if (L == NULL) {
+    l_message(argv[0], "cannot create state: not enough memory");
+    return EXIT_FAILURE;
+  }
+  /* call 'pmain' in protected mode */
+  lua_pushcfunction(L, &pmain);
+  lua_pushinteger(L, argc);  /* 1st argument */
+  lua_pushlightuserdata(L, argv); /* 2nd argument */
+  status = lua_pcall(L, 2, 1, 0);
+  result = lua_toboolean(L, -1);  /* get result */
+  finalreport(L, status);
+  lua_close(L);
+  return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
diff --git a/dep/lualib/lua.h b/dep/lualib/lua.h
new file mode 100644
index 0000000..5c88fd2
--- /dev/null
+++ b/dep/lualib/lua.h
@@ -0,0 +1,442 @@
+/*
+** $Id: lua.h,v 1.283 2012/04/20 13:18:26 roberto Exp $
+** Lua - A Scripting Language
+** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
+** See Copyright Notice at the end of this file
+*/
+
+
+#ifndef lua_h
+#define lua_h
+
+#include <stdarg.h>
+#include <stddef.h>
+
+
+#include "luaconf.h"
+
+
+#define LUA_VERSION_MAJOR	"5"
+#define LUA_VERSION_MINOR	"2"
+#define LUA_VERSION_NUM		502
+#define LUA_VERSION_RELEASE	"1"
+
+#define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
+#define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
+#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2012 Lua.org, PUC-Rio"
+#define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
+
+
+/* mark for precompiled code ('<esc>Lua') */
+#define LUA_SIGNATURE	"\033Lua"
+
+/* option for multiple returns in 'lua_pcall' and 'lua_call' */
+#define LUA_MULTRET	(-1)
+
+
+/*
+** pseudo-indices
+*/
+#define LUA_REGISTRYINDEX	LUAI_FIRSTPSEUDOIDX
+#define lua_upvalueindex(i)	(LUA_REGISTRYINDEX - (i))
+
+
+/* thread status */
+#define LUA_OK		0
+#define LUA_YIELD	1
+#define LUA_ERRRUN	2
+#define LUA_ERRSYNTAX	3
+#define LUA_ERRMEM	4
+#define LUA_ERRGCMM	5
+#define LUA_ERRERR	6
+
+
+typedef struct lua_State lua_State;
+
+typedef int (*lua_CFunction) (lua_State *L);
+
+
+/*
+** functions that read/write blocks when loading/dumping Lua chunks
+*/
+typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
+
+typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);
+
+
+/*
+** prototype for memory-allocation functions
+*/
+typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
+
+
+/*
+** basic types
+*/
+#define LUA_TNONE		(-1)
+
+#define LUA_TNIL		0
+#define LUA_TBOOLEAN		1
+#define LUA_TLIGHTUSERDATA	2
+#define LUA_TNUMBER		3
+#define LUA_TSTRING		4
+#define LUA_TTABLE		5
+#define LUA_TFUNCTION		6
+#define LUA_TUSERDATA		7
+#define LUA_TTHREAD		8
+
+#define LUA_NUMTAGS		9
+
+
+
+/* minimum Lua stack available to a C function */
+#define LUA_MINSTACK	20
+
+
+/* predefined values in the registry */
+#define LUA_RIDX_MAINTHREAD	1
+#define LUA_RIDX_GLOBALS	2
+#define LUA_RIDX_LAST		LUA_RIDX_GLOBALS
+
+
+/* type of numbers in Lua */
+typedef LUA_NUMBER lua_Number;
+
+
+/* type for integer functions */
+typedef LUA_INTEGER lua_Integer;
+
+/* unsigned integer type */
+typedef LUA_UNSIGNED lua_Unsigned;
+
+
+
+/*
+** generic extra include file
+*/
+#if defined(LUA_USER_H)
+#include LUA_USER_H
+#endif
+
+
+
+/*
+** state manipulation
+*/
+LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
+LUA_API void       (lua_close) (lua_State *L);
+LUA_API lua_State *(lua_newthread) (lua_State *L);
+
+LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);
+
+
+LUA_API const lua_Number *(lua_version) (lua_State *L);
+
+
+/*
+** basic stack manipulation
+*/
+LUA_API int   (lua_absindex) (lua_State *L, int idx);
+LUA_API int   (lua_gettop) (lua_State *L);
+LUA_API void  (lua_settop) (lua_State *L, int idx);
+LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
+LUA_API void  (lua_remove) (lua_State *L, int idx);
+LUA_API void  (lua_insert) (lua_State *L, int idx);
+LUA_API void  (lua_replace) (lua_State *L, int idx);
+LUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);
+LUA_API int   (lua_checkstack) (lua_State *L, int sz);
+
+LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API int             (lua_isnumber) (lua_State *L, int idx);
+LUA_API int             (lua_isstring) (lua_State *L, int idx);
+LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
+LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
+LUA_API int             (lua_type) (lua_State *L, int idx);
+LUA_API const char     *(lua_typename) (lua_State *L, int tp);
+
+LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);
+LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);
+LUA_API lua_Unsigned    (lua_tounsignedx) (lua_State *L, int idx, int *isnum);
+LUA_API int             (lua_toboolean) (lua_State *L, int idx);
+LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
+LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);
+LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
+LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
+LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
+LUA_API const void     *(lua_topointer) (lua_State *L, int idx);
+
+
+/*
+** Comparison and arithmetic functions
+*/
+
+#define LUA_OPADD	0	/* ORDER TM */
+#define LUA_OPSUB	1
+#define LUA_OPMUL	2
+#define LUA_OPDIV	3
+#define LUA_OPMOD	4
+#define LUA_OPPOW	5
+#define LUA_OPUNM	6
+
+LUA_API void  (lua_arith) (lua_State *L, int op);
+
+#define LUA_OPEQ	0
+#define LUA_OPLT	1
+#define LUA_OPLE	2
+
+LUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);
+LUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void        (lua_pushnil) (lua_State *L);
+LUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);
+LUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);
+LUA_API void        (lua_pushunsigned) (lua_State *L, lua_Unsigned n);
+LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t l);
+LUA_API const char *(lua_pushstring) (lua_State *L, const char *s);
+LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
+                                                      va_list argp);
+LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
+LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
+LUA_API void  (lua_pushboolean) (lua_State *L, int b);
+LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
+LUA_API int   (lua_pushthread) (lua_State *L);
+
+
+/*
+** get functions (Lua -> stack)
+*/
+LUA_API void  (lua_getglobal) (lua_State *L, const char *var);
+LUA_API void  (lua_gettable) (lua_State *L, int idx);
+LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);
+LUA_API void  (lua_rawget) (lua_State *L, int idx);
+LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);
+LUA_API void  (lua_rawgetp) (lua_State *L, int idx, const void *p);
+LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
+LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
+LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
+LUA_API void  (lua_getuservalue) (lua_State *L, int idx);
+
+
+/*
+** set functions (stack -> Lua)
+*/
+LUA_API void  (lua_setglobal) (lua_State *L, const char *var);
+LUA_API void  (lua_settable) (lua_State *L, int idx);
+LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
+LUA_API void  (lua_rawset) (lua_State *L, int idx);
+LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);
+LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);
+LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
+LUA_API void  (lua_setuservalue) (lua_State *L, int idx);
+
+
+/*
+** 'load' and 'call' functions (load and run Lua code)
+*/
+LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults, int ctx,
+                           lua_CFunction k);
+#define lua_call(L,n,r)		lua_callk(L, (n), (r), 0, NULL)
+
+LUA_API int   (lua_getctx) (lua_State *L, int *ctx);
+
+LUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,
+                            int ctx, lua_CFunction k);
+#define lua_pcall(L,n,r,f)	lua_pcallk(L, (n), (r), (f), 0, NULL)
+
+LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
+                                        const char *chunkname,
+                                        const char *mode);
+
+LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data);
+
+
+/*
+** coroutine functions
+*/
+LUA_API int  (lua_yieldk) (lua_State *L, int nresults, int ctx,
+                           lua_CFunction k);
+#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)
+LUA_API int  (lua_resume) (lua_State *L, lua_State *from, int narg);
+LUA_API int  (lua_status) (lua_State *L);
+
+/*
+** garbage-collection function and options
+*/
+
+#define LUA_GCSTOP		0
+#define LUA_GCRESTART		1
+#define LUA_GCCOLLECT		2
+#define LUA_GCCOUNT		3
+#define LUA_GCCOUNTB		4
+#define LUA_GCSTEP		5
+#define LUA_GCSETPAUSE		6
+#define LUA_GCSETSTEPMUL	7
+#define LUA_GCSETMAJORINC	8
+#define LUA_GCISRUNNING		9
+#define LUA_GCGEN		10
+#define LUA_GCINC		11
+
+LUA_API int (lua_gc) (lua_State *L, int what, int data);
+
+
+/*
+** miscellaneous functions
+*/
+
+LUA_API int   (lua_error) (lua_State *L);
+
+LUA_API int   (lua_next) (lua_State *L, int idx);
+
+LUA_API void  (lua_concat) (lua_State *L, int n);
+LUA_API void  (lua_len)    (lua_State *L, int idx);
+
+LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
+LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);
+
+
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define lua_tonumber(L,i)	lua_tonumberx(L,i,NULL)
+#define lua_tointeger(L,i)	lua_tointegerx(L,i,NULL)
+#define lua_tounsigned(L,i)	lua_tounsignedx(L,i,NULL)
+
+#define lua_pop(L,n)		lua_settop(L, -(n)-1)
+
+#define lua_newtable(L)		lua_createtable(L, 0, 0)
+
+#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
+
+#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)
+
+#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
+#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
+#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
+#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
+#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
+#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
+#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
+#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)
+
+#define lua_ref(L, lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
+    (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
+
+#define lua_pushliteral(L, s)	\
+	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
+
+#define lua_pushglobaltable(L)  \
+	lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS)
+
+#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)
+
+
+
+/*
+** {======================================================================
+** Debug API
+** =======================================================================
+*/
+
+
+/*
+** Event codes
+*/
+#define LUA_HOOKCALL	0
+#define LUA_HOOKRET	1
+#define LUA_HOOKLINE	2
+#define LUA_HOOKCOUNT	3
+#define LUA_HOOKTAILCALL 4
+
+
+/*
+** Event masks
+*/
+#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
+#define LUA_MASKRET	(1 << LUA_HOOKRET)
+#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
+#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)
+
+typedef struct lua_Debug lua_Debug;  /* activation record */
+
+
+/* Functions to be called by the debugger in specific events */
+typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
+
+
+LUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);
+LUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);
+LUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);
+LUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);
+
+LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
+LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
+                                               int fidx2, int n2);
+
+LUA_API int (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
+LUA_API lua_Hook (lua_gethook) (lua_State *L);
+LUA_API int (lua_gethookmask) (lua_State *L);
+LUA_API int (lua_gethookcount) (lua_State *L);
+
+
+struct lua_Debug {
+  int event;
+  const char *name;	/* (n) */
+  const char *namewhat;	/* (n) 'global', 'local', 'field', 'method' */
+  const char *what;	/* (S) 'Lua', 'C', 'main', 'tail' */
+  const char *source;	/* (S) */
+  int currentline;	/* (l) */
+  int linedefined;	/* (S) */
+  int lastlinedefined;	/* (S) */
+  unsigned char nups;	/* (u) number of upvalues */
+  unsigned char nparams;/* (u) number of parameters */
+  char isvararg;        /* (u) */
+  char istailcall;	/* (t) */
+  char short_src[LUA_IDSIZE]; /* (S) */
+  /* private part */
+  struct CallInfo *i_ci;  /* active function */
+};
+
+/* }====================================================================== */
+
+
+/******************************************************************************
+* Copyright (C) 1994-2012 Lua.org, PUC-Rio.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
+
+
+#endif
diff --git a/dep/lualib/lua.hpp b/dep/lualib/lua.hpp
new file mode 100644
index 0000000..ec417f5
--- /dev/null
+++ b/dep/lualib/lua.hpp
@@ -0,0 +1,9 @@
+// lua.hpp
+// Lua header files for C++
+// <<extern "C">> not supplied automatically because Lua also compiles as C++
+
+extern "C" {
+#include "lua.h"
+#include "lualib.h"
+#include "lauxlib.h"
+}
diff --git a/dep/lualib/luaconf.h b/dep/lualib/luaconf.h
new file mode 100644
index 0000000..e4335df
--- /dev/null
+++ b/dep/lualib/luaconf.h
@@ -0,0 +1,546 @@
+/*
+** $Id: luaconf.h,v 1.172 2012/05/11 14:14:42 roberto Exp $
+** Configuration file for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lconfig_h
+#define lconfig_h
+
+#include <limits.h>
+#include <stddef.h>
+
+
+/*
+** ==================================================================
+** Search for "@@" to find all configurable definitions.
+** ===================================================================
+*/
+
+
+/*
+@@ LUA_ANSI controls the use of non-ansi features.
+** CHANGE it (define it) if you want Lua to avoid the use of any
+** non-ansi feature or library.
+*/
+#if !defined(LUA_ANSI) && defined(__STRICT_ANSI__)
+#define LUA_ANSI
+#endif
+
+
+#if !defined(LUA_ANSI) && defined(_WIN32) && !defined(_WIN32_WCE)
+#define LUA_WIN		/* enable goodies for regular Windows platforms */
+#endif
+
+#if defined(LUA_WIN)
+#define LUA_DL_DLL
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#endif
+
+
+
+#if defined(LUA_USE_LINUX)
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
+#define LUA_USE_READLINE	/* needs some extra libraries */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hexa formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#define LUA_USE_LONGLONG	/* assume support for long long */
+#endif
+
+#if defined(LUA_USE_MACOSX)
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* does not need -ldl */
+#define LUA_USE_READLINE	/* needs an extra library: -lreadline */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hexa formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#define LUA_USE_LONGLONG	/* assume support for long long */
+#endif
+
+
+
+/*
+@@ LUA_USE_POSIX includes all functionality listed as X/Open System
+@* Interfaces Extension (XSI).
+** CHANGE it (define it) if your system is XSI compatible.
+*/
+#if defined(LUA_USE_POSIX)
+#define LUA_USE_MKSTEMP
+#define LUA_USE_ISATTY
+#define LUA_USE_POPEN
+#define LUA_USE_ULONGJMP
+#define LUA_USE_GMTIME_R
+#endif
+
+
+
+/*
+@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
+@* Lua libraries.
+@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
+@* C libraries.
+** CHANGE them if your machine has a non-conventional directory
+** hierarchy or if you want to install your libraries in
+** non-conventional directories.
+*/
+#if defined(_WIN32)	/* { */
+/*
+** In Windows, any exclamation mark ('!') in the path is replaced by the
+** path of the directory of the executable file of the current process.
+*/
+#define LUA_LDIR	"!\\lua\\"
+#define LUA_CDIR	"!\\"
+#define LUA_PATH_DEFAULT  \
+		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
+		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" ".\\?.lua"
+#define LUA_CPATH_DEFAULT \
+		LUA_CDIR"?.dll;" LUA_CDIR"loadall.dll;" ".\\?.dll"
+
+#else			/* }{ */
+
+#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR "/"
+#define LUA_ROOT	"/usr/local/"
+#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR
+#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR
+#define LUA_PATH_DEFAULT  \
+		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
+		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" "./?.lua"
+#define LUA_CPATH_DEFAULT \
+		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so"
+#endif			/* } */
+
+
+/*
+@@ LUA_DIRSEP is the directory separator (for submodules).
+** CHANGE it if your machine does not use "/" as the directory separator
+** and is not Windows. (On Windows Lua automatically uses "\".)
+*/
+#if defined(_WIN32)
+#define LUA_DIRSEP	"\\"
+#else
+#define LUA_DIRSEP	"/"
+#endif
+
+
+/*
+@@ LUA_ENV is the name of the variable that holds the current
+@@ environment, used to access global names.
+** CHANGE it if you do not like this name.
+*/
+#define LUA_ENV		"_ENV"
+
+
+/*
+@@ LUA_API is a mark for all core API functions.
+@@ LUALIB_API is a mark for all auxiliary library functions.
+@@ LUAMOD_API is a mark for all standard library opening functions.
+** CHANGE them if you need to define those functions in some special way.
+** For instance, if you want to create one Windows DLL with the core and
+** the libraries, you may want to use the following definition (define
+** LUA_BUILD_AS_DLL to get it).
+*/
+#if defined(LUA_BUILD_AS_DLL)	/* { */
+
+#if defined(LUA_CORE) || defined(LUA_LIB)	/* { */
+#define LUA_API __declspec(dllexport)
+#else						/* }{ */
+#define LUA_API __declspec(dllimport)
+#endif						/* } */
+
+#else				/* }{ */
+
+#define LUA_API		extern
+
+#endif				/* } */
+
+
+/* more often than not the libs go together with the core */
+#define LUALIB_API	LUA_API
+#define LUAMOD_API	LUALIB_API
+
+
+/*
+@@ LUAI_FUNC is a mark for all extern functions that are not to be
+@* exported to outside modules.
+@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables
+@* that are not to be exported to outside modules (LUAI_DDEF for
+@* definitions and LUAI_DDEC for declarations).
+** CHANGE them if you need to mark them in some special way. Elf/gcc
+** (versions 3.2 and later) mark them as "hidden" to optimize access
+** when Lua is compiled as a shared library. Not all elf targets support
+** this attribute. Unfortunately, gcc does not offer a way to check
+** whether the target offers that support, and those without support
+** give a warning about it. To avoid these warnings, change to the
+** default definition.
+*/
+#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
+    defined(__ELF__)		/* { */
+#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
+#define LUAI_DDEC	LUAI_FUNC
+#define LUAI_DDEF	/* empty */
+
+#else				/* }{ */
+#define LUAI_FUNC	extern
+#define LUAI_DDEC	extern
+#define LUAI_DDEF	/* empty */
+#endif				/* } */
+
+
+
+/*
+@@ LUA_QL describes how error messages quote program elements.
+** CHANGE it if you want a different appearance.
+*/
+#define LUA_QL(x)	"'" x "'"
+#define LUA_QS		LUA_QL("%s")
+
+
+/*
+@@ LUA_IDSIZE gives the maximum size for the description of the source
+@* of a function in debug information.
+** CHANGE it if you want a different size.
+*/
+#define LUA_IDSIZE	60
+
+
+/*
+@@ luai_writestring/luai_writeline define how 'print' prints its results.
+** They are only used in libraries and the stand-alone program. (The #if
+** avoids including 'stdio.h' everywhere.)
+*/
+#if defined(LUA_LIB) || defined(lua_c)
+#include <stdio.h>
+#define luai_writestring(s,l)	fwrite((s), sizeof(char), (l), stdout)
+#define luai_writeline()	(luai_writestring("\n", 1), fflush(stdout))
+#endif
+
+/*
+@@ luai_writestringerror defines how to print error messages.
+** (A format string with one argument is enough for Lua...)
+*/
+#define luai_writestringerror(s,p) \
+	(fprintf(stderr, (s), (p)), fflush(stderr))
+
+
+/*
+@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,
+** strings that are internalized. (Cannot be smaller than reserved words
+** or tags for metamethods, as these strings must be internalized;
+** #("function") = 8, #("__newindex") = 10.)
+*/
+#define LUAI_MAXSHORTLEN        40
+
+
+
+/*
+** {==================================================================
+** Compatibility with previous versions
+** ===================================================================
+*/
+
+/*
+@@ LUA_COMPAT_ALL controls all compatibility options.
+** You can define it to get all options, or change specific options
+** to fit your specific needs.
+*/
+#if defined(LUA_COMPAT_ALL)	/* { */
+
+/*
+@@ LUA_COMPAT_UNPACK controls the presence of global 'unpack'.
+** You can replace it with 'table.unpack'.
+*/
+#define LUA_COMPAT_UNPACK
+
+/*
+@@ LUA_COMPAT_LOADERS controls the presence of table 'package.loaders'.
+** You can replace it with 'package.searchers'.
+*/
+#define LUA_COMPAT_LOADERS
+
+/*
+@@ macro 'lua_cpcall' emulates deprecated function lua_cpcall.
+** You can call your C function directly (with light C functions).
+*/
+#define lua_cpcall(L,f,u)  \
+	(lua_pushcfunction(L, (f)), \
+	 lua_pushlightuserdata(L,(u)), \
+	 lua_pcall(L,1,0,0))
+
+
+/*
+@@ LUA_COMPAT_LOG10 defines the function 'log10' in the math library.
+** You can rewrite 'log10(x)' as 'log(x, 10)'.
+*/
+#define LUA_COMPAT_LOG10
+
+/*
+@@ LUA_COMPAT_LOADSTRING defines the function 'loadstring' in the base
+** library. You can rewrite 'loadstring(s)' as 'load(s)'.
+*/
+#define LUA_COMPAT_LOADSTRING
+
+/*
+@@ LUA_COMPAT_MAXN defines the function 'maxn' in the table library.
+*/
+#define LUA_COMPAT_MAXN
+
+/*
+@@ The following macros supply trivial compatibility for some
+** changes in the API. The macros themselves document how to
+** change your code to avoid using them.
+*/
+#define lua_strlen(L,i)		lua_rawlen(L, (i))
+
+#define lua_objlen(L,i)		lua_rawlen(L, (i))
+
+#define lua_equal(L,idx1,idx2)		lua_compare(L,(idx1),(idx2),LUA_OPEQ)
+#define lua_lessthan(L,idx1,idx2)	lua_compare(L,(idx1),(idx2),LUA_OPLT)
+
+/*
+@@ LUA_COMPAT_MODULE controls compatibility with previous
+** module functions 'module' (Lua) and 'luaL_register' (C).
+*/
+#define LUA_COMPAT_MODULE
+
+#endif				/* } */
+
+/* }================================================================== */
+
+
+
+/*
+@@ LUAI_BITSINT defines the number of bits in an int.
+** CHANGE here if Lua cannot automatically detect the number of bits of
+** your machine. Probably you do not need to change this.
+*/
+/* avoid overflows in comparison */
+#if INT_MAX-20 < 32760		/* { */
+#define LUAI_BITSINT	16
+#elif INT_MAX > 2147483640L	/* }{ */
+/* int has at least 32 bits */
+#define LUAI_BITSINT	32
+#else				/* }{ */
+#error "you must define LUA_BITSINT with number of bits in an integer"
+#endif				/* } */
+
+
+/*
+@@ LUA_INT32 is an signed integer with exactly 32 bits.
+@@ LUAI_UMEM is an unsigned integer big enough to count the total
+@* memory used by Lua.
+@@ LUAI_MEM is a signed integer big enough to count the total memory
+@* used by Lua.
+** CHANGE here if for some weird reason the default definitions are not
+** good enough for your machine. Probably you do not need to change
+** this.
+*/
+#if LUAI_BITSINT >= 32		/* { */
+#define LUA_INT32	int
+#define LUAI_UMEM	size_t
+#define LUAI_MEM	ptrdiff_t
+#else				/* }{ */
+/* 16-bit ints */
+#define LUA_INT32	long
+#define LUAI_UMEM	unsigned long
+#define LUAI_MEM	long
+#endif				/* } */
+
+
+/*
+@@ LUAI_MAXSTACK limits the size of the Lua stack.
+** CHANGE it if you need a different limit. This limit is arbitrary;
+** its only purpose is to stop Lua to consume unlimited stack
+** space (and to reserve some numbers for pseudo-indices).
+*/
+#if LUAI_BITSINT >= 32
+#define LUAI_MAXSTACK		1000000
+#else
+#define LUAI_MAXSTACK		15000
+#endif
+
+/* reserve some space for error handling */
+#define LUAI_FIRSTPSEUDOIDX	(-LUAI_MAXSTACK - 1000)
+
+
+
+
+/*
+@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
+** CHANGE it if it uses too much C-stack space.
+*/
+#define LUAL_BUFFERSIZE		BUFSIZ
+
+
+
+
+/*
+** {==================================================================
+@@ LUA_NUMBER is the type of numbers in Lua.
+** CHANGE the following definitions only if you want to build Lua
+** with a number type different from double. You may also need to
+** change lua_number2int & lua_number2integer.
+** ===================================================================
+*/
+
+#define LUA_NUMBER_DOUBLE
+#define LUA_NUMBER	double
+
+/*
+@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
+@* over a number.
+*/
+#define LUAI_UACNUMBER	double
+
+
+/*
+@@ LUA_NUMBER_SCAN is the format for reading numbers.
+@@ LUA_NUMBER_FMT is the format for writing numbers.
+@@ lua_number2str converts a number to a string.
+@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
+*/
+#define LUA_NUMBER_SCAN		"%lf"
+#define LUA_NUMBER_FMT		"%.14g"
+#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
+#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
+
+
+/*
+@@ lua_str2number converts a decimal numeric string to a number.
+@@ lua_strx2number converts an hexadecimal numeric string to a number.
+** In C99, 'strtod' do both conversions. C89, however, has no function
+** to convert floating hexadecimal strings to numbers. For these
+** systems, you can leave 'lua_strx2number' undefined and Lua will
+** provide its own implementation.
+*/
+#define lua_str2number(s,p)	strtod((s), (p))
+
+#if defined(LUA_USE_STRTODHEX)
+#define lua_strx2number(s,p)	strtod((s), (p))
+#endif
+
+
+/*
+@@ The luai_num* macros define the primitive operations over numbers.
+*/
+
+/* the following operations need the math library */
+#if defined(lobject_c) || defined(lvm_c)
+#include <math.h>
+#define luai_nummod(L,a,b)	((a) - floor((a)/(b))*(b))
+#define luai_numpow(L,a,b)	(pow(a,b))
+#endif
+
+/* these are quite standard operations */
+#if defined(LUA_CORE)
+#define luai_numadd(L,a,b)	((a)+(b))
+#define luai_numsub(L,a,b)	((a)-(b))
+#define luai_nummul(L,a,b)	((a)*(b))
+#define luai_numdiv(L,a,b)	((a)/(b))
+#define luai_numunm(L,a)	(-(a))
+#define luai_numeq(a,b)		((a)==(b))
+#define luai_numlt(L,a,b)	((a)<(b))
+#define luai_numle(L,a,b)	((a)<=(b))
+#define luai_numisnan(L,a)	(!luai_numeq((a), (a)))
+#endif
+
+
+
+/*
+@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
+** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
+** machines, ptrdiff_t gives a good choice between int or long.)
+*/
+#define LUA_INTEGER	ptrdiff_t
+
+/*
+@@ LUA_UNSIGNED is the integral type used by lua_pushunsigned/lua_tounsigned.
+** It must have at least 32 bits.
+*/
+#define LUA_UNSIGNED	unsigned LUA_INT32
+
+
+
+/*
+** Some tricks with doubles
+*/
+
+#if defined(LUA_CORE) && \
+    defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI)	/* { */
+/*
+** The next definitions activate some tricks to speed up the
+** conversion from doubles to integer types, mainly to LUA_UNSIGNED.
+**
+@@ MS_ASMTRICK uses Microsoft assembler to avoid clashes with a
+** DirectX idiosyncrasy.
+**
+@@ LUA_IEEE754TRICK uses a trick that should work on any machine
+** using IEEE754 with a 32-bit integer type.
+**
+@@ LUA_IEEELL extends the trick to LUA_INTEGER; should only be
+** defined when LUA_INTEGER is a 32-bit integer.
+**
+@@ LUA_IEEEENDIAN is the endianness of doubles in your machine
+** (0 for little endian, 1 for big endian); if not defined, Lua will
+** check it dynamically for LUA_IEEE754TRICK (but not for LUA_NANTRICK).
+**
+@@ LUA_NANTRICK controls the use of a trick to pack all types into
+** a single double value, using NaN values to represent non-number
+** values. The trick only works on 32-bit machines (ints and pointers
+** are 32-bit values) with numbers represented as IEEE 754-2008 doubles
+** with conventional endianess (12345678 or 87654321), in CPUs that do
+** not produce signaling NaN values (all NaNs are quiet).
+*/
+
+/* Microsoft compiler on a Pentium (32 bit) ? */
+#if defined(LUA_WIN) && defined(_MSC_VER) && defined(_M_IX86)	/* { */
+
+#define MS_ASMTRICK
+#define LUA_IEEEENDIAN		0
+#define LUA_NANTRICK
+
+
+/* pentium 32 bits? */
+#elif defined(__i386__) || defined(__i386) || defined(__X86__) /* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEELL
+#define LUA_IEEEENDIAN		0
+#define LUA_NANTRICK
+
+/* pentium 64 bits? */
+#elif defined(__x86_64)						/* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEEENDIAN		0
+
+#elif defined(__POWERPC__) || defined(__ppc__)			/* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEEENDIAN		1
+
+#else								/* }{ */
+
+/* assume IEEE754 and a 32-bit integer type */
+#define LUA_IEEE754TRICK
+
+#endif								/* } */
+
+#endif							/* } */
+
+/* }================================================================== */
+
+
+
+
+/* =================================================================== */
+
+/*
+** Local configuration. You can use this space to add your redefinitions
+** without modifying the main part of the file.
+*/
+
+
+
+#endif
+
diff --git a/dep/lualib/lualib.h b/dep/lualib/lualib.h
new file mode 100644
index 0000000..9fd126b
--- /dev/null
+++ b/dep/lualib/lualib.h
@@ -0,0 +1,55 @@
+/*
+** $Id: lualib.h,v 1.43 2011/12/08 12:11:37 roberto Exp $
+** Lua standard libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lualib_h
+#define lualib_h
+
+#include "lua.h"
+
+
+
+LUAMOD_API int (luaopen_base) (lua_State *L);
+
+#define LUA_COLIBNAME	"coroutine"
+LUAMOD_API int (luaopen_coroutine) (lua_State *L);
+
+#define LUA_TABLIBNAME	"table"
+LUAMOD_API int (luaopen_table) (lua_State *L);
+
+#define LUA_IOLIBNAME	"io"
+LUAMOD_API int (luaopen_io) (lua_State *L);
+
+#define LUA_OSLIBNAME	"os"
+LUAMOD_API int (luaopen_os) (lua_State *L);
+
+#define LUA_STRLIBNAME	"string"
+LUAMOD_API int (luaopen_string) (lua_State *L);
+
+#define LUA_BITLIBNAME	"bit32"
+LUAMOD_API int (luaopen_bit32) (lua_State *L);
+
+#define LUA_MATHLIBNAME	"math"
+LUAMOD_API int (luaopen_math) (lua_State *L);
+
+#define LUA_DBLIBNAME	"debug"
+LUAMOD_API int (luaopen_debug) (lua_State *L);
+
+#define LUA_LOADLIBNAME	"package"
+LUAMOD_API int (luaopen_package) (lua_State *L);
+
+
+/* open all previous libraries */
+LUALIB_API void (luaL_openlibs) (lua_State *L);
+
+
+
+#if !defined(lua_assert)
+#define lua_assert(x)	((void)0)
+#endif
+
+
+#endif
diff --git a/dep/lualib/lundump.c b/dep/lualib/lundump.c
new file mode 100644
index 0000000..54de011
--- /dev/null
+++ b/dep/lualib/lundump.c
@@ -0,0 +1,258 @@
+/*
+** $Id: lundump.c,v 2.22 2012/05/08 13:53:33 roberto Exp $
+** load precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lundump_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstring.h"
+#include "lundump.h"
+#include "lzio.h"
+
+typedef struct {
+ lua_State* L;
+ ZIO* Z;
+ Mbuffer* b;
+ const char* name;
+} LoadState;
+
+static l_noret error(LoadState* S, const char* why)
+{
+ luaO_pushfstring(S->L,"%s: %s precompiled chunk",S->name,why);
+ luaD_throw(S->L,LUA_ERRSYNTAX);
+}
+
+#define LoadMem(S,b,n,size)	LoadBlock(S,b,(n)*(size))
+#define LoadByte(S)		(lu_byte)LoadChar(S)
+#define LoadVar(S,x)		LoadMem(S,&x,1,sizeof(x))
+#define LoadVector(S,b,n,size)	LoadMem(S,b,n,size)
+
+#if !defined(luai_verifycode)
+#define luai_verifycode(L,b,f)	/* empty */
+#endif
+
+static void LoadBlock(LoadState* S, void* b, size_t size)
+{
+ if (luaZ_read(S->Z,b,size)!=0) error(S,"truncated");
+}
+
+static int LoadChar(LoadState* S)
+{
+ char x;
+ LoadVar(S,x);
+ return x;
+}
+
+static int LoadInt(LoadState* S)
+{
+ int x;
+ LoadVar(S,x);
+ if (x<0) error(S,"corrupted");
+ return x;
+}
+
+static lua_Number LoadNumber(LoadState* S)
+{
+ lua_Number x;
+ LoadVar(S,x);
+ return x;
+}
+
+static TString* LoadString(LoadState* S)
+{
+ size_t size;
+ LoadVar(S,size);
+ if (size==0)
+  return NULL;
+ else
+ {
+  char* s=luaZ_openspace(S->L,S->b,size);
+  LoadBlock(S,s,size*sizeof(char));
+  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
+ }
+}
+
+static void LoadCode(LoadState* S, Proto* f)
+{
+ int n=LoadInt(S);
+ f->code=luaM_newvector(S->L,n,Instruction);
+ f->sizecode=n;
+ LoadVector(S,f->code,n,sizeof(Instruction));
+}
+
+static void LoadFunction(LoadState* S, Proto* f);
+
+static void LoadConstants(LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->k=luaM_newvector(S->L,n,TValue);
+ f->sizek=n;
+ for (i=0; i<n; i++) setnilvalue(&f->k[i]);
+ for (i=0; i<n; i++)
+ {
+  TValue* o=&f->k[i];
+  int t=LoadChar(S);
+  switch (t)
+  {
+   case LUA_TNIL:
+	setnilvalue(o);
+	break;
+   case LUA_TBOOLEAN:
+	setbvalue(o,LoadChar(S));
+	break;
+   case LUA_TNUMBER:
+	setnvalue(o,LoadNumber(S));
+	break;
+   case LUA_TSTRING:
+	setsvalue2n(S->L,o,LoadString(S));
+	break;
+    default: lua_assert(0);
+  }
+ }
+ n=LoadInt(S);
+ f->p=luaM_newvector(S->L,n,Proto*);
+ f->sizep=n;
+ for (i=0; i<n; i++) f->p[i]=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->p[i]=luaF_newproto(S->L);
+  LoadFunction(S,f->p[i]);
+ }
+}
+
+static void LoadUpvalues(LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->upvalues=luaM_newvector(S->L,n,Upvaldesc);
+ f->sizeupvalues=n;
+ for (i=0; i<n; i++) f->upvalues[i].name=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->upvalues[i].instack=LoadByte(S);
+  f->upvalues[i].idx=LoadByte(S);
+ }
+}
+
+static void LoadDebug(LoadState* S, Proto* f)
+{
+ int i,n;
+ f->source=LoadString(S);
+ n=LoadInt(S);
+ f->lineinfo=luaM_newvector(S->L,n,int);
+ f->sizelineinfo=n;
+ LoadVector(S,f->lineinfo,n,sizeof(int));
+ n=LoadInt(S);
+ f->locvars=luaM_newvector(S->L,n,LocVar);
+ f->sizelocvars=n;
+ for (i=0; i<n; i++) f->locvars[i].varname=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->locvars[i].varname=LoadString(S);
+  f->locvars[i].startpc=LoadInt(S);
+  f->locvars[i].endpc=LoadInt(S);
+ }
+ n=LoadInt(S);
+ for (i=0; i<n; i++) f->upvalues[i].name=LoadString(S);
+}
+
+static void LoadFunction(LoadState* S, Proto* f)
+{
+ f->linedefined=LoadInt(S);
+ f->lastlinedefined=LoadInt(S);
+ f->numparams=LoadByte(S);
+ f->is_vararg=LoadByte(S);
+ f->maxstacksize=LoadByte(S);
+ LoadCode(S,f);
+ LoadConstants(S,f);
+ LoadUpvalues(S,f);
+ LoadDebug(S,f);
+}
+
+/* the code below must be consistent with the code in luaU_header */
+#define N0	LUAC_HEADERSIZE
+#define N1	(sizeof(LUA_SIGNATURE)-sizeof(char))
+#define N2	N1+2
+#define N3	N2+6
+
+static void LoadHeader(LoadState* S)
+{
+ lu_byte h[LUAC_HEADERSIZE];
+ lu_byte s[LUAC_HEADERSIZE];
+ luaU_header(h);
+ memcpy(s,h,sizeof(char));			/* first char already read */
+ LoadBlock(S,s+sizeof(char),LUAC_HEADERSIZE-sizeof(char));
+ if (memcmp(h,s,N0)==0) return;
+ if (memcmp(h,s,N1)!=0) error(S,"not a");
+ if (memcmp(h,s,N2)!=0) error(S,"version mismatch in");
+ if (memcmp(h,s,N3)!=0) error(S,"incompatible"); else error(S,"corrupted");
+}
+
+/*
+** load precompiled chunk
+*/
+Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
+{
+ LoadState S;
+ Closure* cl;
+ if (*name=='@' || *name=='=')
+  S.name=name+1;
+ else if (*name==LUA_SIGNATURE[0])
+  S.name="binary string";
+ else
+  S.name=name;
+ S.L=L;
+ S.Z=Z;
+ S.b=buff;
+ LoadHeader(&S);
+ cl=luaF_newLclosure(L,1);
+ setclLvalue(L,L->top,cl); incr_top(L);
+ cl->l.p=luaF_newproto(L);
+ LoadFunction(&S,cl->l.p);
+ if (cl->l.p->sizeupvalues != 1)
+ {
+  Proto* p=cl->l.p;
+  cl=luaF_newLclosure(L,cl->l.p->sizeupvalues);
+  cl->l.p=p;
+  setclLvalue(L,L->top-1,cl);
+ }
+ luai_verifycode(L,buff,cl->l.p);
+ return cl;
+}
+
+#define MYINT(s)	(s[0]-'0')
+#define VERSION		MYINT(LUA_VERSION_MAJOR)*16+MYINT(LUA_VERSION_MINOR)
+#define FORMAT		0		/* this is the official format */
+
+/*
+* make header for precompiled chunks
+* if you change the code below be sure to update LoadHeader and FORMAT above
+* and LUAC_HEADERSIZE in lundump.h
+*/
+void luaU_header (lu_byte* h)
+{
+ int x=1;
+ memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-sizeof(char));
+ h+=sizeof(LUA_SIGNATURE)-sizeof(char);
+ *h++=cast_byte(VERSION);
+ *h++=cast_byte(FORMAT);
+ *h++=cast_byte(*(char*)&x);			/* endianness */
+ *h++=cast_byte(sizeof(int));
+ *h++=cast_byte(sizeof(size_t));
+ *h++=cast_byte(sizeof(Instruction));
+ *h++=cast_byte(sizeof(lua_Number));
+ *h++=cast_byte(((lua_Number)0.5)==0);		/* is lua_Number integral? */
+ memcpy(h,LUAC_TAIL,sizeof(LUAC_TAIL)-sizeof(char));
+}
diff --git a/dep/lualib/lundump.h b/dep/lualib/lundump.h
new file mode 100644
index 0000000..2b8acce
--- /dev/null
+++ b/dep/lualib/lundump.h
@@ -0,0 +1,28 @@
+/*
+** $Id: lundump.h,v 1.39 2012/05/08 13:53:33 roberto Exp $
+** load precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lundump_h
+#define lundump_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+/* load one chunk; from lundump.c */
+LUAI_FUNC Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name);
+
+/* make header; from lundump.c */
+LUAI_FUNC void luaU_header (lu_byte* h);
+
+/* dump one chunk; from ldump.c */
+LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip);
+
+/* data to catch conversion errors */
+#define LUAC_TAIL		"\x19\x93\r\n\x1a\n"
+
+/* size in bytes of header of binary files */
+#define LUAC_HEADERSIZE		(sizeof(LUA_SIGNATURE)-sizeof(char)+2+6+sizeof(LUAC_TAIL)-sizeof(char))
+
+#endif
diff --git a/dep/lualib/lvm.c b/dep/lualib/lvm.c
new file mode 100644
index 0000000..b77eac2
--- /dev/null
+++ b/dep/lualib/lvm.c
@@ -0,0 +1,868 @@
+/*
+** $Id: lvm.c,v 2.152 2012/06/08 15:14:04 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lvm_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+/* limit for table tag-method chains (to avoid loops) */
+#define MAXTAGLOOP	100
+
+
+const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
+  lua_Number num;
+  if (ttisnumber(obj)) return obj;
+  if (ttisstring(obj) && luaO_str2d(svalue(obj), tsvalue(obj)->len, &num)) {
+    setnvalue(n, num);
+    return n;
+  }
+  else
+    return NULL;
+}
+
+
+int luaV_tostring (lua_State *L, StkId obj) {
+  if (!ttisnumber(obj))
+    return 0;
+  else {
+    char s[LUAI_MAXNUMBER2STR];
+    lua_Number n = nvalue(obj);
+    int l = lua_number2str(s, n);
+    setsvalue2s(L, obj, luaS_newlstr(L, s, l));
+    return 1;
+  }
+}
+
+
+static void traceexec (lua_State *L) {
+  CallInfo *ci = L->ci;
+  lu_byte mask = L->hookmask;
+  int counthook = ((mask & LUA_MASKCOUNT) && L->hookcount == 0);
+  if (counthook)
+    resethookcount(L);  /* reset count */
+  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */
+    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
+    return;  /* do not call hook again (VM yielded, so it did not move) */
+  }
+  if (counthook)
+    luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */
+  if (mask & LUA_MASKLINE) {
+    Proto *p = ci_func(ci)->p;
+    int npc = pcRel(ci->u.l.savedpc, p);
+    int newline = getfuncline(p, npc);
+    if (npc == 0 ||  /* call linehook when enter a new function, */
+        ci->u.l.savedpc <= L->oldpc ||  /* when jump back (loop), or when */
+        newline != getfuncline(p, pcRel(L->oldpc, p)))  /* enter a new line */
+      luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */
+  }
+  L->oldpc = ci->u.l.savedpc;
+  if (L->status == LUA_YIELD) {  /* did hook yield? */
+    if (counthook)
+      L->hookcount = 1;  /* undo decrement to zero */
+    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
+    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yieled */
+    ci->func = L->top - 1;  /* protect stack below results */
+    luaD_throw(L, LUA_YIELD);
+  }
+}
+
+
+static void callTM (lua_State *L, const TValue *f, const TValue *p1,
+                    const TValue *p2, TValue *p3, int hasres) {
+  ptrdiff_t result = savestack(L, p3);
+  setobj2s(L, L->top++, f);  /* push function */
+  setobj2s(L, L->top++, p1);  /* 1st argument */
+  setobj2s(L, L->top++, p2);  /* 2nd argument */
+  if (!hasres)  /* no result? 'p3' is third argument */
+    setobj2s(L, L->top++, p3);  /* 3rd argument */
+  luaD_checkstack(L, 0);
+  /* metamethod may yield only when called from Lua code */
+  luaD_call(L, L->top - (4 - hasres), hasres, isLua(L->ci));
+  if (hasres) {  /* if has result, move it to its place */
+    p3 = restorestack(L, result);
+    setobjs2s(L, p3, --L->top);
+  }
+}
+
+
+void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
+  int loop;
+  for (loop = 0; loop < MAXTAGLOOP; loop++) {
+    const TValue *tm;
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      const TValue *res = luaH_get(h, key); /* do a primitive get */
+      if (!ttisnil(res) ||  /* result is not nil? */
+          (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) { /* or no TM? */
+        setobj2s(L, val, res);
+        return;
+      }
+      /* else will try the tag method */
+    }
+    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
+      luaG_typeerror(L, t, "index");
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val, 1);
+      return;
+    }
+    t = tm;  /* else repeat with 'tm' */
+  }
+  luaG_runerror(L, "loop in gettable");
+}
+
+
+void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
+  int loop;
+  for (loop = 0; loop < MAXTAGLOOP; loop++) {
+    const TValue *tm;
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      TValue *oldval = cast(TValue *, luaH_get(h, key));
+      /* if previous value is not nil, there must be a previous entry
+         in the table; moreover, a metamethod has no relevance */
+      if (!ttisnil(oldval) ||
+         /* previous value is nil; must check the metamethod */
+         ((tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL &&
+         /* no metamethod; is there a previous entry in the table? */
+         (oldval != luaO_nilobject ||
+         /* no previous entry; must create one. (The next test is
+            always true; we only need the assignment.) */
+         (oldval = luaH_newkey(L, h, key), 1)))) {
+        /* no metamethod and (now) there is an entry with given key */
+        setobj2t(L, oldval, val);  /* assign new value to that entry */
+        invalidateTMcache(h);
+        luaC_barrierback(L, obj2gco(h), val);
+        return;
+      }
+      /* else will try the metamethod */
+    }
+    else  /* not a table; check metamethod */
+      if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
+        luaG_typeerror(L, t, "index");
+    /* there is a metamethod */
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val, 0);
+      return;
+    }
+    t = tm;  /* else repeat with 'tm' */
+  }
+  luaG_runerror(L, "loop in settable");
+}
+
+
+static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
+                       StkId res, TMS event) {
+  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
+  if (ttisnil(tm))
+    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
+  if (ttisnil(tm)) return 0;
+  callTM(L, tm, p1, p2, res, 1);
+  return 1;
+}
+
+
+static const TValue *get_equalTM (lua_State *L, Table *mt1, Table *mt2,
+                                  TMS event) {
+  const TValue *tm1 = fasttm(L, mt1, event);
+  const TValue *tm2;
+  if (tm1 == NULL) return NULL;  /* no metamethod */
+  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
+  tm2 = fasttm(L, mt2, event);
+  if (tm2 == NULL) return NULL;  /* no metamethod */
+  if (luaV_rawequalobj(tm1, tm2))  /* same metamethods? */
+    return tm1;
+  return NULL;
+}
+
+
+static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
+                         TMS event) {
+  if (!call_binTM(L, p1, p2, L->top, event))
+    return -1;  /* no metamethod */
+  else
+    return !l_isfalse(L->top);
+}
+
+
+static int l_strcmp (const TString *ls, const TString *rs) {
+  const char *l = getstr(ls);
+  size_t ll = ls->tsv.len;
+  const char *r = getstr(rs);
+  size_t lr = rs->tsv.len;
+  for (;;) {
+    int temp = strcoll(l, r);
+    if (temp != 0) return temp;
+    else {  /* strings are equal up to a `\0' */
+      size_t len = strlen(l);  /* index of first `\0' in both strings */
+      if (len == lr)  /* r is finished? */
+        return (len == ll) ? 0 : 1;
+      else if (len == ll)  /* l is finished? */
+        return -1;  /* l is smaller than r (because r is not finished) */
+      /* both strings longer than `len'; go on comparing (after the `\0') */
+      len++;
+      l += len; ll -= len; r += len; lr -= len;
+    }
+  }
+}
+
+
+int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
+  int res;
+  if (ttisnumber(l) && ttisnumber(r))
+    return luai_numlt(L, nvalue(l), nvalue(r));
+  else if (ttisstring(l) && ttisstring(r))
+    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
+  else if ((res = call_orderTM(L, l, r, TM_LT)) < 0)
+    luaG_ordererror(L, l, r);
+  return res;
+}
+
+
+int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {
+  int res;
+  if (ttisnumber(l) && ttisnumber(r))
+    return luai_numle(L, nvalue(l), nvalue(r));
+  else if (ttisstring(l) && ttisstring(r))
+    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
+  else if ((res = call_orderTM(L, l, r, TM_LE)) >= 0)  /* first try `le' */
+    return res;
+  else if ((res = call_orderTM(L, r, l, TM_LT)) < 0)  /* else try `lt' */
+    luaG_ordererror(L, l, r);
+  return !res;
+}
+
+
+/*
+** equality of Lua values. L == NULL means raw equality (no metamethods)
+*/
+int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2) {
+  const TValue *tm;
+  lua_assert(ttisequal(t1, t2));
+  switch (ttype(t1)) {
+    case LUA_TNIL: return 1;
+    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
+    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TLCF: return fvalue(t1) == fvalue(t2);
+    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));
+    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));
+    case LUA_TUSERDATA: {
+      if (uvalue(t1) == uvalue(t2)) return 1;
+      else if (L == NULL) return 0;
+      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    case LUA_TTABLE: {
+      if (hvalue(t1) == hvalue(t2)) return 1;
+      else if (L == NULL) return 0;
+      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    default:
+      lua_assert(iscollectable(t1));
+      return gcvalue(t1) == gcvalue(t2);
+  }
+  if (tm == NULL) return 0;  /* no TM? */
+  callTM(L, tm, t1, t2, L->top, 1);  /* call TM */
+  return !l_isfalse(L->top);
+}
+
+
+void luaV_concat (lua_State *L, int total) {
+  lua_assert(total >= 2);
+  do {
+    StkId top = L->top;
+    int n = 2;  /* number of elements handled in this pass (at least 2) */
+    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
+      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
+        luaG_concaterror(L, top-2, top-1);
+    }
+    else if (tsvalue(top-1)->len == 0)  /* second operand is empty? */
+      (void)tostring(L, top - 2);  /* result is first operand */
+    else if (ttisstring(top-2) && tsvalue(top-2)->len == 0) {
+      setobjs2s(L, top - 2, top - 1);  /* result is second op. */
+    }
+    else {
+      /* at least two non-empty string values; get as many as possible */
+      size_t tl = tsvalue(top-1)->len;
+      char *buffer;
+      int i;
+      /* collect total length */
+      for (i = 1; i < total && tostring(L, top-i-1); i++) {
+        size_t l = tsvalue(top-i-1)->len;
+        if (l >= (MAX_SIZET/sizeof(char)) - tl)
+          luaG_runerror(L, "string length overflow");
+        tl += l;
+      }
+      buffer = luaZ_openspace(L, &G(L)->buff, tl);
+      tl = 0;
+      n = i;
+      do {  /* concat all strings */
+        size_t l = tsvalue(top-i)->len;
+        memcpy(buffer+tl, svalue(top-i), l * sizeof(char));
+        tl += l;
+      } while (--i > 0);
+      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
+    }
+    total -= n-1;  /* got 'n' strings to create 1 new */
+    L->top -= n-1;  /* popped 'n' strings and pushed one */
+  } while (total > 1);  /* repeat until only 1 result left */
+}
+
+
+void luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {
+  const TValue *tm;
+  switch (ttypenv(rb)) {
+    case LUA_TTABLE: {
+      Table *h = hvalue(rb);
+      tm = fasttm(L, h->metatable, TM_LEN);
+      if (tm) break;  /* metamethod? break switch to call it */
+      setnvalue(ra, cast_num(luaH_getn(h)));  /* else primitive len */
+      return;
+    }
+    case LUA_TSTRING: {
+      setnvalue(ra, cast_num(tsvalue(rb)->len));
+      return;
+    }
+    default: {  /* try metamethod */
+      tm = luaT_gettmbyobj(L, rb, TM_LEN);
+      if (ttisnil(tm))  /* no metamethod? */
+        luaG_typeerror(L, rb, "get length of");
+      break;
+    }
+  }
+  callTM(L, tm, rb, rb, ra, 1);
+}
+
+
+void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
+                 const TValue *rc, TMS op) {
+  TValue tempb, tempc;
+  const TValue *b, *c;
+  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
+      (c = luaV_tonumber(rc, &tempc)) != NULL) {
+    lua_Number res = luaO_arith(op - TM_ADD + LUA_OPADD, nvalue(b), nvalue(c));
+    setnvalue(ra, res);
+  }
+  else if (!call_binTM(L, rb, rc, ra, op))
+    luaG_aritherror(L, rb, rc);
+}
+
+
+/*
+** check whether cached closure in prototype 'p' may be reused, that is,
+** whether there is a cached closure with the same upvalues needed by
+** new closure to be created.
+*/
+static Closure *getcached (Proto *p, UpVal **encup, StkId base) {
+  Closure *c = p->cache;
+  if (c != NULL) {  /* is there a cached closure? */
+    int nup = p->sizeupvalues;
+    Upvaldesc *uv = p->upvalues;
+    int i;
+    for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */
+      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;
+      if (c->l.upvals[i]->v != v)
+        return NULL;  /* wrong upvalue; cannot reuse closure */
+    }
+  }
+  return c;  /* return cached closure (or NULL if no cached closure) */
+}
+
+
+/*
+** create a new Lua closure, push it in the stack, and initialize
+** its upvalues. Note that the call to 'luaC_barrierproto' must come
+** before the assignment to 'p->cache', as the function needs the
+** original value of that field.
+*/
+static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,
+                         StkId ra) {
+  int nup = p->sizeupvalues;
+  Upvaldesc *uv = p->upvalues;
+  int i;
+  Closure *ncl = luaF_newLclosure(L, nup);
+  ncl->l.p = p;
+  setclLvalue(L, ra, ncl);  /* anchor new closure in stack */
+  for (i = 0; i < nup; i++) {  /* fill in its upvalues */
+    if (uv[i].instack)  /* upvalue refers to local variable? */
+      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);
+    else  /* get upvalue from enclosing function */
+      ncl->l.upvals[i] = encup[uv[i].idx];
+  }
+  luaC_barrierproto(L, p, ncl);
+  p->cache = ncl;  /* save it on cache for reuse */
+}
+
+
+/*
+** finish execution of an opcode interrupted by an yield
+*/
+void luaV_finishOp (lua_State *L) {
+  CallInfo *ci = L->ci;
+  StkId base = ci->u.l.base;
+  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */
+  OpCode op = GET_OPCODE(inst);
+  switch (op) {  /* finish its execution */
+    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:
+    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:
+    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {
+      setobjs2s(L, base + GETARG_A(inst), --L->top);
+      break;
+    }
+    case OP_LE: case OP_LT: case OP_EQ: {
+      int res = !l_isfalse(L->top - 1);
+      L->top--;
+      /* metamethod should not be called when operand is K */
+      lua_assert(!ISK(GETARG_B(inst)));
+      if (op == OP_LE &&  /* "<=" using "<" instead? */
+          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))
+        res = !res;  /* invert result */
+      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);
+      if (res != GETARG_A(inst))  /* condition failed? */
+        ci->u.l.savedpc++;  /* skip jump instruction */
+      break;
+    }
+    case OP_CONCAT: {
+      StkId top = L->top - 1;  /* top when 'call_binTM' was called */
+      int b = GETARG_B(inst);      /* first element to concatenate */
+      int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */
+      setobj2s(L, top - 2, top);  /* put TM result in proper position */
+      if (total > 1) {  /* are there elements to concat? */
+        L->top = top - 1;  /* top is one after last element (at top-2) */
+        luaV_concat(L, total);  /* concat them (may yield again) */
+      }
+      /* move final result to final position */
+      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);
+      L->top = ci->top;  /* restore top */
+      break;
+    }
+    case OP_TFORCALL: {
+      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);
+      L->top = ci->top;  /* correct top */
+      break;
+    }
+    case OP_CALL: {
+      if (GETARG_C(inst) - 1 >= 0)  /* nresults >= 0? */
+        L->top = ci->top;  /* adjust results */
+      break;
+    }
+    case OP_TAILCALL: case OP_SETTABUP:  case OP_SETTABLE:
+      break;
+    default: lua_assert(0);
+  }
+}
+
+
+
+/*
+** some macros for common tasks in `luaV_execute'
+*/
+
+#if !defined luai_runtimecheck
+#define luai_runtimecheck(L, c)		/* void */
+#endif
+
+
+#define RA(i)	(base+GETARG_A(i))
+/* to be used after possible stack reallocation */
+#define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
+#define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
+#define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
+	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
+#define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
+	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
+#define KBx(i)  \
+  (k + (GETARG_Bx(i) != 0 ? GETARG_Bx(i) - 1 : GETARG_Ax(*ci->u.l.savedpc++)))
+
+
+/* execute a jump instruction */
+#define dojump(ci,i,e) \
+  { int a = GETARG_A(i); \
+    if (a > 0) luaF_close(L, ci->u.l.base + a - 1); \
+    ci->u.l.savedpc += GETARG_sBx(i) + e; }
+
+/* for test instructions, execute the jump instruction that follows it */
+#define donextjump(ci)	{ i = *ci->u.l.savedpc; dojump(ci, i, 1); }
+
+
+#define Protect(x)	{ {x;}; base = ci->u.l.base; }
+
+#define checkGC(L,c)  \
+  Protect( luaC_condGC(L,{L->top = (c);  /* limit of live values */ \
+                          luaC_step(L); \
+                          L->top = ci->top;})  /* restore top */ \
+           luai_threadyield(L); )
+
+
+#define arith_op(op,tm) { \
+        TValue *rb = RKB(i); \
+        TValue *rc = RKC(i); \
+        if (ttisnumber(rb) && ttisnumber(rc)) { \
+          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
+          setnvalue(ra, op(L, nb, nc)); \
+        } \
+        else { Protect(luaV_arith(L, ra, rb, rc, tm)); } }
+
+
+#define vmdispatch(o)	switch(o)
+#define vmcase(l,b)	case l: {b}  break;
+#define vmcasenb(l,b)	case l: {b}		/* nb = no break */
+
+void luaV_execute (lua_State *L) {
+  CallInfo *ci = L->ci;
+  LClosure *cl;
+  TValue *k;
+  StkId base;
+ newframe:  /* reentry point when frame changes (call/return) */
+  lua_assert(ci == L->ci);
+  cl = clLvalue(ci->func);
+  k = cl->p->k;
+  base = ci->u.l.base;
+  /* main loop of interpreter */
+  for (;;) {
+    Instruction i = *(ci->u.l.savedpc++);
+    StkId ra;
+    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
+        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
+      Protect(traceexec(L));
+    }
+    /* WARNING: several calls may realloc the stack and invalidate `ra' */
+    ra = RA(i);
+    lua_assert(base == ci->u.l.base);
+    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
+    vmdispatch (GET_OPCODE(i)) {
+      vmcase(OP_MOVE,
+        setobjs2s(L, ra, RB(i));
+      )
+      vmcase(OP_LOADK,
+        TValue *rb = k + GETARG_Bx(i);
+        setobj2s(L, ra, rb);
+      )
+      vmcase(OP_LOADKX,
+        TValue *rb;
+        lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
+        rb = k + GETARG_Ax(*ci->u.l.savedpc++);
+        setobj2s(L, ra, rb);
+      )
+      vmcase(OP_LOADBOOL,
+        setbvalue(ra, GETARG_B(i));
+        if (GETARG_C(i)) ci->u.l.savedpc++;  /* skip next instruction (if C) */
+      )
+      vmcase(OP_LOADNIL,
+        int b = GETARG_B(i);
+        do {
+          setnilvalue(ra++);
+        } while (b--);
+      )
+      vmcase(OP_GETUPVAL,
+        int b = GETARG_B(i);
+        setobj2s(L, ra, cl->upvals[b]->v);
+      )
+      vmcase(OP_GETTABUP,
+        int b = GETARG_B(i);
+        Protect(luaV_gettable(L, cl->upvals[b]->v, RKC(i), ra));
+      )
+      vmcase(OP_GETTABLE,
+        Protect(luaV_gettable(L, RB(i), RKC(i), ra));
+      )
+      vmcase(OP_SETTABUP,
+        int a = GETARG_A(i);
+        Protect(luaV_settable(L, cl->upvals[a]->v, RKB(i), RKC(i)));
+      )
+      vmcase(OP_SETUPVAL,
+        UpVal *uv = cl->upvals[GETARG_B(i)];
+        setobj(L, uv->v, ra);
+        luaC_barrier(L, uv, ra);
+      )
+      vmcase(OP_SETTABLE,
+        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
+      )
+      vmcase(OP_NEWTABLE,
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        Table *t = luaH_new(L);
+        sethvalue(L, ra, t);
+        if (b != 0 || c != 0)
+          luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
+        checkGC(L, ra + 1);
+      )
+      vmcase(OP_SELF,
+        StkId rb = RB(i);
+        setobjs2s(L, ra+1, rb);
+        Protect(luaV_gettable(L, rb, RKC(i), ra));
+      )
+      vmcase(OP_ADD,
+        arith_op(luai_numadd, TM_ADD);
+      )
+      vmcase(OP_SUB,
+        arith_op(luai_numsub, TM_SUB);
+      )
+      vmcase(OP_MUL,
+        arith_op(luai_nummul, TM_MUL);
+      )
+      vmcase(OP_DIV,
+        arith_op(luai_numdiv, TM_DIV);
+      )
+      vmcase(OP_MOD,
+        arith_op(luai_nummod, TM_MOD);
+      )
+      vmcase(OP_POW,
+        arith_op(luai_numpow, TM_POW);
+      )
+      vmcase(OP_UNM,
+        TValue *rb = RB(i);
+        if (ttisnumber(rb)) {
+          lua_Number nb = nvalue(rb);
+          setnvalue(ra, luai_numunm(L, nb));
+        }
+        else {
+          Protect(luaV_arith(L, ra, rb, rb, TM_UNM));
+        }
+      )
+      vmcase(OP_NOT,
+        TValue *rb = RB(i);
+        int res = l_isfalse(rb);  /* next assignment may change this value */
+        setbvalue(ra, res);
+      )
+      vmcase(OP_LEN,
+        Protect(luaV_objlen(L, ra, RB(i)));
+      )
+      vmcase(OP_CONCAT,
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        StkId rb;
+        L->top = base + c + 1;  /* mark the end of concat operands */
+        Protect(luaV_concat(L, c - b + 1));
+        ra = RA(i);  /* 'luav_concat' may invoke TMs and move the stack */
+        rb = b + base;
+        setobjs2s(L, ra, rb);
+        checkGC(L, (ra >= rb ? ra + 1 : rb));
+        L->top = ci->top;  /* restore top */
+      )
+      vmcase(OP_JMP,
+        dojump(ci, i, 0);
+      )
+      vmcase(OP_EQ,
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        Protect(
+          if (cast_int(equalobj(L, rb, rc)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_LT,
+        Protect(
+          if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_LE,
+        Protect(
+          if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_TEST,
+        if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra))
+            ci->u.l.savedpc++;
+          else
+          donextjump(ci);
+      )
+      vmcase(OP_TESTSET,
+        TValue *rb = RB(i);
+        if (GETARG_C(i) ? l_isfalse(rb) : !l_isfalse(rb))
+          ci->u.l.savedpc++;
+        else {
+          setobjs2s(L, ra, rb);
+          donextjump(ci);
+        }
+      )
+      vmcase(OP_CALL,
+        int b = GETARG_B(i);
+        int nresults = GETARG_C(i) - 1;
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        if (luaD_precall(L, ra, nresults)) {  /* C function? */
+          if (nresults >= 0) L->top = ci->top;  /* adjust results */
+          base = ci->u.l.base;
+        }
+        else {  /* Lua function */
+          ci = L->ci;
+          ci->callstatus |= CIST_REENTRY;
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcase(OP_TAILCALL,
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
+        if (luaD_precall(L, ra, LUA_MULTRET))  /* C function? */
+          base = ci->u.l.base;
+        else {
+          /* tail call: put called frame (n) in place of caller one (o) */
+          CallInfo *nci = L->ci;  /* called frame */
+          CallInfo *oci = nci->previous;  /* caller frame */
+          StkId nfunc = nci->func;  /* called function */
+          StkId ofunc = oci->func;  /* caller function */
+          /* last stack slot filled by 'precall' */
+          StkId lim = nci->u.l.base + getproto(nfunc)->numparams;
+          int aux;
+          /* close all upvalues from previous call */
+          if (cl->p->sizep > 0) luaF_close(L, oci->u.l.base);
+          /* move new frame into old one */
+          for (aux = 0; nfunc + aux < lim; aux++)
+            setobjs2s(L, ofunc + aux, nfunc + aux);
+          oci->u.l.base = ofunc + (nci->u.l.base - nfunc);  /* correct base */
+          oci->top = L->top = ofunc + (L->top - nfunc);  /* correct top */
+          oci->u.l.savedpc = nci->u.l.savedpc;
+          oci->callstatus |= CIST_TAIL;  /* function was tail called */
+          ci = L->ci = oci;  /* remove new frame */
+          lua_assert(L->top == oci->u.l.base + getproto(ofunc)->maxstacksize);
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcasenb(OP_RETURN,
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b-1;
+        if (cl->p->sizep > 0) luaF_close(L, base);
+        b = luaD_poscall(L, ra);
+        if (!(ci->callstatus & CIST_REENTRY))  /* 'ci' still the called one */
+          return;  /* external invocation: return */
+        else {  /* invocation via reentry: continue execution */
+          ci = L->ci;
+          if (b) L->top = ci->top;
+          lua_assert(isLua(ci));
+          lua_assert(GET_OPCODE(*((ci)->u.l.savedpc - 1)) == OP_CALL);
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcase(OP_FORLOOP,
+        lua_Number step = nvalue(ra+2);
+        lua_Number idx = luai_numadd(L, nvalue(ra), step); /* increment index */
+        lua_Number limit = nvalue(ra+1);
+        if (luai_numlt(L, 0, step) ? luai_numle(L, idx, limit)
+                                   : luai_numle(L, limit, idx)) {
+          ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+          setnvalue(ra, idx);  /* update internal index... */
+          setnvalue(ra+3, idx);  /* ...and external index */
+        }
+      )
+      vmcase(OP_FORPREP,
+        const TValue *init = ra;
+        const TValue *plimit = ra+1;
+        const TValue *pstep = ra+2;
+        if (!tonumber(init, ra))
+          luaG_runerror(L, LUA_QL("for") " initial value must be a number");
+        else if (!tonumber(plimit, ra+1))
+          luaG_runerror(L, LUA_QL("for") " limit must be a number");
+        else if (!tonumber(pstep, ra+2))
+          luaG_runerror(L, LUA_QL("for") " step must be a number");
+        setnvalue(ra, luai_numsub(L, nvalue(ra), nvalue(pstep)));
+        ci->u.l.savedpc += GETARG_sBx(i);
+      )
+      vmcasenb(OP_TFORCALL,
+        StkId cb = ra + 3;  /* call base */
+        setobjs2s(L, cb+2, ra+2);
+        setobjs2s(L, cb+1, ra+1);
+        setobjs2s(L, cb, ra);
+        L->top = cb + 3;  /* func. + 2 args (state and index) */
+        Protect(luaD_call(L, cb, GETARG_C(i), 1));
+        L->top = ci->top;
+        i = *(ci->u.l.savedpc++);  /* go to next instruction */
+        ra = RA(i);
+        lua_assert(GET_OPCODE(i) == OP_TFORLOOP);
+        goto l_tforloop;
+      )
+      vmcase(OP_TFORLOOP,
+        l_tforloop:
+        if (!ttisnil(ra + 1)) {  /* continue loop? */
+          setobjs2s(L, ra, ra + 1);  /* save control variable */
+           ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+        }
+      )
+      vmcase(OP_SETLIST,
+        int n = GETARG_B(i);
+        int c = GETARG_C(i);
+        int last;
+        Table *h;
+        if (n == 0) n = cast_int(L->top - ra) - 1;
+        if (c == 0) {
+          lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
+          c = GETARG_Ax(*ci->u.l.savedpc++);
+        }
+        luai_runtimecheck(L, ttistable(ra));
+        h = hvalue(ra);
+        last = ((c-1)*LFIELDS_PER_FLUSH) + n;
+        if (last > h->sizearray)  /* needs more space? */
+          luaH_resizearray(L, h, last);  /* pre-allocate it at once */
+        for (; n > 0; n--) {
+          TValue *val = ra+n;
+          luaH_setint(L, h, last--, val);
+          luaC_barrierback(L, obj2gco(h), val);
+        }
+        L->top = ci->top;  /* correct top (in case of previous open call) */
+      )
+      vmcase(OP_CLOSURE,
+        Proto *p = cl->p->p[GETARG_Bx(i)];
+        Closure *ncl = getcached(p, cl->upvals, base);  /* cached closure */
+        if (ncl == NULL)  /* no match? */
+          pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
+        else
+          setclLvalue(L, ra, ncl);  /* push cashed closure */
+        checkGC(L, ra + 1);
+      )
+      vmcase(OP_VARARG,
+        int b = GETARG_B(i) - 1;
+        int j;
+        int n = cast_int(base - ci->func) - cl->p->numparams - 1;
+        if (b < 0) {  /* B == 0? */
+          b = n;  /* get all var. arguments */
+          Protect(luaD_checkstack(L, n));
+          ra = RA(i);  /* previous call may change the stack */
+          L->top = ra + n;
+        }
+        for (j = 0; j < b; j++) {
+          if (j < n) {
+            setobjs2s(L, ra + j, base - n + j);
+          }
+          else {
+            setnilvalue(ra + j);
+          }
+        }
+      )
+      vmcase(OP_EXTRAARG,
+        lua_assert(0);
+      )
+    }
+  }
+}
+
diff --git a/dep/lualib/lvm.h b/dep/lualib/lvm.h
new file mode 100644
index 0000000..ec35822
--- /dev/null
+++ b/dep/lualib/lvm.h
@@ -0,0 +1,45 @@
+/*
+** $Id: lvm.h,v 2.17 2011/05/31 18:27:56 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lvm_h
+#define lvm_h
+
+
+#include "ldo.h"
+#include "lobject.h"
+#include "ltm.h"
+
+
+#define tostring(L,o) (ttisstring(o) || (luaV_tostring(L, o)))
+
+#define tonumber(o,n)	(ttisnumber(o) || (((o) = luaV_tonumber(o,n)) != NULL))
+
+#define equalobj(L,o1,o2)  (ttisequal(o1, o2) && luaV_equalobj_(L, o1, o2))
+
+#define luaV_rawequalobj(t1,t2)  \
+        (ttisequal(t1,t2) && luaV_equalobj_(NULL,t1,t2))
+
+
+/* not to called directly */
+LUAI_FUNC int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2);
+
+
+LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
+LUAI_FUNC int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r);
+LUAI_FUNC const TValue *luaV_tonumber (const TValue *obj, TValue *n);
+LUAI_FUNC int luaV_tostring (lua_State *L, StkId obj);
+LUAI_FUNC void luaV_gettable (lua_State *L, const TValue *t, TValue *key,
+                                            StkId val);
+LUAI_FUNC void luaV_settable (lua_State *L, const TValue *t, TValue *key,
+                                            StkId val);
+LUAI_FUNC void luaV_finishOp (lua_State *L);
+LUAI_FUNC void luaV_execute (lua_State *L);
+LUAI_FUNC void luaV_concat (lua_State *L, int total);
+LUAI_FUNC void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
+                           const TValue *rc, TMS op);
+LUAI_FUNC void luaV_objlen (lua_State *L, StkId ra, const TValue *rb);
+
+#endif
diff --git a/dep/lualib/lzio.c b/dep/lualib/lzio.c
new file mode 100644
index 0000000..8b77054
--- /dev/null
+++ b/dep/lualib/lzio.c
@@ -0,0 +1,76 @@
+/*
+** $Id: lzio.c,v 1.35 2012/05/14 13:34:18 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lzio_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "llimits.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+int luaZ_fill (ZIO *z) {
+  size_t size;
+  lua_State *L = z->L;
+  const char *buff;
+  lua_unlock(L);
+  buff = z->reader(L, z->data, &size);
+  lua_lock(L);
+  if (buff == NULL || size == 0)
+    return EOZ;
+  z->n = size - 1;  /* discount char being returned */
+  z->p = buff;
+  return cast_uchar(*(z->p++));
+}
+
+
+void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
+  z->L = L;
+  z->reader = reader;
+  z->data = data;
+  z->n = 0;
+  z->p = NULL;
+}
+
+
+/* --------------------------------------------------------------- read --- */
+size_t luaZ_read (ZIO *z, void *b, size_t n) {
+  while (n) {
+    size_t m;
+    if (z->n == 0) {  /* no bytes in buffer? */
+      if (luaZ_fill(z) == EOZ)  /* try to read more */
+        return n;  /* no more input; return number of missing bytes */
+      else {
+        z->n++;  /* luaZ_fill consumed first byte; put it back */
+        z->p--;
+      }
+    }
+    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
+    memcpy(b, z->p, m);
+    z->n -= m;
+    z->p += m;
+    b = (char *)b + m;
+    n -= m;
+  }
+  return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
+  if (n > buff->buffsize) {
+    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;
+    luaZ_resizebuffer(L, buff, n);
+  }
+  return buff->buffer;
+}
+
+
diff --git a/dep/lualib/lzio.h b/dep/lualib/lzio.h
new file mode 100644
index 0000000..0868230
--- /dev/null
+++ b/dep/lualib/lzio.h
@@ -0,0 +1,65 @@
+/*
+** $Id: lzio.h,v 1.26 2011/07/15 12:48:03 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lzio_h
+#define lzio_h
+
+#include "lua.h"
+
+#include "lmem.h"
+
+
+#define EOZ	(-1)			/* end of stream */
+
+typedef struct Zio ZIO;
+
+#define zgetc(z)  (((z)->n--)>0 ?  cast_uchar(*(z)->p++) : luaZ_fill(z))
+
+
+typedef struct Mbuffer {
+  char *buffer;
+  size_t n;
+  size_t buffsize;
+} Mbuffer;
+
+#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
+
+#define luaZ_buffer(buff)	((buff)->buffer)
+#define luaZ_sizebuffer(buff)	((buff)->buffsize)
+#define luaZ_bufflen(buff)	((buff)->n)
+
+#define luaZ_resetbuffer(buff) ((buff)->n = 0)
+
+
+#define luaZ_resizebuffer(L, buff, size) \
+	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
+	(buff)->buffsize = size)
+
+#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)
+
+
+LUAI_FUNC char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
+LUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,
+                                        void *data);
+LUAI_FUNC size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
+
+
+
+/* --------- Private Part ------------------ */
+
+struct Zio {
+  size_t n;			/* bytes still unread */
+  const char *p;		/* current position in buffer */
+  lua_Reader reader;		/* reader function */
+  void* data;			/* additional data */
+  lua_State *L;			/* Lua state (for reader) */
+};
+
+
+LUAI_FUNC int luaZ_fill (ZIO *z);
+
+#endif
diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt
index e8816ea..9cadc9c 100644
--- a/src/server/CMakeLists.txt
+++ b/src/server/CMakeLists.txt
@@ -27,6 +27,7 @@ if( SERVERS )
   add_subdirectory(authserver)
   add_subdirectory(scripts)
   add_subdirectory(worldserver)
+  add_subdirectory(LuaEngine)
 else()
   if( TOOLS )
     add_subdirectory(collision)
diff --git a/src/server/LuaEngine/AuraMethods.h b/src/server/LuaEngine/AuraMethods.h
new file mode 100644
index 0000000..c40f36b
--- /dev/null
+++ b/src/server/LuaEngine/AuraMethods.h
@@ -0,0 +1,153 @@
+#ifndef AURAMETHODS_H
+#define AURAMETHODS_H
+
+class LuaAura
+{
+public:
+    // GetUnitType()
+    static int GetUnitType(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        Eluna::get()->PushString(L, "Aura");
+        return 1;
+    }
+
+    // GetCaster()
+    static int GetCaster(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        Eluna::get()->PushUnit(L, aura->GetCaster());
+        return 1;
+    }
+
+    // GetCasterGUID()
+    static int GetCasterGUID(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        Eluna::get()->PushGUID(L, aura->GetCasterGUID());
+        return 1;
+    }
+
+    // GetCasterLevel()
+    static int GetCasterLevel(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, aura->GetCasterLevel());
+        return 1;
+    }
+
+    // GetDuration()
+    static int GetDuration(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        Eluna::get()->PushInteger(L, aura->GetDuration());
+        return 1;
+    }
+
+    // GetCharges()
+    static int GetCharges(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, aura->GetCharges());
+        return 1;
+    }
+
+    // GetAuraId()
+    static int GetAuraId(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, aura->GetId());
+        return 1;
+    }
+
+    // GetMaxDuration()
+    static int GetMaxDuration(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        Eluna::get()->PushInteger(L, aura->GetMaxDuration());
+        return 1;
+    }
+
+    // GetStackAmount()
+    static int GetStackAmount(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, aura->GetStackAmount());
+        return 1;
+    }
+
+    // SetDuration()
+    static int SetDuration(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        int duration = luaL_checkinteger(L, 1);
+        aura->SetDuration(duration, false);
+        return 0;
+    }
+
+    // SetMaxDuration()
+    static int SetMaxDuration(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        int duration = luaL_checkinteger(L, 1);
+        aura->SetMaxDuration(duration);
+        return 0;
+    }
+
+    // SetStackAmount()
+    static int SetStackAmount(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        int amount = luaL_checkunsigned(L, 1);
+        aura->SetStackAmount(amount);
+        return 0;
+    }
+
+    // Remove()
+    static int Remove(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        aura->Remove();
+        return 0;
+    }
+
+    // GetOwner()
+    static int GetOwner(lua_State* L, Aura* aura)
+    {
+        if (!aura)
+            return 0;
+
+        if (aura->GetType() != UNIT_AURA_TYPE)
+            return 0;
+
+        Eluna::get()->PushUnit(L, aura->GetUnitOwner());
+        return 1;
+    }
+};
+#endif
diff --git a/src/server/LuaEngine/CMakeLists.txt b/src/server/LuaEngine/CMakeLists.txt
new file mode 100644
index 0000000..776cf13
--- /dev/null
+++ b/src/server/LuaEngine/CMakeLists.txt
@@ -0,0 +1,135 @@
+# Copyright (C) 2008-2013 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+if( USE_COREPCH )
+  include_directories(${CMAKE_CURRENT_BINARY_DIR})
+  include_directories(${CMAKE_SOURCE_DIR})
+endif()
+
+file(GLOB sources_localdir *.cpp *.h)
+
+set(LuaEngine_STAT_SRCS
+  ${LuaEngine_STAT_SRCS}
+  ${sources_localdir}
+)
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/SFMT
+  ${CMAKE_SOURCE_DIR}/dep/mersennetwister
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/dep/lualib
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/CountedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Policies
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/collision
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
+  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
+  ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/EventAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat/Channels
+  ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/DungeonFinding
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Corpse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/DynamicObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/GameObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Transport
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Events
+  ${CMAKE_SOURCE_DIR}/src/server/game/Globals
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Notifiers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
+  ${CMAKE_SOURCE_DIR}/src/server/game/Guilds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Instances
+  ${CMAKE_SOURCE_DIR}/src/server/game/LookingForGroup
+  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Mails
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/MovementGenerators
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
+  ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
+  ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/game/Pools
+  ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/game/Quests
+  ${CMAKE_SOURCE_DIR}/src/server/game/Reputation
+  ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Skills
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Weather
+  ${CMAKE_SOURCE_DIR}/src/server/game/World
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${ACE_INCLUDE_DIR}
+  ${MYSQL_INCLUDE_DIR}
+)
+
+add_library(LuaEngine STATIC 
+  ${LuaEngine_STAT_SRCS}
+  ${game_STAT_SRCS}
+  ${game_STAT_PCH_SRC}
+)
+
+target_link_libraries(LuaEngine
+  game
+)
+
+add_dependencies(LuaEngine game)
\ No newline at end of file
diff --git a/src/server/LuaEngine/GameObjectMethods.h b/src/server/LuaEngine/GameObjectMethods.h
new file mode 100644
index 0000000..138c23b
--- /dev/null
+++ b/src/server/LuaEngine/GameObjectMethods.h
@@ -0,0 +1,475 @@
+#ifndef GAMEOBJECTMETHODS_H
+#define GAMEOBJECTMETHODS_H
+
+class LuaGameObject
+{
+public:
+
+    // GetUnitType()
+    static int GetUnitType(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushString(L, "GameObject");
+        return 1;
+    }
+
+    // GetGUID()
+    static int GetGUID(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushGUID(L, go->GetGUID());
+        return 1;
+    }
+
+    // CastSpellOnTarget(target, spellid)
+    static int CastSpellOnTarget(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint32 spell = luaL_checkunsigned(L, 1);
+        Unit* target = Eluna::get()->CHECK_UNIT(L, 2);
+        if (target)
+            go->CastSpell(target, spell);
+        return 0;
+    }
+
+    // GetX()
+    static int GetX(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushFloat(L, go->GetPositionX());
+        return 1;
+    }
+
+    // GetY()
+    static int GetY(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushFloat(L, go->GetPositionY());
+        return 1;
+    }
+
+    // GetZ()
+    static int GetZ(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushFloat(L, go->GetPositionZ());
+        return 1;
+    }
+
+    // GetO()
+    static int GetO(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushFloat(L, go->GetOrientation());
+        return 1;
+    }
+
+    // GetLocation()
+    static int GetLocation(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushFloat(L, go->GetPositionX());
+        Eluna::get()->PushFloat(L, go->GetPositionY());
+        Eluna::get()->PushFloat(L, go->GetPositionZ());
+        Eluna::get()->PushFloat(L, go->GetOrientation());
+        return 4;
+    }
+
+    // GetMapId()
+    static int GetMapId(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushFloat(L, go->GetMapId());
+        return 1;
+    }
+
+    // GetZoneId()
+    static int GetZoneId(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushFloat(L, go->GetZoneId());
+        return 1;
+    }
+
+    // GetAreaId()
+    static int GetAreaId(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushFloat(L, go->GetAreaId());
+        return 1;
+    }
+
+    // GetName()
+    static int GetName(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushString(L, go->GetName().c_str());
+        return 1;
+    }
+
+    // GetEntry()
+    static int GetEntry(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, go->GetEntry());
+        return 1;
+    }
+
+    // SummonCreature(entry, x, y, z, o, despawntime)
+    static int SummonCreature(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint32 entry = luaL_checkunsigned(L, 1);
+        float x = luaL_checknumber(L, 2);
+        float y = luaL_checknumber(L, 3);
+        float z = luaL_checknumber(L, 4);
+        float o = luaL_checknumber(L, 5);
+        uint32 despawn = luaL_optunsigned(L, 6, 0);
+
+        TempSummonType summontype;
+        if (despawn)
+            summontype = TEMPSUMMON_TIMED_OR_DEAD_DESPAWN;
+        else
+            summontype = TEMPSUMMON_MANUAL_DESPAWN;
+        Eluna::get()->PushUnit(L, go->SummonCreature(entry, x, y, z, o, summontype, despawn));
+        return 1;
+    }
+
+    //SpawnGameObject(entry, x, y, z, o[, respawnDelay])
+    static int SummonGameObject(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+        
+        uint32 entry = luaL_checkunsigned(L, 1);
+        float x = luaL_checknumber(L, 2);
+        float y = luaL_checknumber(L, 3);
+        float z = luaL_checknumber(L, 4);
+        float o = luaL_checknumber(L, 5);
+        uint32 respawnDelay = luaL_optunsigned(L, 6, 30);
+        Eluna::get()->PushGO(L, go->SummonGameObject(entry, x, y, z, o, 0, 0, 0, 0, respawnDelay));
+        return 1;
+    }
+
+    //Despawn()
+    static int Despawn(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        go->RemoveFromWorld();
+        return 0;
+    }
+
+    // GetDisplayId()
+    static int GetDisplayId(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, go->GetDisplayId());
+        return 1;
+    }
+
+    // GetScale()
+    static int GetScale(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushFloat(L, go->GetObjectSize());
+        return 1;
+    }
+
+    // IsInWorld()
+    static int IsInWorld(lua_State* L, GameObject* go)
+    {
+        if (!go)
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, go->IsInWorld());
+        return 1;
+    }
+
+    // HasQuest(questId)
+    static int HasQuest(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+        {
+            uint32 questId = luaL_checkunsigned(L, 1);
+            Eluna::get()->PushBoolean(L, go->hasQuest(questId));
+        }
+        return 1;
+    }
+
+    // IsTransport()
+    static int IsTransport(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, go->IsTransport());
+        return 1;
+    }
+
+    // IsDestructible()
+    static int IsDestructible(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, go->IsDestructibleBuilding());
+        return 1;
+    }
+
+    // IsActive()
+    static int IsActive(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, go->isActiveObject());
+        return 1;
+    }
+
+    // Move(x, y, z, o)
+    static int Move(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        float X = luaL_checknumber(L, 1);
+        float Y = luaL_checknumber(L, 2);
+        float Z = luaL_checknumber(L, 3);
+        float O = luaL_checknumber(L, 4);
+        go->Relocate(X, Y, Z, O);
+        return 0;
+    }
+
+    // SetScale(scale)
+    static int SetScale(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        float scale = luaL_checknumber(L, 1);
+        go->SetObjectScale(scale);
+        return 0;
+    }
+
+    // RegisterEvent(function, delay, calls)
+    static int RegisterEvent(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint32 delay = luaL_checkunsigned(L, 2);
+        uint32 repeats = luaL_checkunsigned(L, 3);
+        Eluna::LuaGameObjectScript::LuaGameObjectAI* luaAI = sLuaGameObjectScript->GetAI(go);
+        if (!luaAI)
+        {
+            luaL_error(L, "GameObject has no registered gameobject events, please register one before using RegisterEvent");
+            return 0;
+        }
+        if (!strcmp(luaL_typename(L, 1), "function") || delay > 0)
+        {
+            lua_settop(L, 1);
+            int functionRef = lua_ref(L, true);
+            luaAI->LuaEventCreate(functionRef, delay, repeats);
+            Eluna::get()->PushInteger(L, functionRef);
+        }
+        else
+            return 0;
+        return 1;
+
+    }
+
+    // RemoveEventByID(eventID)
+    static int RemoveEventByID(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        int eventID = luaL_checkinteger(L, 1);
+        Eluna::LuaGameObjectScript::LuaGameObjectAI* luaAI = sLuaGameObjectScript->GetAI(go);
+        if (luaAI)
+            luaAI->LuaEventCancel(eventID);
+        return 0;
+    }
+
+    // RemoveEvents()
+    static int RemoveEvents(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        Eluna::LuaGameObjectScript::LuaGameObjectAI* luaAI = sLuaGameObjectScript->GetAI(go);
+        if (luaAI)
+            luaAI->LuaEventsReset();
+        return 0;
+    }
+
+    static int GetInt32Value(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushInteger(L, go->GetInt32Value(index));
+        return 1;
+    }
+
+    static int GetUInt32Value(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushUnsigned(L, go->GetUInt32Value(index));
+        return 1;
+    }
+
+    static int GetFloatValue(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushFloat(L, go->GetFloatValue(index));
+        return 1;
+    }
+
+    static int GetByteValue(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        Eluna::get()->PushUnsigned(L, go->GetByteValue(index, offset));
+        return 1;
+    }
+
+    static int GetUInt16Value(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        Eluna::get()->PushUnsigned(L, go->GetUInt16Value(index, offset));
+        return 1;
+    }
+
+    static int SetInt32Value(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        int32 value = luaL_checkinteger(L, 2);
+        go->SetInt32Value(index, value);
+        return 0;
+    }
+
+    static int SetUInt32Value(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint32 value = luaL_checkunsigned(L, 2);
+        go->SetUInt32Value(index, value);
+        return 0;
+    }
+
+    static int UpdateUInt32Value(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint32 value = luaL_checkunsigned(L, 2);
+        go->UpdateUInt32Value(index, value);
+        return 0;
+    }
+
+    static int SetFloatValue(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        float value = luaL_checknumber(L, 2);
+        go->SetFloatValue(index, value);
+        return 0;
+    }
+
+    static int SetByteValue(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        uint8 value = luaL_checkunsigned(L, 3);
+        go->SetByteValue(index, offset, value);
+        return 0;
+    }
+
+    static int SetUInt16Value(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        uint16 value = luaL_checkunsigned(L, 3);
+        go->SetUInt16Value(index, offset, value);
+        return 0;
+    }
+
+    static int SetInt16Value(lua_State* L, GameObject* go)
+    {
+        if (!go || !go->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        int16 value = luaL_checkinteger(L, 3);
+        go->SetInt16Value(index, offset, value);
+        return 0;
+    }
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/LuaEngine/GlobalMethods.h b/src/server/LuaEngine/GlobalMethods.h
new file mode 100644
index 0000000..0686496
--- /dev/null
+++ b/src/server/LuaEngine/GlobalMethods.h
@@ -0,0 +1,463 @@
+#ifndef __GLOBAL_METHODS_ELUNA
+#define __GLOBAL_METHODS_ELUNA
+
+namespace LuaGlobalFunctions
+{
+    // GetLuaEngine() - Gets lua engine name
+    static int GetLuaEngine(lua_State* L)
+    {
+        Eluna::get()->PushString(L, "Eluna Nova 0.1"); // remove version?
+        return 1;
+    }
+
+    // ReloadEluna() - Gets core version as string
+    static int GetCoreVersion(lua_State* L)
+    {
+        Eluna::get()->PushString(L, _FULLVERSION);
+        return 1;
+    }
+
+	// GetQuest(questId)
+	static int GetQuest(lua_State* L)
+	{
+		uint32 questId = luaL_checkunsigned(L, 1);
+		if (!questId)
+			return 0;
+
+		Eluna::get()->PushQuest(L, sObjectMgr->GetQuestTemplate(questId));
+		return 1;
+	}
+
+    // ReloadEluna() - Reloads eluna
+    static int ReloadEluna(lua_State* L)
+    {
+        Eluna::get()->Restart();
+        return 0;
+    }
+
+    // GetPlayerByGUID(guid) - Gets Player object by its guid
+    static int GetPlayerByGUID(lua_State* L)
+    {
+        uint32 guidLow = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushUnit(L, sObjectAccessor->FindPlayer(MAKE_NEW_GUID(guidLow, 0, HIGHGUID_PLAYER)));
+        return 1;
+    }
+
+    // GetPlayerByName("name") - Gets player object by name
+    static int GetPlayerByName(lua_State* L)
+    {
+        const char* message = luaL_checkstring(L, 1);
+        Eluna::get()->PushUnit(L, sObjectAccessor->FindPlayerByName(message));
+        return 1;
+    }
+
+    // GetGameTime() - Gets ingame time as seconds (server time?)
+    static int GetGameTime(lua_State* L)
+    {
+        Eluna::get()->PushUnsigned(L, sWorld->GetGameTime());
+        return 1;
+    }
+
+    // SendWorldMessage("msg") - Sends a broadcast message to everyone
+    static int SendWorldMessage(lua_State* L)
+    {
+        const char* message = luaL_checkstring(L, 1);
+        sWorld->SendServerMessage(SERVER_MSG_STRING, message);
+        return 0;
+    }
+
+    // GetPlayersInWorld([team, onlyGM]) - Gets a table with players in world. Team can be 0 for ally, 1 for horde and 2 for both.
+    static int GetPlayersInWorld(lua_State* L)
+    {
+        uint32 team = luaL_optunsigned(L, 1, TEAM_NEUTRAL);
+        bool onlyGM = luaL_optbool(L, 2, false);
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        SessionMap const& sessions = sWorld->GetAllSessions();
+        for (SessionMap::const_iterator it = sessions.begin(); it != sessions.end(); ++it)
+        {
+            if (Player* player = it->second->GetPlayer())
+            {
+                if (player->GetSession() && ((team >= TEAM_NEUTRAL || player->GetTeamId() == team) && (!onlyGM || player->isGameMaster())))
+                {
+                    ++i;
+                    Eluna::get()->PushUnsigned(L, i);
+                    Eluna::get()->PushUnit(L, player);
+                    lua_settable(L, tbl);
+                }
+            }
+        }
+
+        lua_settop(L, tbl); // push table to top of stack
+        return 1;
+    }
+
+    // GetPlayersInMap(mapid[, instanceid, team]) - Gets a table with players in the map. Instanceid optional (0 for normal map). Team can be 0 for ally, 1 for horde and 2 for both
+    static int GetPlayersInMap(lua_State* L)
+    {
+        uint32 mapID = luaL_checkunsigned(L, 1);
+        uint32 instanceID = luaL_optunsigned(L, 2, 0);
+        uint32 team = luaL_optunsigned(L, 3, TEAM_NEUTRAL);
+
+        Map* map = sMapMgr->FindMap(mapID, instanceID);
+        if (!map)
+            return 0;
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        Map::PlayerList const& players = map->GetPlayers();
+        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+        {
+            Player* player = itr->getSource();
+            if (!player)
+                continue;
+            if (player->GetSession() && (team >= TEAM_NEUTRAL || player->GetTeamId() == team))
+            {
+                ++i;
+                Eluna::get()->PushUnsigned(L, i);
+                Eluna::get()->PushUnit(L, player);
+                lua_settable(L, tbl);
+            }
+        }
+
+        lua_settop(L, tbl);
+        return 1;
+    }
+
+    // WorldDBQuery("sql") - Executes SQL to world database and returns the query Result or nil (instant)
+    static int WorldDBQuery(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        QueryResult Result = WorldDatabase.Query(query);
+        if (!Result)
+            return 0;
+
+        Eluna::get()->PushQueryResult(L, new QueryResult(Result));
+        return 1;
+    }
+
+    // WorldDBExecute("sql") - Executes SQL to world database (not instant)
+    static int WorldDBExecute(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        WorldDatabase.Execute(query);
+        return 0;
+    }
+
+    // CharDBQuery("sql") - Executes SQL to characters database and returns the query Result or nil (instant)
+    static int CharDBQuery(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        QueryResult Result = CharacterDatabase.Query(query);
+        if (!Result)
+            return 0;
+
+        Eluna::get()->PushQueryResult(L, new QueryResult(Result));
+        return 1;
+    }
+
+    // CharDBExecute("sql") - Executes SQL to characters database (not instant)
+    static int CharDBExecute(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        CharacterDatabase.Execute(query);
+        return 0;
+    }
+
+    // AuthDBQuery("sql") - Executes SQL to auth database and returns the query Result or nil (instant)
+    static int AuthDBQuery(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        QueryResult Result = LoginDatabase.Query(query);
+        if (!Result)
+            return 0;
+
+        Eluna::get()->PushQueryResult(L, new QueryResult(Result));
+        return 1;
+    }
+
+    // AuthDBExecute("sql") - Executes SQL to auth database (not instant)
+    static int AuthDBExecute(lua_State* L)
+    {
+        const char* query = luaL_checkstring(L, 1);
+        if (!query)
+            return 0;
+
+        LoginDatabase.Execute(query);
+        return 0;
+    }
+
+    // GetGuildByName("name") - Gets guild object
+    static int GetGuildByName(lua_State* L)
+    {
+        const char* name = luaL_checkstring(L, 1);
+        Eluna::get()->PushGuild(L, sGuildMgr->GetGuildByName(name));
+        return 1;
+    }
+
+    // GetGuildByLeaderGUID(leaderGUID) - Gets guild object
+    static int GetGuildByLeaderGUID(lua_State* L)
+    {
+        uint32 guidLow = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushGuild(L, sGuildMgr->GetGuildByLeader(MAKE_NEW_GUID(guidLow, 0, HIGHGUID_PLAYER)));
+        return 1;
+    }
+
+    // GetPlayerCount() - Gets server player count
+    static int GetPlayerCount(lua_State* L)
+    {
+        Eluna::get()->PushUnsigned(L, sWorld->GetPlayerCount());
+        return 1;
+    }
+
+    // CreateLuaEvent(function, delay, calls) - Creates a timed event. Calls set to 0 will call inf returns eventID.
+    static int CreateLuaEvent(lua_State* L)
+    {
+        uint32 delay = luaL_checkunsigned(L, 2);
+        uint32 repeats = luaL_checkunsigned(L, 3);
+        if (!strcmp(luaL_typename(L, 1), "function") || delay > 0)
+        {
+            lua_settop(L, 1);
+            int functionRef = lua_ref(L, true);
+            sLuaWorldScript->LuaEventCreate(functionRef, delay, repeats);
+            Eluna::get()->PushInteger(L, functionRef);
+        }
+        else
+            return 0;
+        return 1;
+    }
+
+    // DestroyLuaEventByID(eventID) - removes all global lua events with eventid
+    static int DestroyLuaEventByID(lua_State* L)
+    {
+        int functionRef = luaL_checkinteger(L, 1);
+        sLuaWorldScript->LuaEventCancel(functionRef);
+        return 0;
+    }
+
+    // DestroyLuaEvents(all_events) - removes all global lua events, if all_events is true, removes creature and gameobject events too
+    static int DestroyLuaEvents(lua_State* L)
+    {
+        bool all_Events = luaL_optbool(L, 1, false);
+
+        if (all_Events)
+            Eluna::LuaEventMap::LuaEventsResetAll();
+        else
+            sLuaWorldScript->LuaEventsReset();
+        return 0;
+    }
+
+    // PerformIngameSpawn(spawntype, entry, mapid, x, y, z, o[, save, DurOrResptime, phase])
+    // spawntype: 1 Creature, 2 Object. DurOrResptime is respawntime for gameobjects and despawntime for creatures if creature is not saved
+    static int PerformIngameSpawn(lua_State* L)
+    {
+        int spawntype = luaL_checkinteger(L, 1);
+        uint32 entry = luaL_checkunsigned(L, 2);
+        uint32 mapID = luaL_checkunsigned(L, 3);
+        float x = luaL_checknumber(L, 4);
+        float y = luaL_checknumber(L, 5);
+        float z = luaL_checknumber(L, 6);
+        float o = luaL_checknumber(L, 7);
+        bool save = luaL_optbool(L, 8, false);
+        uint32 durorresptime = luaL_optunsigned(L, 9, 0);
+        uint32 phase = luaL_optunsigned(L, 10, PHASEMASK_NORMAL);
+        if (!phase)
+            return 0;
+
+        Map* map = sMapMgr->FindMap(mapID, 0);
+        if (!map)
+            return 0;
+
+        Position pos = {x,y,z,o};
+
+        if (spawntype == 1) // spawn creature
+        {
+            if (save)
+            {
+                Creature* creature = new Creature();
+                if (!creature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), map, phase, entry, 0, 0, x, y, z, o))
+                {
+                    delete creature;
+                    return 0;
+                }
+
+                creature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), phase);
+
+                uint32 db_guid = creature->GetDBTableGUIDLow();
+                if (!creature->LoadCreatureFromDB(db_guid, map))
+                {
+                    delete creature;
+                    return 0;
+                }
+
+                sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
+                Eluna::get()->PushUnit(L, creature);
+            }
+            else
+            {
+                TempSummon* creature = map->SummonCreature(entry, pos, NULL, durorresptime);
+                if (!creature)
+                    return 0;
+
+                if (durorresptime)
+                    creature->SetTempSummonType(TEMPSUMMON_TIMED_OR_DEAD_DESPAWN);
+                else
+                    creature->SetTempSummonType(TEMPSUMMON_MANUAL_DESPAWN);
+
+                Eluna::get()->PushUnit(L, creature);
+            }
+
+            return 1;
+        }
+
+        if (spawntype == 2) // Spawn object
+        {
+
+            const GameObjectTemplate* objectInfo = sObjectMgr->GetGameObjectTemplate(entry);
+            if (!objectInfo)
+                return 0;
+
+            if (objectInfo->displayId && !sGameObjectDisplayInfoStore.LookupEntry(objectInfo->displayId))
+                return 0;
+
+            GameObject* object = new GameObject;
+            uint32 guidLow = sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+
+            if (!object->Create(guidLow, objectInfo->entry, map, phase, x, y, z, o, 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
+            {
+                delete object;
+                return 0;
+            }
+
+            if (durorresptime)
+                object->SetRespawnTime(durorresptime);
+
+            if (save)
+            {
+                // fill the gameobject data and save to the db
+                object->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), phase);
+
+                // this will generate a new guid if the object is in an instance
+                if (!object->LoadGameObjectFromDB(guidLow, map))
+                {
+                    delete object;
+                    return false;
+                }
+
+                sObjectMgr->AddGameobjectToGrid(guidLow, sObjectMgr->GetGOData(guidLow));
+            }
+            else
+                map->AddToMap(object);
+            Eluna::get()->PushGO(L, object);
+            return 1;
+        }
+
+        return 0;
+    }
+
+    // CreatePacket(opcode, size)
+    static int CreatePacket(lua_State* L)
+    {
+        uint16 opcode = luaL_checkunsigned(L, 1);
+        size_t size = luaL_checkunsigned(L, 2);
+
+        if (opcode >= NUM_MSG_TYPES)
+            luaL_error(L, "Eluna Nova:: Opcode %d is greater than the max Opcode type (%d)!", opcode, NUM_MSG_TYPES);
+        else
+        {
+            WorldPacket* _packet = new WorldPacket(opcode, size);
+            Eluna::get()->PushPacket(L, _packet);
+            return 1;
+        }
+        return 0;
+    }
+
+	// AddVendorItem(entry, itemId, maxcount, incrtime, extendedcost, persist(bool))
+	static int AddVendorItem(lua_State* L)
+	{
+		uint32 entry = luaL_checkunsigned(L, 1);
+		uint32 item = luaL_checkunsigned(L, 2);
+		int maxcount = luaL_checkinteger(L, 3);
+		uint32 incrtime = luaL_checkunsigned(L, 4);
+		uint32 extendedcost = luaL_checkunsigned(L, 5);
+		bool persist = luaL_optbool(L, 6, true);
+		if (!sObjectMgr->GetCreatureTemplate(entry))
+		{
+			sLog->outError(LOG_FILTER_GENERAL, "Eluna Nova::Couldn't find a creature with (ID: %d)!", entry);
+			return 0;
+		}
+
+		if (!sObjectMgr->IsVendorItemValid(entry, item, maxcount, incrtime, extendedcost))
+			return 0;
+		sObjectMgr->AddVendorItem(entry, item, maxcount, incrtime, extendedcost, persist);
+		return 0;
+	}
+
+	// VendorRemoveItem(entry, item, persist(bool), otherNpcFlag(optional-uint))
+	static int VendorRemoveItem(lua_State* L)
+	{
+		uint32 entry = luaL_checkunsigned(L, 1);
+		uint32 item = luaL_checkunsigned(L, 2);
+		bool persist = luaL_optbool(L, 3, true);
+		uint32 otherFlag = luaL_optunsigned(L, 4, UNIT_NPC_FLAG_VENDOR+1);
+		if (!sObjectMgr->GetCreatureTemplate(entry))
+		{
+			sLog->outError(LOG_FILTER_GENERAL, "Eluna Nova::Couldn't find a creature with (ID: %d)!", entry);
+			return 0;
+		}
+
+		CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(entry);
+		if (!((cInfo->npcflag | otherFlag) & UNIT_NPC_FLAG_VENDOR))
+			return 0;
+
+		if (!sObjectMgr->RemoveVendorItem(entry, item, persist))
+			return 0;
+		return 0;
+	}
+
+	// VendorRemoveAllItems(creature, persist(bool))
+	static int VendorRemoveAllItems(lua_State* L)
+	{
+		Creature* creature = Eluna::get()->CHECK_CREATURE(L, 1);
+		bool persist = luaL_optbool(L, 2, true);
+		if (!creature || !creature->IsInWorld())
+			return 0;
+
+		VendorItemData const* items = creature->GetVendorItems();
+		if (!items || items->Empty())
+			return 0;
+
+		uint32 vendorItems[200];
+		uint32 i = 0;
+		for (VendorItemList::const_iterator itr = items->m_items.begin(); itr != items->m_items.end(); ++itr)
+		{
+			vendorItems[i] = (*itr)->item;
+			i++;
+		}
+
+		for (i = 0; i < items->GetItemCount(); i++)
+			sObjectMgr->RemoveVendorItem(creature->GetEntry(), vendorItems[i], persist);
+		return 0;
+	}
+}
+#endif
\ No newline at end of file
diff --git a/src/server/LuaEngine/GroupMethods.h b/src/server/LuaEngine/GroupMethods.h
new file mode 100644
index 0000000..836b32e
--- /dev/null
+++ b/src/server/LuaEngine/GroupMethods.h
@@ -0,0 +1,332 @@
+#ifndef GROUPMETHODS_H
+#define GROUPMETHODS_H
+
+class LuaGroup
+{
+public:
+
+    static int GetMembers(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        for (GroupReference* itr = group->GetFirstMember(); itr; itr = itr->next())
+        {
+            Player* member = itr->getSource();
+
+            if (!member || !member->GetSession())
+                continue;
+
+            ++i;
+            Eluna::get()->PushUnsigned(L, i);
+            Eluna::get()->PushUnit(L, member);
+            lua_settable(L, tbl);
+        }
+
+        lua_settop(L, tbl); // push table to top of stack
+        return 1;
+    }
+
+    static int GetLeaderGUID(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        Eluna::get()->PushGUID(L, group->GetLeaderGUID());
+        return 1;
+    }
+
+    static int GetLeader(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        Eluna::get()->PushUnit(L, sObjectAccessor->FindPlayer(group->GetLeaderGUID()));
+        return 1;
+    }
+
+    static int GetUnitType(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        Eluna::get()->PushString(L, "Group");
+        return 1;
+    }
+
+    static int GetGUID(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        Eluna::get()->PushGUID(L, group->GetGUID());
+        return 1;
+    }
+
+    static int ChangeLeader(lua_State* L, Group* group)
+    {
+        if (!group)
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* leader = Eluna::get()->CHECK_PLAYER(L, 1);
+        if (leader)
+        {
+            group->ChangeLeader(leader->GetGUID());
+            Eluna::get()->PushBoolean(L, true);
+        }
+        else
+            Eluna::get()->PushBoolean(L, false);
+        return 1;
+    }
+
+    static int IsLeader(lua_State* L, Group* group)
+    {
+        if (!group)
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+        if (!player)
+            if (const char* name = luaL_checkstring(L, 1))
+                player = sObjectAccessor->FindPlayerByName(name);
+
+        if (player)
+            Eluna::get()->PushBoolean(L, group->IsLeader(player->GetGUID()));
+        else
+            Eluna::get()->PushBoolean(L, false);
+        return 1;
+    }
+
+    // SendPacket(packet, sendToPlayersInBattleground[, ignoreguid])
+    static int SendPacket(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        WorldPacket* data = Eluna::get()->CHECK_PACKET(L, 1);
+        bool ignorePlayersInBg = luaL_checkbool(L, 2);
+        uint32 ignore = luaL_optunsigned(L, 3, 0);
+
+        if (data)
+            group->BroadcastPacket(data, ignorePlayersInBg, -1, (ignore ? MAKE_NEW_GUID(ignore, 0, HIGHGUID_PLAYER) : 0));
+        return 0;
+    }
+
+    static int AddInvite(lua_State* L, Group* group)
+    {
+        if (!group)
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+        if (player)
+            Eluna::get()->PushBoolean(L, group->AddInvite(player));
+        else
+            Eluna::get()->PushBoolean(L, false);
+        return 1;
+    }
+
+    static int RemoveMember(lua_State* L, Group* group)
+    {
+        if (!group)
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+        if (player)
+            Eluna::get()->PushBoolean(L, group->RemoveMember(player->GetGUID()));
+        else
+            Eluna::get()->PushBoolean(L, false);
+        return 1;
+    }
+
+    static int Disband(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        group->Disband();
+        return 0;
+    }
+
+    static int IsFull(lua_State* L, Group* group)
+    {
+        if (!group)
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, group->IsFull());
+        return 1;
+    }
+
+    static int isLFGGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, group->isLFGGroup());
+        return 1;
+    }
+
+    static int isRaidGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, group->isRaidGroup());
+        return 1;
+    }
+
+    static int isBGGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, group->isBGGroup());
+        return 1;
+    }
+
+    static int isBFGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, group->isBFGroup());
+        return 1;
+    }
+
+    static int IsMember(lua_State* L, Group* group)
+    {
+        if (!group)
+            Eluna::get()->PushBoolean(L, false);
+        else
+        {
+            Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+            if (player)
+                Eluna::get()->PushBoolean(L, group->IsMember(player->GetGUID()));
+            else
+                Eluna::get()->PushBoolean(L, false);
+        }
+        return 1;
+    }
+
+    static int IsAssistant(lua_State* L, Group* group)
+    {
+        if (!group)
+            Eluna::get()->PushBoolean(L, false);
+        else
+        {
+            Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+            if (player)
+                Eluna::get()->PushBoolean(L, group->IsAssistant(player->GetGUID()));
+            else
+                Eluna::get()->PushBoolean(L, false);
+        }
+        return 1;
+    }
+
+    static int SameSubGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            Eluna::get()->PushBoolean(L, false);
+        else
+        {
+            Player* player1 = Eluna::get()->CHECK_PLAYER(L, 1);
+            Player* player2 = Eluna::get()->CHECK_PLAYER(L, 2);
+            if (player1 && player2)
+                Eluna::get()->PushBoolean(L, group->SameSubGroup(player1, player2));
+            else
+                Eluna::get()->PushBoolean(L, false);
+        }
+        return 1;
+    }
+
+    static int HasFreeSlotSubGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            Eluna::get()->PushBoolean(L, false);
+        else
+        {
+            uint8 subGroup = luaL_checkunsigned(L, 1);
+            Eluna::get()->PushBoolean(L, group->HasFreeSlotSubGroup(subGroup));
+        }
+        return 1;
+    }
+
+    static int GetMemberGUID(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        const char* name = luaL_checkstring(L, 1);
+        Eluna::get()->PushGUID(L, group->GetMemberGUID(name));
+        return 1;
+    }
+
+    static int GetMembersCount(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, group->GetMembersCount());
+        return 1;
+    }
+
+    static int ConvertToLFG(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        group->ConvertToLFG();
+        return 0;
+    }
+
+    static int ConvertToRaid(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        group->ConvertToRaid();
+        return 0;
+    }
+
+    static int ChangeMembersGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+        uint8 groupID = luaL_checkunsigned(L, 2);
+
+        if (player)
+            group->ChangeMembersGroup(player->GetGUID(), groupID);
+        return 0;
+    }
+
+    static int GetMemberGroup(lua_State* L, Group* group)
+    {
+        if (!group)
+            return 0;
+
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+        if (!player)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, group->GetMemberGroup(player->GetGUID()));
+        return 1;
+    }
+
+};
+#endif
diff --git a/src/server/LuaEngine/GuildMethods.h b/src/server/LuaEngine/GuildMethods.h
new file mode 100644
index 0000000..0599401
--- /dev/null
+++ b/src/server/LuaEngine/GuildMethods.h
@@ -0,0 +1,178 @@
+#ifndef GUILDMETHODS_H
+#define GUILDMETHODS_H
+
+class LuaGuild
+{
+public:
+
+    static int GetMembers(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        // Note that the following is very hacky, I don't like it and it SHOULD be changed ASAP.
+
+        TRINITY_READ_GUARD(HashMapHolder<Player>::LockType, *HashMapHolder<Player>::GetLock());
+        HashMapHolder<Player>::MapType const& m = sObjectAccessor->GetPlayers();
+        for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+        {
+            if (itr->second->GetGuildId() == guild->GetId())
+            {
+                ++i;
+                Eluna::get()->PushUnsigned(L, i);
+                Eluna::get()->PushUnit(L, itr->second);
+                lua_settable(L, tbl);
+            }
+        }
+
+        lua_settop(L, tbl); // push table to top of stack
+        return 1;
+    }
+
+    static int GetUnitType(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Eluna::get()->PushString(L, "Guild");
+        return 1;
+    }
+
+    static int GetLeaderGUID(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Eluna::get()->PushGUID(L, guild->GetLeaderGUID());
+        return 1;
+    }
+
+    // SendPacketToGuild(packet)
+    static int SendPacket(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        WorldPacket* data = Eluna::get()->CHECK_PACKET(L, 1);
+
+        if (data)
+            guild->BroadcastPacket(data);
+        return 0;
+    }
+
+    // SendPacketToRankedInGuild(packet, rankId)
+    static int SendPacketToRanked(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        WorldPacket* data = Eluna::get()->CHECK_PACKET(L, 1);
+        uint8 ranked = luaL_checkunsigned(L, 2);
+
+        if (data)
+            guild->BroadcastPacketToRank(data, ranked);
+        return 0;
+    }
+
+    static int Disband(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        guild->Disband();
+        return 0;
+    }
+
+    static int GetId(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, guild->GetId());
+        return 1;
+    }
+
+    static int GetName(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Eluna::get()->PushString(L, guild->GetName().c_str());
+        return 1;
+    }
+
+    static int GetMOTD(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Eluna::get()->PushString(L, guild->GetMOTD().c_str());
+        return 1;
+    }
+
+    static int GetInfo(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Eluna::get()->PushString(L, guild->GetInfo().c_str());
+        return 1;
+    }
+
+    static int AddMember(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+        uint8 rankId = luaL_optint(L, 2, GUILD_RANK_NONE);
+
+        if (player)
+            guild->AddMember(player->GetGUID(), rankId);
+        return 0;
+    }
+
+    static int DeleteMember(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+        bool isDisbanding = luaL_optbool(L, 2, false);
+        bool isKicked = luaL_optbool(L, 3, false);
+
+        if (player)
+            guild->DeleteMember(player->GetGUID(), isDisbanding, isKicked);
+        return 0;
+    }
+
+    static int ChangeMemberRank(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+        uint8 newRank = luaL_checkunsigned(L, 2);
+
+        if (player)
+            guild->ChangeMemberRank(player->GetGUID(), newRank);
+        return 0;
+    }
+
+    static int SetBankTabText(lua_State* L, Guild* guild)
+    {
+        if (!guild)
+            return 0;
+
+        uint8 tabId = luaL_checkunsigned(L, 1);
+        const char* text = luaL_checkstring(L, 2);
+
+        guild->SetBankTabText(tabId, text);
+        return 0;
+    }
+};
+#endif
diff --git a/src/server/LuaEngine/ItemMethods.h b/src/server/LuaEngine/ItemMethods.h
new file mode 100644
index 0000000..5639c35
--- /dev/null
+++ b/src/server/LuaEngine/ItemMethods.h
@@ -0,0 +1,495 @@
+#ifndef ITEMMETHODS_H
+#define ITEMMETHODS_H
+
+class LuaItem
+{
+public:
+
+    static int GetUnitType(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushString(L, "Item");
+        return 1;
+    }
+
+    static int GetGUID(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushGUID(L, item->GetGUID());
+        return 1;
+    }
+
+    static int GetOwnerGUID(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushGUID(L, item->GetOwnerGUID());
+        return 1;
+    }
+
+    static int GetOwner(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushUnit(L, item->GetOwner());
+        return 1;
+    }
+
+    static int SetOwner(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+
+        if (player)
+            item->SetOwnerGUID(player->GetGUID());
+        return 0;
+    }
+
+    static int SetBinding(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        bool soulbound = luaL_checkbool(L, 1);
+
+        item->SetBinding(soulbound);
+        return 0;
+    }
+
+    static int IsSoulBound(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsSoulBound());
+        return 1;
+    }
+
+    static int IsBoundAccountWide(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsBoundAccountWide());
+        return 1;
+    }
+
+    static int IsBoundByEnchant(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsBoundByEnchant());
+        return 1;
+    }
+
+    static int IsBindedNotWith(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+        {
+            Player* player = Eluna::get()->CHECK_PLAYER(L, 1);
+            if (player)
+                Eluna::get()->PushBoolean(L, item->IsBindedNotWith(player));
+            else
+                Eluna::get()->PushBoolean(L, false);
+        }
+        return 1;
+    }
+
+    static int IsLocked(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsLocked());
+        return 1;
+    }
+
+    static int IsBag(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsBag());
+        return 1;
+    }
+
+    static int IsCurrencyToken(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsCurrencyToken());
+        return 1;
+    }
+
+    static int IsNotEmptyBag(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsNotEmptyBag());
+        return 1;
+    }
+
+    static int IsBroken(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsBroken());
+        return 1;
+    }
+
+    static int CanBeTraded(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+        {
+            bool mail = luaL_optbool(L, 1, false);
+            bool trade = luaL_optbool(L, 2, false);
+            Eluna::get()->PushBoolean(L, item->CanBeTraded(mail, trade));
+        }
+        return 1;
+    }
+
+    static int IsInTrade(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsInTrade());
+        return 1;
+    }
+
+    static int GetCount(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, item->GetCount());
+        return 1;
+    }
+
+    static int SetCount(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint32 count = luaL_checkunsigned(L, 1);
+        item->SetCount(count);
+        return 0;
+    }
+
+    static int GetMaxStackCount(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, item->GetMaxStackCount());
+        return 1;
+    }
+
+    static int GetSlot(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, item->GetSlot());
+        return 1;
+    }
+
+    static int GetBagSlot(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, item->GetBagSlot());
+        return 1;
+    }
+
+    static int IsInBag(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsInBag());
+        return 1;
+    }
+
+    static int IsEquipped(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsEquipped());
+        return 1;
+    }
+
+    static int hasQuest(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+        {
+            uint32 quest = luaL_checkunsigned(L, 1);
+            Eluna::get()->PushBoolean(L, item->hasQuest(quest));
+        }
+        return 1;
+    }
+
+    static int IsPotion(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsPotion());
+        return 1;
+    }
+
+    static int IsWeaponVellum(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsWeaponVellum());
+        return 1;
+    }
+
+    static int IsArmorVellum(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsArmorVellum());
+        return 1;
+    }
+
+    static int IsConjuredConsumable(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsConjuredConsumable());
+        return 1;
+    }
+
+    static int IsRefundExpired(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, item->IsRefundExpired());
+        return 1;
+    }
+
+    static int GetEntry(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, item->GetEntry());
+        return 1;
+    }
+
+    static int GetInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushInteger(L, item->GetInt32Value(index));
+        return 1;
+    }
+
+    static int GetUInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushUnsigned(L, item->GetUInt32Value(index));
+        return 1;
+    }
+
+    static int GetFloatValue(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushFloat(L, item->GetFloatValue(index));
+        return 1;
+    }
+
+    static int GetByteValue(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        Eluna::get()->PushUnsigned(L, item->GetByteValue(index, offset));
+        return 1;
+    }
+
+    static int GetUInt16Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        Eluna::get()->PushUnsigned(L, item->GetUInt16Value(index, offset));
+        return 1;
+    }
+
+    static int SetInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        int32 value = luaL_checkinteger(L, 2);
+        item->SetInt32Value(index, value);
+        return 0;
+    }
+
+    static int SetUInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint32 value = luaL_checkunsigned(L, 2);
+        item->SetUInt32Value(index, value);
+        return 0;
+    }
+
+    static int UpdateUInt32Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint32 value = luaL_checkunsigned(L, 2);
+        item->UpdateUInt32Value(index, value);
+        return 0;
+    }
+
+    static int SetFloatValue(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        float value = luaL_checknumber(L, 2);
+        item->SetFloatValue(index, value);
+        return 0;
+    }
+
+    static int SetByteValue(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        uint8 value = luaL_checkunsigned(L, 3);
+        item->SetByteValue(index, offset, value);
+        return 0;
+    }
+
+    static int SetUInt16Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        uint16 value = luaL_checkunsigned(L, 3);
+        item->SetUInt16Value(index, offset, value);
+        return 0;
+    }
+
+    static int SetInt16Value(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+            return 0;
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        int16 value = luaL_checkinteger(L, 3);
+        item->SetInt16Value(index, offset, value);
+        return 0;
+    }
+
+    static int SetEnchantment(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* owner = item->GetOwner();
+        if (!owner)
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        uint32 enchant = luaL_checkunsigned(L, 1);
+        if (!sSpellItemEnchantmentStore.LookupEntry(enchant))
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        owner->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+        item->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchant, 0, 0);
+        owner->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, true);
+        Eluna::get()->PushBoolean(L, true);
+        return 1;
+    }
+
+    static int ClearEnchantment(lua_State* L, Item* item)
+    {
+        if (!item || !item->IsInWorld())
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        Player* owner = item->GetOwner();
+        if (!owner)
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        if (!item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT))
+        {
+            Eluna::get()->PushBoolean(L, false);
+            return 1;
+        }
+
+        owner->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+        item->ClearEnchantment(PERM_ENCHANTMENT_SLOT);
+        Eluna::get()->PushBoolean(L, true);
+        return 1;
+    }
+
+};
+#endif
diff --git a/src/server/LuaEngine/LuaEngine.cpp b/src/server/LuaEngine/LuaEngine.cpp
new file mode 100644
index 0000000..0f59a7d
--- /dev/null
+++ b/src/server/LuaEngine/LuaEngine.cpp
@@ -0,0 +1,669 @@
+#include "LuaEngine.h"
+Eluna::LuaWorldScript* sLuaWorldScript = NULL;
+#include "GlobalMethods.h"
+#include "UnitMethods.h"
+#include "GroupMethods.h"
+#include "GuildMethods.h"
+#include "GameObjectMethods.h"
+#include "QueryMethods.h"
+#include "AuraMethods.h"
+#include "ItemMethods.h"
+#include "WorldPacketMethods.h"
+#include "SpellMethods.h"
+#include "QuestMethods.h"
+#include "LuaFunctions.h"
+
+#if PLATFORM == PLATFORM_UNIX
+#include <dirent.h>
+#endif
+
+Eluna* Eluna::LuaEngine = NULL; // give it a value
+ElunaScript* Eluna::Script = NULL;
+
+void Eluna::Init()
+{
+    if (LuaEngine)
+        return;
+
+    LuaEngine = new Eluna;
+    Script = new ElunaScript;
+    sLuaWorldScript = new LuaWorldScript;
+    get()->StartEluna();
+}
+
+template<typename T> const char* GetTName() { return "UNK"; }
+template<> const char* GetTName<Unit>() { return "Unit"; }
+template<> const char* GetTName<GameObject>() { return "GameObject"; }
+template<> const char* GetTName<Group>() { return "Group"; }
+template<> const char* GetTName<Guild>() { return "Guild"; }
+template<> const char* GetTName<Log>() { return "Log"; }
+template<> const char* GetTName<QueryResult>() { return "QueryResult"; }
+template<> const char* GetTName<Aura>() { return "Aura"; }
+template<> const char* GetTName<WorldPacket>() { return "WorldPacket"; }
+template<> const char* GetTName<Item>() { return "Item"; }
+template<> const char* GetTName<Spell>() { return "Spell"; }
+template<> const char* GetTName<Quest>() { return "Quest"; }
+
+void Eluna::StartEluna()
+{
+    LuaState = luaL_newstate();
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Eluna Nova Lua Engine loaded.");
+
+    LoadedScripts loadedScripts;
+    LoadDirectory("scripts", &loadedScripts);
+    luaL_openlibs(LuaState);
+    //Register Globals Here
+    RegisterGlobals(LuaState);
+    //Register Templates Here
+    ElunaTemplate<Unit>::Register(LuaState);
+    ElunaTemplate<GameObject>::Register(LuaState);
+    ElunaTemplate<Group>::Register(LuaState);
+    ElunaTemplate<Guild>::Register(LuaState);
+    ElunaTemplate<QueryResult>::Register(LuaState);
+    ElunaTemplate<Aura>::Register(LuaState);
+    ElunaTemplate<WorldPacket>::Register(LuaState);
+    ElunaTemplate<Item>::Register(LuaState);
+    ElunaTemplate<Spell>::Register(LuaState);
+    ElunaTemplate<Quest>::Register(LuaState);
+
+    uint32 count = 0;
+    char filename[200];
+    for (std::set<std::string>::iterator itr = loadedScripts.luaFiles.begin(); itr !=  loadedScripts.luaFiles.end(); ++itr)
+    {
+        strcpy(filename, itr->c_str());
+        if (luaL_loadfile(LuaState, filename) != 0)
+        {
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "Eluna Nova::Error loading `%s`.", itr->c_str());
+            report(LuaState);
+        }
+        else
+        {
+            int err = lua_pcall(LuaState, 0, 0, 0);
+            if (err != 0 && err == LUA_ERRRUN)
+            {
+                sLog->outError(LOG_FILTER_SERVER_LOADING, "Eluna Nova::Error loading `%s`.", itr->c_str());
+                report(LuaState);
+            }
+        }
+        ++count;
+    }
+    sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Eluna Nova::Loaded %u Lua scripts", count);
+}
+
+/* Register Other Hooks (Events) */
+static int RegisterServerHook(lua_State* L);
+static int RegisterCreatureGossipEvent(lua_State* L);
+static int RegisterCreatureEvent(lua_State* L);
+static int RegisterGameObjectEvent(lua_State* L);
+static int RegisterGameObjectGossipEvent(lua_State* L);
+static int RegisterItemEvent(lua_State* L);
+static int RegisterItemGossipEvent(lua_State* L);
+static int RegisterPlayerGossipEvent(lua_State* L);
+
+void Eluna::RegisterGlobals(lua_State* L)
+{
+    lua_register(L, "RegisterServerHook", RegisterServerHook);
+    lua_register(L, "RegisterCreatureEvent", RegisterCreatureEvent);
+    lua_register(L, "RegisterCreatureGossipEvent", RegisterCreatureGossipEvent);
+    lua_register(L, "RegisterGameObjectEvent", RegisterGameObjectEvent);
+    lua_register(L, "RegisterGameObjectGossipEvent", RegisterGameObjectGossipEvent);
+    lua_register(L, "RegisterItemEvent", RegisterItemEvent);
+    lua_register(L, "RegisterItemGossipEvent", RegisterItemGossipEvent);
+    lua_register(L, "RegisterPlayerGossipEvent", RegisterPlayerGossipEvent);
+
+    lua_register(L, "GetLuaEngine", &LuaGlobalFunctions::GetLuaEngine);
+    lua_register(L, "GetLUAEngine", &LuaGlobalFunctions::GetLuaEngine);
+    lua_register(L, "GetCoreVersion", &LuaGlobalFunctions::GetCoreVersion);
+    lua_register(L, "GetQuest", &LuaGlobalFunctions::GetQuest);
+    lua_register(L, "ReloadEluna", &LuaGlobalFunctions::ReloadEluna);
+    lua_register(L, "GetPlayerByGUID", &LuaGlobalFunctions::GetPlayerByGUID);
+    lua_register(L, "GetPlayerByName", &LuaGlobalFunctions::GetPlayerByName);
+    lua_register(L, "GetGameTime", &LuaGlobalFunctions::GetGameTime);
+    lua_register(L, "SendWorldMessage", &LuaGlobalFunctions::SendWorldMessage);
+    lua_register(L, "GetPlayersInWorld", &LuaGlobalFunctions::GetPlayersInWorld);
+    lua_register(L, "GetPlayersInMap", &LuaGlobalFunctions::GetPlayersInMap);
+    lua_register(L, "WorldDBQuery", &LuaGlobalFunctions::WorldDBQuery); // Not Documented
+    lua_register(L, "WorldDBExecute", &LuaGlobalFunctions::WorldDBExecute); // Not Documented
+    lua_register(L, "CharDBQuery", &LuaGlobalFunctions::CharDBQuery); // Not Documented
+    lua_register(L, "CharDBExecute", &LuaGlobalFunctions::CharDBExecute); // Not Documented
+    lua_register(L, "AuthDBQuery", &LuaGlobalFunctions::AuthDBQuery); // Not Documented
+    lua_register(L, "AuthDBExecute", &LuaGlobalFunctions::AuthDBExecute); // Not Documented
+    lua_register(L, "GetGuildByName", &LuaGlobalFunctions::GetGuildByName);
+    lua_register(L, "GetGuildByLeaderGUID", &LuaGlobalFunctions::GetGuildByLeaderGUID);
+    lua_register(L, "GetPlayerCount", &LuaGlobalFunctions::GetPlayerCount);
+    lua_register(L, "CreateLuaEvent", &LuaGlobalFunctions::CreateLuaEvent); // Not Documented
+    lua_register(L, "RegisterTimedEvent", &LuaGlobalFunctions::CreateLuaEvent); // Arc compability Not Documented
+    lua_register(L, "DestroyLuaEventByID", &LuaGlobalFunctions::DestroyLuaEventByID); // Not Documented
+    lua_register(L, "DestroyLuaEvents", &LuaGlobalFunctions::DestroyLuaEvents); // Not Documented
+    lua_register(L, "PerformIngameSpawn", &LuaGlobalFunctions::PerformIngameSpawn); // Not Documented
+    lua_register(L, "CreatePacket", &LuaGlobalFunctions::CreatePacket); // Not Documented
+	lua_register(L, "AddVendorItem", &LuaGlobalFunctions::AddVendorItem);
+	lua_register(L, "VendorRemoveItem", &LuaGlobalFunctions::VendorRemoveItem);
+	lua_register(L, "VendorRemoveAllItems", &LuaGlobalFunctions::VendorRemoveAllItems); // :VendorRemoveAllItems(creature, persist(bool)) -- Removes all items from a vendor. If persist is true, it will remove the rows in the npc_vendor table.
+}
+
+// Loads lua scripts from given directory
+void Eluna::LoadDirectory(char* Dirname, LoadedScripts* lscr)
+{
+#ifdef WIN32
+    HANDLE hFile;
+    WIN32_FIND_DATA FindData;
+    memset(&FindData, 0, sizeof(FindData));
+    char SearchName[MAX_PATH];
+
+    strcpy(SearchName, Dirname);
+    strcat(SearchName, "\\*.*");
+
+    hFile = FindFirstFile(SearchName, &FindData);
+
+    // break if we don't find dir
+    if (!hFile)
+    {
+        sLog->outError(LOG_FILTER_SERVER_LOADING, "Eluna Nova::No `scripts` directory found!");
+        return;
+    }
+
+    FindNextFile(hFile, &FindData);
+    while ( FindNextFile(hFile, &FindData) )
+    {
+        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+        {
+            strcpy(SearchName, Dirname);
+            strcat(SearchName, "\\");
+            strcat(SearchName, FindData.cFileName);
+            LoadDirectory(SearchName, lscr);
+        }
+        else
+        {
+            std::string fname = Dirname;
+            fname += "\\";
+            fname += FindData.cFileName;
+            size_t len = strlen(fname.c_str());
+            int i = 0;
+            char ext[MAX_PATH];
+            while (len > 0)
+            {
+                ext[i++] = fname[--len];
+                if (fname[len] == '.')
+                    break;
+            }
+            ext[i++] = '\0';
+            if (!_stricmp(ext,"aul."))
+                lscr->luaFiles.insert(fname);
+        }
+    }
+    FindClose(hFile);
+#else    
+    char* dir = strrchr(Dirname, '/');
+    if (strcmp(Dirname, "..") == 0 || strcmp(Dirname, ".") == 0)
+        return;
+
+    if (dir && (strcmp(dir, "/..") == 0 || strcmp(dir, "/.") == 0 || strcmp(dir, "/.svn") == 0))
+        return;
+
+    struct dirent** list;
+    int fileCount = scandir(Dirname, &list, 0, 0);
+
+    if (fileCount <= 0 || !list)
+        return;
+
+    struct stat attributes;
+    bool error;
+    while (fileCount--)
+    {
+        char _path[200];
+        sprintf(_path, "%s/%s", Dirname, list[fileCount]->d_name);
+        if (stat(_path, &attributes) == -1)
+        {
+            error = true;
+            sLog->outError(LOG_FILTER_SERVER_LOADING, "Eluna Nova::Error opening `%s`", _path);
+        }
+        else
+            error = false;
+
+        if (!error && S_ISDIR(attributes.st_mode))
+            LoadDirectory((char*)_path, lscr);
+        else
+        {
+            char* ext = strrchr(list[fileCount]->d_name, '.');
+            if (ext && !strcmp(ext, ".lua"))
+                lscr->luaFiles.insert(_path);
+        }
+        free(list[fileCount]);
+    }
+    free(list);
+#endif
+}
+
+void Eluna::report(lua_State* L)
+{
+    const char* msg = lua_tostring(L, -1);
+    while (msg)
+    {
+        lua_pop(L, -1);
+        printf("\t%s\n",msg);
+        msg = lua_tostring(L, -1);
+    }
+}
+
+/* Pushes */
+// Pushes a low part of a guid (low guid)
+void Eluna::PushGUID(lua_State* L, uint64 g)
+{
+    if (!L) L = LuaState;
+    lua_pushunsigned(L, GUID_LOPART(g));
+}
+
+void Eluna::PushInteger(lua_State* L, int i)
+{
+    if (!L) L = LuaState;
+    lua_pushinteger(L, i);
+}
+
+void Eluna::PushUnsigned(lua_State* L, uint32 u)
+{
+    if (!L) L = LuaState;
+    lua_pushunsigned(L, u);
+}
+
+void Eluna::PushFloat(lua_State* L, float f)
+{
+    if (!L) L = LuaState;
+    lua_pushnumber(L, f);
+}
+
+void Eluna::PushDouble(lua_State* L, double d)
+{
+    if (!L) L = LuaState;
+    lua_pushnumber(L, d);
+}
+
+void Eluna::PushBoolean(lua_State* L, bool b)
+{
+    if (!L) L = LuaState;
+    if (b)
+        lua_pushboolean(L, 1);
+    else
+        lua_pushboolean(L, 0);
+}
+
+void Eluna::PushString(lua_State* L, const char* str)
+{
+    if (!L) L = LuaState;
+    lua_pushstring(L, str);
+}
+
+void Eluna::PushGroup(lua_State* L, Group* group)
+{
+    if (!L) L = LuaState;
+    if (group)
+        ElunaTemplate<Group>::push(L, group);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushGuild(lua_State* L, Guild* guild)
+{
+    if (!L) L = LuaState;
+    if (guild)
+        ElunaTemplate<Guild>::push(L, guild);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushUnit(lua_State* L, Unit* unit)
+{
+    if (!L) L = LuaState;
+    if (unit)
+        ElunaTemplate<Unit>::push(L, unit);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushQueryResult(lua_State* L, QueryResult* result)
+{
+    if (!L) L = LuaState;
+    if (result)
+        ElunaTemplate<QueryResult>::push(L, result);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushGO(lua_State* L, GameObject* _go)
+{
+    if (!L) L = LuaState;
+    if (_go)
+        ElunaTemplate<GameObject>::push(L, _go);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushAura(lua_State* L, Aura* aura)
+{
+    if (!L) L = LuaState;
+    if (aura)
+        ElunaTemplate<Aura>::push(L, aura);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushItem(lua_State* L, Item* item)
+{
+    if (!L) L = LuaState;
+    if (item)
+        ElunaTemplate<Item>::push(L, item);
+    else
+        lua_pushnil(L);
+}
+
+void Eluna::PushSpell(lua_State* L, Spell* spell)
+{
+	if (!L) L = LuaState;
+	if (spell)
+		ElunaTemplate<Spell>::push(L, spell);
+	else
+		lua_pushnil(L);
+}
+
+void Eluna::PushQuest(lua_State* L, Quest const* quest)
+{
+	if (!L) L = LuaState;
+	if (quest)
+		ElunaTemplate<Quest>::push(L, const_cast<Quest*>(quest));
+	else
+		lua_pushnil(L);
+}
+
+void Eluna::PushPacket(lua_State* L, WorldPacket* packet)
+{
+    if (!L) L = LuaState;
+    if (packet)
+        ElunaTemplate<WorldPacket>::push(L, packet);
+    else
+        lua_pushnil(L);
+}
+
+// Unregisters and stops all timed events
+void Eluna::LuaEventMap::LuaEventsResetAll()
+{
+    // GameObject && Creature events reset
+    if (!Eluna::get()->scriptsToClear.empty())
+        for (set<Eluna::LuaEventMap*>::iterator itr = Eluna::get()->scriptsToClear.begin(); itr != Eluna::get()->scriptsToClear.end(); ++itr)
+            if (*itr)
+                (*itr)->LuaEventsReset();
+    // Global events reset
+    sLuaWorldScript->LuaEventsReset();
+}
+
+// RegisterServerHook(ev, func)
+static int RegisterServerHook(lua_State* L)
+{
+    int functionRef = 0;
+    lua_settop(L, 2);
+    uint32 ev = luaL_checkunsigned(L, 1);
+    const char* typeName = luaL_typename(L, 2);
+
+    if (ev == 0 || !typeName)
+        return 0;
+
+    if (!strcmp(typeName, "function"))
+        functionRef = lua_ref(L, true);
+
+    if (functionRef > 0)
+        Eluna::get()->Register(REGTYPE_SERVER, 0, ev, functionRef);
+    return 0;
+}
+
+//RegisterCreatureGossipEvent(ev, func)
+static int RegisterCreatureGossipEvent(lua_State* L)
+{
+    int functionRef = 0;
+    lua_settop(L, 3);
+    uint32 entry = luaL_checkint(L, 1);
+    uint32 ev = luaL_checkunsigned(L, 2);
+    const char* typeName = luaL_typename(L, 3);
+
+    if (ev == 0 || !typeName)
+        return 0;
+
+    if (!strcmp(typeName, "function"))
+        functionRef = lua_ref(L, true);
+
+    if (functionRef > 0)
+        Eluna::get()->Register(REGTYPE_CREATURE_GOSSIP, entry, ev, functionRef);
+    return 0;
+}
+
+// RegisterGameObjectGossipEvent(entry, event, function)
+static int RegisterGameObjectGossipEvent(lua_State* L)
+{
+    int functionRef = 0;
+    lua_settop(L, 3);
+    uint32 entry = luaL_checkint(L, 1);
+    uint32 ev = luaL_checkunsigned(L, 2);
+    const char* typeName = luaL_typename(L, 3);
+
+    if (ev == 0 || !typeName)
+        return 0;
+
+    if (!strcmp(typeName, "function"))
+        functionRef = lua_ref(L, true);
+
+    if (functionRef > 0)
+        Eluna::get()->Register(REGTYPE_GAMEOBJECT_GOSSIP, entry, ev, functionRef);
+    return 0;
+}
+
+// RegisterItemEvent(entry, event, function)
+static int RegisterItemEvent(lua_State* L)
+{
+    int functionRef = 0;
+    lua_settop(L, 3);
+    uint32 entry = luaL_checkint(L, 1);
+    uint32 ev = luaL_checkunsigned(L, 2);
+    const char* typeName = luaL_typename(L, 3);
+
+    if (ev == 0 || !typeName)
+        return 0;
+
+    if (!strcmp(typeName, "function"))
+        functionRef = lua_ref(L, true);
+
+    if (functionRef > 0)
+        Eluna::get()->Register(REGTYPE_ITEM, entry, ev, functionRef);
+    return 0;
+}
+
+// RegisterItemGossipEvent(entry, event, function)
+static int RegisterItemGossipEvent(lua_State* L)
+{
+    int functionRef = 0;
+    lua_settop(L, 3);
+    uint32 entry = luaL_checkint(L, 1);
+    uint32 ev = luaL_checkunsigned(L, 2);
+    const char* typeName = luaL_typename(L, 3);
+
+    if (ev == 0 || !typeName)
+        return 0;
+
+    if (!strcmp(typeName, "function"))
+        functionRef = lua_ref(L, true);
+
+    if (functionRef > 0)
+        Eluna::get()->Register(REGTYPE_ITEM_GOSSIP, entry, ev, functionRef);
+    return 0;
+}
+
+// RegisterPlayerGossipEvent(menu_id, event, function)
+static int RegisterPlayerGossipEvent(lua_State* L)
+{
+    int functionRef = 0;
+    lua_settop(L, 3);
+    uint32 menu_id = luaL_checkint(L, 1);
+    uint32 ev = luaL_checkunsigned(L, 2);
+    const char* typeName = luaL_typename(L, 3);
+
+    if (ev == 0 || !typeName)
+        return 0;
+
+    if (!strcmp(typeName, "function"))
+        functionRef = lua_ref(L, true);
+
+    if (functionRef > 0)
+        Eluna::get()->Register(REGTYPE_PLAYER_GOSSIP, menu_id, ev, functionRef);
+    return 0;
+}
+
+// RegisterCreatureEvent(entry, ev, func)
+static int RegisterCreatureEvent(lua_State* L)
+{
+    int functionRef = 0;
+    lua_settop(L, 3);
+    uint32 entry = luaL_checkint(L, 1);
+    uint32 ev = luaL_checkunsigned(L, 2);
+    const char* typeName = luaL_typename(L, 3);
+    if (ev == 0 || !typeName)
+        return 0;
+
+    if (!strcmp(typeName, "function"))
+        functionRef = lua_ref(L, true);
+
+    if (functionRef > 0)
+        Eluna::get()->Register(REGTYPE_CREATURE, entry, ev, functionRef);
+    return 0;
+}
+
+// RegisterGameObjectEvent(entry, event, func)
+static int RegisterGameObjectEvent(lua_State* L)
+{
+    int functionRef = 0;
+    lua_settop(L, 3);
+    uint32 entry = luaL_checkint(L, 1);
+    uint32 ev = luaL_checkunsigned(L, 2);
+    const char* typeName = luaL_typename(L, 3);
+    if (ev == 0 || !typeName)
+        return 0;
+
+    if (!strcmp(typeName, "function"))
+        functionRef = lua_ref(L, true);
+
+    if (functionRef > 0)
+        Eluna::get()->Register(REGTYPE_GAMEOBJECT, entry, ev, functionRef);
+    return 0;
+}
+
+// Saves the function reference ID given to the register type's store for given entry under the given event
+void Eluna::Register(uint8 regtype, uint32 id, uint32 evt, int functionRef)
+{
+    switch(regtype)
+    {
+    case REGTYPE_SERVER:
+        if (evt < SERVER_EVENT_COUNT)
+        {
+            ServerEventBindings.at(evt).push_back(functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_CREATURE:
+        if (evt < CREATURE_EVENT_COUNT)
+        {
+            sLuaCreatureScript->RegisterCreatureScript(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_CREATURE_GOSSIP:
+        if (evt < GOSSIP_EVENT_COUNT)
+        {
+            sLuaCreatureScript->RegisterCreatureGossipScript(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_GAMEOBJECT:
+        if (evt < GAMEOBJECT_EVENT_COUNT)
+        {
+            sLuaGameObjectScript->RegisterGameObjectScript(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_GAMEOBJECT_GOSSIP:
+        if (evt < GOSSIP_EVENT_COUNT)
+        {
+            sLuaGameObjectScript->RegisterGameObjectGossipScript(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_ITEM:
+        if (evt < ITEM_EVENT_COUNT)
+        {
+            if (!sObjectMgr->GetItemTemplate(id))
+            {
+                sLog->outError(LOG_FILTER_GENERAL, "Eluna Nova::Couldn't find a item with (ID: %d)!", id);
+                return;
+            }
+
+            get()->ItemEventBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_ITEM_GOSSIP:
+        if (evt < GOSSIP_EVENT_COUNT)
+        {
+            if (!sObjectMgr->GetItemTemplate(id))
+            {
+                sLog->outError(LOG_FILTER_GENERAL, "Eluna Nova::Couldn't find a item with (ID: %d)!", id);
+                return;
+            }
+
+            get()->ItemGossipBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    case REGTYPE_PLAYER_GOSSIP:
+        if (evt < GOSSIP_EVENT_COUNT)
+        {
+            get()->playerGossipBindings->Insert(id, evt, functionRef);
+            return;
+        }
+        break;
+
+    default:
+        sLog->outError(LOG_FILTER_GENERAL, "Unknown register type (regtype %u, id %u, event %u)", regtype, id, evt);
+        return;
+    }
+    sLog->outError(LOG_FILTER_GENERAL, "Unknown event type (regtype %u, id %u, event %u)", regtype, id, evt);
+}
+
+void Eluna::Restart()
+{
+    sLog->outInfo(LOG_FILTER_GENERAL, "Eluna Nova::Restarting Engine");
+
+    getScript()->OnElunaRestart(ELUNA_EVENT_ON_RESTART);
+
+    Eluna::LuaEventMap::LuaEventsResetAll(); // Unregisters and stops all timed events
+
+    for (map<int, vector<int> >::iterator itr = get()->ServerEventBindings.begin(); itr != get()->ServerEventBindings.end(); ++itr)
+    {
+        for (vector<int>::iterator it = itr->second.begin(); it != itr->second.end(); ++it)
+            luaL_unref(get()->LuaState, LUA_REGISTRYINDEX, (*it));
+        itr->second.clear();
+    }
+
+    get()->CreatureEventBindings->Clear();
+    get()->CreatureGossipBindings->Clear();
+    get()->GameObjectEventBindings->Clear();
+    get()->GameObjectGossipBindings->Clear();
+    get()->ItemEventBindings->Clear();
+    get()->ItemGossipBindings->Clear();
+    get()->playerGossipBindings->Clear();
+
+    lua_close(get()->LuaState); // Closing
+
+    get()->StartEluna(); // Restarting
+}
diff --git a/src/server/LuaEngine/LuaEngine.h b/src/server/LuaEngine/LuaEngine.h
new file mode 100644
index 0000000..77e2ac8
--- /dev/null
+++ b/src/server/LuaEngine/LuaEngine.h
@@ -0,0 +1,2574 @@
+#ifndef __ELUNA__H
+#define __ELUNA__H
+#include <string>
+#include <map>
+#include "AccountMgr.h"
+#include "Chat.h"
+#include "Channel.h"
+#include "Creature.h"
+#include "GameObjectAI.h"
+#include "Group.h"
+#include "Guild.h"
+#include "GuildMgr.h"
+#include "QuestDef.h"
+#include "ScriptPCH.h"
+#include "ScriptMgr.h"
+#include "ScriptedCreature.h"
+#include "ArenaTeam.h"
+#include "Vehicle.h"
+#include "SystemConfig.h"
+#include "MapManager.h"
+
+using namespace std;
+
+extern "C"
+{
+#include "lua.h"
+#include "lualib.h"
+#include "lauxlib.h"
+};
+
+class ElunaTemplate;
+class ElunaScript;
+
+struct LoadedScripts
+{
+    std::set<std::string> luaFiles;
+};
+
+enum REGISTER_TYPE
+{
+    REGTYPE_SERVER,
+    REGTYPE_CREATURE,
+    REGTYPE_CREATURE_GOSSIP,
+    REGTYPE_GAMEOBJECT,
+    REGTYPE_GAMEOBJECT_GOSSIP,
+    REGTYPE_ITEM,
+    REGTYPE_ITEM_GOSSIP,
+    REGTYPE_PLAYER_GOSSIP,
+    REGTYPE_COUNT
+};
+
+enum ServerEvents
+{
+    // Player
+    PLAYER_EVENT_ON_CHARACTER_CREATE        =     1,            // Implemented
+    PLAYER_EVENT_ON_CHARACTER_DELETE        =     2,            // Implemented
+    PLAYER_EVENT_ON_LOGIN                   =     3,            // Implemented
+    PLAYER_EVENT_ON_LOGOUT                  =     4,            // Implemented
+    PLAYER_EVENT_ON_SPELL_CAST              =     5,            // Implemented
+    PLAYER_EVENT_ON_KILL_PLAYER             =     6,            // Implemented
+    PLAYER_EVENT_ON_KILL_CREATURE           =     7,            // Implemented
+    PLAYER_EVENT_ON_KILLED_BY_CREATURE      =     8,            // Implemented
+    PLAYER_EVENT_ON_DUEL_REQUEST            =     9,            // Implemented
+    PLAYER_EVENT_ON_DUEL_START              =     10,           // Implemented
+    PLAYER_EVENT_ON_DUEL_END                =     11,           // Implemented
+    PLAYER_EVENT_ON_GIVE_XP                 =     12,           // Implemented
+    PLAYER_EVENT_ON_LEVEL_CHANGE            =     13,           // Implemented -- The level is the old level
+    PLAYER_EVENT_ON_MONEY_CHANGE            =     14,           // Implemented
+    PLAYER_EVENT_ON_REPUTATION_CHANGE       =     15,           // Implemented
+    PLAYER_EVENT_ON_TALENTS_CHANGE          =     16,           // Implemented
+    PLAYER_EVENT_ON_TALENTS_RESET           =     17,           // Implemented
+    PLAYER_EVENT_ON_CHAT                    =     18,           // Implemented
+    PLAYER_EVENT_ON_WHISPER                 =     19,           // Implemented
+    PLAYER_EVENT_ON_GROUP_CHAT              =     20,           // Implemented
+    PLAYER_EVENT_ON_GUILD_CHAT              =     21,           // Implemented
+    PLAYER_EVENT_ON_CHANNEL_CHAT            =     22,           // Implemented
+    PLAYER_EVENT_ON_EMOTE                   =     23,           // Implemented -- Not triggered on any known emote
+    PLAYER_EVENT_ON_TEXT_EMOTE              =     24,           // Implemented
+    PLAYER_EVENT_ON_SAVE                    =     25,           // Implemented
+    PLAYER_EVENT_ON_BIND_TO_INSTANCE        =     26,           // Implemented
+    PLAYER_EVENT_ON_UPDATE_ZONE             =     27,           // Implemented
+    PLAYER_EVENT_ON_MAP_CHANGE              =     28,           // Implemented
+
+    // Guild
+    GUILD_EVENT_ON_ADD_MEMBER               =     29,           // Implemented -- Commented out
+    GUILD_EVENT_ON_REMOVE_MEMBER            =     30,           // Implemented -- Commented out
+    GUILD_EVENT_ON_MOTD_CHANGE              =     31,           // Implemented -- Commented out
+    GUILD_EVENT_ON_INFO_CHANGE              =     32,           // Implemented -- Commented out
+    GUILD_EVENT_ON_CREATE                   =     33,           // Implemented -- Commented out
+    GUILD_EVENT_ON_DISBAND                  =     34,           // Implemented -- Commented out
+    GUILD_EVENT_ON_MONEY_WITHDRAW           =     35,           // Implemented -- Commented out
+    GUILD_EVENT_ON_MONEY_DEPOSIT            =     36,           // Implemented -- Commented out
+    GUILD_EVENT_ON_ITEM_MOVE                =     37,           // Implemented -- Commented out
+    GUILD_EVENT_ON_EVENT                    =     38,           // Implemented -- Commented out
+    GUILD_EVENT_ON_BANK_EVENT               =     39,           // Implemented -- Commented out
+
+    // Server
+    SERVER_EVENT_ON_NETWORK_START           =     40,           // Not Implemented
+    SERVER_EVENT_ON_NETWORK_STOP            =     41,           // Not Implemented
+    SERVER_EVENT_ON_SOCKET_OPEN             =     42,           // Not Implemented
+    SERVER_EVENT_ON_SOCKET_CLOSE            =     43,           // Not Implemented
+    SERVER_EVENT_ON_PACKET_RECEIVE          =     44,           // Not Implemented
+    SERVER_EVENT_ON_PACKET_RECEIVE_UNKNOWN  =     45,           // Not Implemented
+    SERVER_EVENT_ON_PACKET_SEND             =     46,           // Not Implemented
+
+    // World
+    WORLD_EVENT_ON_OPEN_STATE_CHANGE        =     47,           // Implemented
+    WORLD_EVENT_ON_CONFIG_LOAD              =     48,           // Implemented
+    WORLD_EVENT_ON_MOTD_CHANGE              =     49,           // Implemented
+    WORLD_EVENT_ON_SHUTDOWN_INIT            =     50,           // Implemented
+    WORLD_EVENT_ON_SHUTDOWN_CANCEL          =     51,           // Implemented
+    WORLD_EVENT_ON_UPDATE                   =     52,           // Implemented
+    WORLD_EVENT_ON_STARTUP                  =     53,           // Implemented -- Actual server start
+    WORLD_EVENT_ON_SHUTDOWN                 =     54,           // Implemented
+
+    // Eluna
+    ELUNA_EVENT_ON_RESTART                  =     55,           // Implemented
+
+    // Map
+    MAP_EVENT_ON_CREATE                     =     56,           // Not Implemented
+    MAP_EVENT_ON_DESTROY                    =     57,           // Not Implemented
+    MAP_EVENT_ON_LOAD                       =     58,           // Not Implemented
+    MAP_EVENT_ON_UNLOAD                     =     59,           // Not Implemented
+    MAP_EVENT_ON_PLAYER_ENTER               =     60,           // Not Implemented
+    MAP_EVENT_ON_PLAYER_LEAVE               =     61,           // Not Implemented
+    MAP_EVENT_ON_UPDATE                     =     62,           // Not Implemented
+
+    // Area trigger
+    TRIGGER_EVENT_ON_TRIGGER                =     63,           // Implemented
+
+    // Weather
+    WEATHER_EVENT_ON_CHANGE                 =     64,           // Implemented - Add weather object?
+
+    // Auction house
+    AUCTION_EVENT_ON_ADD                    =     65,           // Not Implemented
+    AUCTION_EVENT_ON_REMOVE                 =     66,           // Not Implemented
+    AUCTION_EVENT_ON_SUCCESFUL              =     67,           // Not Implemented
+    AUCTION_EVENT_ON_EXPIRE                 =     68,           // Not Implemented
+
+    // Group
+    GROUP_EVENT_ON_MEMBER_ADD               =     69,           // Implemented
+    GROUP_EVENT_ON_MEMBER_INVITE            =     70,           // Implemented
+    GROUP_EVENT_ON_MEMBER_REMOVE            =     71,           // Implemented
+    GROUP_EVENT_ON_LEADER_CHANGE            =     72,           // Implemented
+    GROUP_EVENT_ON_DISBAND                  =     73,           // Implemented
+
+    SERVER_EVENT_COUNT
+};
+
+enum CreatureEvents
+{
+    CREATURE_EVENT_ON_ENTER_COMBAT                    = 1,      //Implemented
+    CREATURE_EVENT_ON_LEAVE_COMBAT                    = 2,      //Implemented
+    CREATURE_EVENT_ON_TARGET_DIED                     = 3,      //Implemented
+    CREATURE_EVENT_ON_DIED                            = 4,      //Implemented
+    CREATURE_EVENT_ON_SPAWN                           = 5,      //Implemented
+    CREATURE_EVENT_ON_REACH_WP                        = 6,      //Implemented
+    CREATURE_EVENT_ON_AIUPDATE                        = 7,      //Implemented
+    CREATURE_EVENT_ON_RECEIVE_EMOTE                   = 8,      //Implemented
+    CREATURE_EVENT_ON_DAMAGE_TAKEN                    = 9,      //Implemented
+    CREATURE_EVENT_ON_PRE_COMBAT                      = 10,     //Implemented
+    CREATURE_EVENT_ON_ATTACKED_AT                     = 11,     //Implemented
+    CREATURE_EVENT_ON_OWNER_ATTACKED                  = 12,     //Implemented
+    CREATURE_EVENT_ON_OWNER_ATTACKED_AT               = 13,     //Implemented
+    CREATURE_EVENT_ON_HIT_BY_SPELL                    = 14,     //Implemented
+    CREATURE_EVENT_ON_SPELL_HIT_TARGET                = 15,     //Implemented
+    CREATURE_EVENT_ON_SPELL_CLICK                     = 16,     //Implemented
+    CREATURE_EVENT_ON_CHARMED                         = 17,     //Implemented
+    CREATURE_EVENT_ON_POSSESS                         = 18,     //Implemented
+    CREATURE_EVENT_ON_JUST_SUMMONED_CREATURE          = 19,     //Implemented
+    CREATURE_EVENT_ON_SUMMONED_CREATURE_DESPAWN       = 20,     //Implemented
+    CREATURE_EVENT_ON_SUMMONED_CREATURE_DIED          = 21,     //Implemented
+    CREATURE_EVENT_ON_SUMMONED                        = 22,     //Implemented
+    CREATURE_EVENT_ON_RESET                           = 23,     //Implemented
+    CREATURE_EVENT_ON_REACH_HOME                      = 24,     //Implemented
+    CREATURE_EVENT_ON_CAN_RESPAWN                     = 25,     //Implemented
+    CREATURE_EVENT_ON_CORPSE_REMOVED                  = 26,     //Implemented
+    CREATURE_EVENT_ON_MOVE_IN_LOS                     = 27,     //Implemented
+    CREATURE_EVENT_ON_VISIBLE_MOVE_IN_LOS             = 28,     //Implemented
+    CREATURE_EVENT_ON_PASSANGER_BOARDED               = 29,     //Implemented
+    CREATURE_EVENT_ON_DUMMY_EFFECT                    = 30,     //Implemented
+    CREATURE_EVENT_ON_QUEST_ACCEPT                    = 31,     //Implemented
+    CREATURE_EVENT_ON_QUEST_SELECT                    = 32,     //Implemented
+    CREATURE_EVENT_ON_QUEST_COMPLETE                  = 33,     //Implemented
+    CREATURE_EVENT_ON_QUEST_REWARD                    = 34,     //Implemented
+    CREATURE_EVENT_ON_DIALOG_STATUS                   = 35,     //Implemented
+    CREATURE_EVENT_COUNT
+};
+
+enum GameObjectEvents
+{
+    GAMEOBJECT_EVENT_ON_AIUPDATE                    = 1,    // Implemented
+    GAMEOBJECT_EVENT_ON_RESET                       = 2,    // Implemented
+    GAMEOBJECT_EVENT_ON_DUMMY_EFFECT                = 3,    // Implemented
+    GAMEOBJECT_EVENT_ON_QUEST_ACCEPT                = 4,    // Implemented
+    GAMEOBJECT_EVENT_ON_QUEST_REWARD                = 5,    // Implemented
+    GAMEOBJECT_EVENT_ON_DIALOG_STATUS               = 6,    // Implemented
+    GAMEOBJECT_EVENT_ON_DESTROYED                   = 7,    // Implemented
+    GAMEOBJECT_EVENT_ON_DAMAGED                     = 8,    // Implemented
+    GAMEOBJECT_EVENT_ON_LOOT_STATE_CHANGE           = 9,    // Implemented
+    GAMEOBJECT_EVENT_ON_GO_STATE_CHANGED            = 10,   // Implemented
+    GAMEOBJECT_EVENT_COUNT
+};
+
+enum ItemEvents
+{
+    ITEM_EVENT_ON_DUMMY_EFFECT                      = 1,    // Implemented
+    ITEM_EVENT_ON_USE                               = 2,    // Implemented
+    ITEM_EVENT_ON_QUEST_ACCEPT                      = 3,    // Implemented
+    ITEM_EVENT_ON_EXPIRE                            = 4,    // Implemented
+    ITEM_EVENT_COUNT
+};
+
+enum GossipEvents
+{
+    GOSSIP_EVENT_ON_HELLO = 1,
+    GOSSIP_EVENT_ON_SELECT = 2,
+    GOSSIP_EVENT_COUNT
+};
+
+template<class T>
+struct ElunaRegister
+{
+    const char* name;
+    int(*mfunc)(lua_State*, T*);
+};
+
+template<typename T> ElunaRegister<T>* GetMethodTable();
+template<typename T> const char* GetTName();
+
+class Eluna
+{
+    friend class ElunaScript;
+    friend class ScriptMgr;
+    static Eluna* LuaEngine;
+    static ElunaScript* Script;
+
+public:
+    static Eluna* get() { return LuaEngine; }
+    static ElunaScript* getScript() { return Script; }
+
+    typedef map<int, int> ElunaBindingMap;
+    typedef UNORDERED_MAP<uint32, ElunaBindingMap> ElunaEntryMap;
+
+    struct ElunaBind
+    {
+        // unregisters all registered functions and clears all registered events from the bind maps (reset)
+        void Clear()
+        {
+            for (ElunaEntryMap::iterator itr = Bindings.begin(); itr != Bindings.end(); ++itr)
+            {
+                for (ElunaBindingMap::iterator it = itr->second.begin(); it != itr->second.end(); ++it)
+                    luaL_unref(get()->LuaState, LUA_REGISTRYINDEX, it->second);
+                itr->second.clear();
+            }
+            Bindings.clear();
+        }
+
+        // Inserts a new registered event
+        void Insert(uint32 entryId, uint32 eventId, int funcRef)
+        {
+            if (Bindings[entryId][eventId])
+            {
+                sLog->outError(LOG_FILTER_GENERAL, "Eluna Nova::A function is already registered for entry %u event %u", entryId, eventId);
+                luaL_unref(get()->LuaState, LUA_REGISTRYINDEX, funcRef); // free the unused ref
+            }
+            else
+                Bindings[entryId][eventId] = funcRef;
+        }
+
+        // Gets the function ref of an entry for an event
+        int GetBind(uint32 entryId, uint32 eventId)
+        {
+            ElunaEntryMap::iterator itr = Bindings.find(entryId);
+            if (itr == Bindings.end())
+                return 0;
+
+            return itr->second[eventId];
+        }
+
+        // Gets the binding map containing all registered events with the function refs for the entry
+        ElunaBindingMap* GetBindMap(uint32 entryId) 
+        {
+            ElunaEntryMap::iterator itr = Bindings.find(entryId);
+            if (itr == Bindings.end())
+                return NULL;
+
+            return &itr->second;
+        }
+
+        ElunaEntryMap Bindings; // Binding store Bindings[entryId][eventId] = funcRef;
+    };
+    // Binding stores
+    map<int, vector<int> > ServerEventBindings;
+    ElunaBind* CreatureEventBindings;
+    ElunaBind* CreatureGossipBindings;
+    ElunaBind* GameObjectEventBindings;
+    ElunaBind* GameObjectGossipBindings;
+    ElunaBind* ItemEventBindings;
+    ElunaBind* ItemGossipBindings;
+    ElunaBind* playerGossipBindings;
+
+    // Creates new binding stores
+    Eluna()
+    {
+        for (int i = 0; i < SERVER_EVENT_COUNT; ++i)
+        {
+            vector<int> _vector;
+            ServerEventBindings.insert(pair<int, vector<int> >(i, _vector));
+        }
+        CreatureEventBindings = new ElunaBind;
+        CreatureGossipBindings = new ElunaBind;
+        GameObjectEventBindings = new ElunaBind;
+        GameObjectGossipBindings = new ElunaBind;
+        ItemEventBindings = new ElunaBind;
+        ItemGossipBindings = new ElunaBind;
+        playerGossipBindings = new ElunaBind;
+    }
+
+    ~Eluna()
+    {
+        LuaEventMap::LuaEventsResetAll(); // Unregisters and stops all timed events
+
+        for (map<int, vector<int> >::iterator itr = ServerEventBindings.begin(); itr != ServerEventBindings.end(); ++itr)
+        {
+            for (vector<int>::iterator it = itr->second.begin(); it != itr->second.end(); ++it)
+                luaL_unref(get()->LuaState, LUA_REGISTRYINDEX, (*it));
+            itr->second.clear();
+        }
+        ServerEventBindings.clear();
+        CreatureEventBindings->Clear();
+        CreatureGossipBindings->Clear();
+        GameObjectEventBindings->Clear();
+        GameObjectGossipBindings->Clear();
+        ItemEventBindings->Clear();
+        ItemGossipBindings->Clear();
+        playerGossipBindings->Clear();
+
+        lua_close(get()->LuaState); // Closing
+    }
+
+    lua_State* LuaState;
+
+    void StartEluna();
+    void Register(uint8 reg, uint32 id, uint32 evt, int func);
+
+    static void report(lua_State*);
+
+    void BeginCall(int fReference)
+    {
+        lua_settop(LuaState, 0); //stack should be empty
+        lua_rawgeti(LuaState, LUA_REGISTRYINDEX, (fReference));
+    }
+
+    bool ExecuteCall(uint8 params, uint8 res)
+    {
+        bool ret = true;
+        int top = lua_gettop(LuaState);
+        if (strcmp(luaL_typename(LuaState,top-params), "function") )
+        {
+            ret = false;
+            if (params > 0)
+            {
+                for (int i = top; i >= (top-params); i--)
+                {
+                    if (!lua_isnone(LuaState, i) )
+                        lua_remove(LuaState, i);
+                }
+            }
+        }
+        else
+        {
+            if (lua_pcall(LuaState,params,res,0) )
+            {
+                report(LuaState);
+                ret = false;
+            }
+        }
+        return ret;
+    }
+
+    void EndCall(uint8 res)
+    {
+        for (int i = res; i > 0; i--)
+        {
+            if (!lua_isnone(LuaState,res))
+                lua_remove(LuaState,res);
+        }
+    }
+    static void Init();
+    static void Restart();
+    void RegisterGlobals(lua_State* L);
+    void LoadDirectory(char* directory, LoadedScripts* scr);
+    // Push
+    void PushGUID(lua_State*, uint64); // Gets GUIDLow (uint32)
+    void PushInteger(lua_State*, int);
+    void PushUnsigned(lua_State*, uint32);
+    void PushBoolean(lua_State*, bool);
+    void PushFloat(lua_State*, float);
+    void PushDouble(lua_State*, double);
+    void PushString(lua_State*, const char*);
+    void PushGroup(lua_State*, Group*);
+    void PushGuild(lua_State*, Guild*);
+    void PushUnit(lua_State*, Unit*);
+    void PushGO(lua_State*, GameObject*);
+    void PushQueryResult(lua_State*, QueryResult*);
+    void PushAura(lua_State*, Aura*);
+    void PushItem(lua_State*, Item*);
+	void PushSpell(lua_State*, Spell*);
+	void PushQuest(lua_State*, Quest const*);
+    void PushPacket(lua_State*, WorldPacket*);
+    // Checks
+    Player * CHECK_PLAYER(lua_State* L, int narg)
+    {
+        if (!L)
+            return ElunaTemplate<Player>::check(LuaState, narg);
+        else
+            return ElunaTemplate<Player>::check(L, narg);
+    }
+
+    Unit * CHECK_UNIT(lua_State* L, int narg)
+    {
+        if (!L)
+            return ElunaTemplate<Unit>::check(LuaState, narg);
+        else
+            return ElunaTemplate<Unit>::check(L, narg);
+    }
+
+    Creature * CHECK_CREATURE(lua_State* L, int narg)
+    {
+        if (!L)
+            return ElunaTemplate<Creature>::check(LuaState, narg);
+        else
+            return ElunaTemplate<Creature>::check(L, narg);
+    }
+
+    GameObject* CHECK_OBJECT(lua_State* L, int narg)
+    {
+        if (!L)
+            return ElunaTemplate<GameObject>::check(LuaState, narg);
+        else
+            return ElunaTemplate<GameObject>::check(L, narg);
+    }
+
+    WorldPacket* CHECK_PACKET(lua_State* L, int narg)
+    {
+        if (!L)
+            return ElunaTemplate<WorldPacket>::check(LuaState, narg);
+        else
+            return ElunaTemplate<WorldPacket>::check(L, narg);
+    }
+
+    WorldObject* CHECK_WORLDOBJECT(lua_State* L, int narg)
+    {
+        if (!L)
+            return ElunaTemplate<WorldObject>::check(LuaState, narg);
+        else
+            return ElunaTemplate<WorldObject>::check(L, narg);
+    }
+
+protected:
+    template<typename T>
+    class ElunaTemplate
+    {
+    public:
+        typedef int (*_funcptr)(lua_State* L, T* ptr);
+        typedef struct { const char* name; _funcptr mfunc; } ElunaRegister;
+
+        static void Register(lua_State* L)
+        {
+            lua_newtable(L);
+            int methods = lua_gettop(L);
+
+            luaL_newmetatable(L, GetTName<T>());
+            int metatable = lua_gettop(L);
+
+            // store method table in globals so that
+            // scripts can add functions in Lua
+            lua_pushvalue(L, methods);
+            lua_setglobal(L, GetTName<T>());
+
+            // hide metatable
+            lua_pushvalue(L, methods);
+            lua_setfield(L, metatable, "__metatable");
+
+            lua_pushvalue(L, methods);
+            lua_setfield(L, metatable, "__index");
+
+            lua_pushcfunction(L, tostringT);
+            lua_setfield(L, metatable, "__tostring");
+
+            lua_pushcfunction(L, gcT);
+            lua_setfield(L, metatable, "__gc");
+
+            lua_newtable(L);
+            lua_setmetatable(L, methods);
+
+            // fill method table.
+            if (!GetMethodTable<T>())
+            {
+                lua_pop(L, 2);
+                return;
+            }
+
+            for (ElunaRegister* l = ((ElunaRegister*)GetMethodTable<T>()); l->name; ++l)
+            {
+                lua_pushstring(L, l->name);
+                lua_pushlightuserdata(L, (void*)l);
+                lua_pushcclosure(L, thunk, 1);
+                lua_settable(L, methods);
+            }
+
+            lua_pop(L, 2);
+        }
+
+        static int push(lua_State* L, T* obj, bool gc = false)
+        {
+            if (!obj)
+            {
+                lua_pushnil(L);
+                return lua_gettop(L);
+            }
+            luaL_getmetatable(L, GetTName<T>());
+            if (lua_isnil(L, -1))
+                luaL_error(L, "%s missing metatable", GetTName<T>());
+            int idxMt = lua_gettop(L);
+            T** ptrHold = (T**)lua_newuserdata(L, sizeof(T**));
+            int ud = lua_gettop(L);
+            if (ptrHold)
+            {
+                *ptrHold = obj;
+                lua_pushvalue(L, idxMt);
+                lua_setmetatable(L, -2);
+                char name[32];
+                tostring(name, obj);
+                lua_getfield(L, LUA_REGISTRYINDEX, "DO NOT TRASH");
+                if (lua_isnil(L, -1))
+                {
+                    luaL_newmetatable(L, "DO NOT TRASH");
+                    lua_pop(L, 1);
+                }
+                lua_getfield(L, LUA_REGISTRYINDEX, "DO NOT TRASH");
+                if (gc == false)
+                {
+                    lua_pushboolean(L, 1);
+                    lua_setfield(L, -2, name);
+                }
+                lua_pop(L, 1);
+            }
+            lua_settop(L, ud);
+            lua_replace(L, idxMt);
+            lua_settop(L, idxMt);
+            return idxMt;
+        }
+
+        static T* check(lua_State* L, int narg)
+        {
+            T** ptrHold = static_cast<T**>(lua_touserdata(L, narg));
+            if (!ptrHold)
+                return NULL;
+            return *ptrHold;
+        }
+
+    private:
+        static int thunk(lua_State* L)
+        {
+            T* obj = check(L, 1); // get self
+            lua_remove(L, 1); // remove self
+            ElunaRegister* l = static_cast<ElunaRegister*>(lua_touserdata(L, lua_upvalueindex(1)));
+            return l->mfunc(L, obj);
+        }
+
+        static int gcT(lua_State* L)
+        {
+            T* obj = check(L, 1);
+            if (!obj)
+                return 0;
+            lua_getfield(L, LUA_REGISTRYINDEX, "DO NO TRASH");
+            if (lua_istable(L, -1))
+            {
+                char name[32];
+                tostring(name, obj);
+                lua_getfield(L, -1, std::string(name).c_str());
+                if (lua_isnil(L, -1))
+                {
+                    delete obj;
+                    obj = NULL;
+                }
+            }
+            return 1;
+        }
+
+        static int tostringT(lua_State* L)
+        {
+            char buff[32];
+            T** ptrHold = (T**)lua_touserdata(L, 1);
+            T* obj = *ptrHold;
+            sprintf(buff, "%p", obj);
+            lua_pushfstring(L, "%s (%s)", GetTName<T>(), buff);
+            return 1;
+        }
+
+        inline static void tostring(char* buff, void* obj)
+        {
+            sprintf(buff, "%p", obj);
+        }
+
+        static int index(lua_State* L)
+        {
+            lua_getglobal(L, GetTName<T>());
+            const char* key = lua_tostring(L, 2);
+            if (lua_istable(L, - 1))
+            {
+                lua_pushvalue(L, 2);
+                lua_rawget(L, -2);
+                if (lua_isnil(L, -1))
+                {
+                    lua_getmetatable(L, -2);
+                    if (lua_istable(L, -1))
+                    {
+                        lua_getfield(L, -1, "__index");
+                        if (lua_isfunction(L, -1))
+                        {
+                            lua_pushvalue(L, 1);
+                            lua_pushvalue(L, 2);
+                            lua_pcall(L, 2, 1, 0);
+                        }
+                        else if (lua_istable(L, -1))
+                            lua_getfield(L, -1, key);
+                        else
+                            lua_pushnil(L);
+                    }
+                    else
+                        lua_pushnil(L);
+                }
+                else if (lua_istable(L, -1))
+                {
+                    lua_pushvalue(L, 2);
+                    lua_rawget(L, -2);
+                }
+            }
+            else
+                lua_pushnil(L);
+            lua_insert(L, 1);
+            lua_settop(L, 1);
+            return 1;
+        }
+    };
+
+public:
+    class LuaEventMap
+    {
+    public:
+        LuaEventMap() { }
+        ~LuaEventMap() { LuaEventsReset(); }
+
+        struct eventData
+        {
+            int funcRef; uint32 delay; uint32 calls;
+            eventData(int _funcRef, uint32 _delay, uint32 _calls) :
+            funcRef(_funcRef), delay(_delay), calls(_calls) {}
+        };
+
+        typedef std::multimap<uint32, eventData> EventStore; // Not to use multimap? Can same function ref ID be used multiple times?
+
+        virtual void OnLuaEvent(int funcRef, uint32 delay, uint32 calls) { }
+        static void LuaEventsResetAll(); // Unregisters and stops all timed events
+
+        void LuaEventsReset()
+        {
+            _time = 0;
+            if (LuaEventsEmpty())
+                return;
+            for (EventStore::iterator itr = _eventMap.begin(); itr != _eventMap.end();)
+            {
+                luaL_unref(get()->LuaState, LUA_REGISTRYINDEX, itr->second.funcRef);
+                ++itr;
+            }
+            _eventMap.clear();
+        }
+
+        void LuaEventsUpdate(uint32 time)
+        {
+            _time += time;
+        }
+
+        bool LuaEventsEmpty() const
+        {
+            return _eventMap.empty();
+        }
+
+        void LuaEventCreate(int funcRef, uint32 delay, uint32 calls)
+        {
+            _eventMap.insert(EventStore::value_type(_time + delay, eventData(funcRef, delay, calls)));
+        }
+
+        void LuaEventCancel(int funcRef)
+        {
+            if (LuaEventsEmpty())
+                return;
+
+            for (EventStore::iterator itr = _eventMap.begin(); itr != _eventMap.end();)
+            {
+                if (funcRef == itr->second.funcRef)
+                {
+                    luaL_unref(get()->LuaState, LUA_REGISTRYINDEX, itr->second.funcRef);
+                    _eventMap.erase(itr++);
+                }
+                else
+                    ++itr;
+            }
+        }
+
+        void LuaEventsExecute()
+        {
+            if (LuaEventsEmpty())
+                return;
+
+            for (EventStore::iterator itr = _eventMap.begin(); itr != _eventMap.end();)
+            {
+                if (itr->first > _time)
+                {
+                    ++itr;
+                    continue;
+                }
+
+                OnLuaEvent(itr->second.funcRef, itr->second.delay, itr->second.calls);
+
+                if (itr->second.calls != 1)
+                {
+                    if (itr->second.calls > 1)
+                        itr->second.calls = itr->second.calls-1;
+                    _eventMap.insert(EventStore::value_type(_time + itr->second.delay, itr->second));
+                }
+                _eventMap.erase(itr++);
+            }
+        }
+
+    private:
+        EventStore _eventMap;
+        uint32 _time;
+    };
+
+public:
+    class LuaWorldScript : public WorldScript, public LuaEventMap
+    {
+    public:
+        LuaWorldScript() : WorldScript("SmartLuaWorldScript"), LuaEventMap() {}
+
+        // Called on every world tick (don't execute too heavy code here).
+        void OnUpdate(uint32 diff)
+        {
+            LuaEventsUpdate(diff);
+            LuaEventsExecute();
+            for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_UPDATE).begin();
+                itr != Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_UPDATE).end(); ++itr)
+            {
+                Eluna::get()->BeginCall((*itr));
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, WORLD_EVENT_ON_UPDATE);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, diff);
+                Eluna::get()->ExecuteCall(2, 0);
+            }
+        }
+
+        // executed when a  timed event fires
+        void OnLuaEvent(int funcRef, uint32 delay, uint32 calls)
+        {
+            Eluna::get()->BeginCall(funcRef);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, funcRef);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, delay);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, calls);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+
+        // Called when the open/closed state of the world changes.
+        void OnOpenStateChange(bool open)
+        {
+            for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_OPEN_STATE_CHANGE).begin();
+                itr != Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_OPEN_STATE_CHANGE).end(); ++itr)
+            {
+                Eluna::get()->BeginCall((*itr));
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, WORLD_EVENT_ON_OPEN_STATE_CHANGE);
+                Eluna::get()->PushBoolean(Eluna::get()->LuaState, open);
+                Eluna::get()->ExecuteCall(2, 0);
+            }
+        }
+
+        // Called after the world configuration is (re)loaded.
+        void OnConfigLoad(bool reload)
+        {
+            for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_CONFIG_LOAD).begin();
+                itr != Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_CONFIG_LOAD).end(); ++itr)
+            {
+                Eluna::get()->BeginCall((*itr));
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, WORLD_EVENT_ON_CONFIG_LOAD);
+                Eluna::get()->PushBoolean(Eluna::get()->LuaState, reload);
+                Eluna::get()->ExecuteCall(2, 0);
+            }
+        }
+
+        // Called before the message of the day is changed.
+        void OnMotdChange(std::string& newMotd)
+        {
+            for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_MOTD_CHANGE).begin();
+                itr != Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_MOTD_CHANGE).end(); ++itr)
+            {
+                Eluna::get()->BeginCall((*itr));
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, WORLD_EVENT_ON_MOTD_CHANGE);
+                Eluna::get()->PushString(Eluna::get()->LuaState, newMotd.c_str());
+                Eluna::get()->ExecuteCall(2, 0);
+            }
+        }
+
+        // Called when a world shutdown is initiated.
+        void OnShutdownInitiate(ShutdownExitCode code, ShutdownMask mask)
+        {
+            for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_SHUTDOWN_INIT).begin();
+                itr != Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_SHUTDOWN_INIT).end(); ++itr)
+            {
+                Eluna::get()->BeginCall((*itr));
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, WORLD_EVENT_ON_SHUTDOWN_INIT);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, code);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, mask);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+        }
+
+        // Called when a world shutdown is cancelled.
+        void OnShutdownCancel()
+        {
+            for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_SHUTDOWN_CANCEL).begin();
+                itr != Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_SHUTDOWN_CANCEL).end(); ++itr)
+            {
+                Eluna::get()->BeginCall((*itr));
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, WORLD_EVENT_ON_SHUTDOWN_CANCEL);
+                Eluna::get()->ExecuteCall(1, 0);
+            }
+        }
+
+        // Called when the world is started.
+        void OnStartup()
+        {
+            for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_STARTUP).begin();
+                itr != Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_STARTUP).end(); ++itr)
+            {
+                Eluna::get()->BeginCall((*itr));
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, WORLD_EVENT_ON_STARTUP);
+                Eluna::get()->ExecuteCall(1, 0);
+            }
+        }
+
+        // Called when the world is actually shut down.
+        void OnShutdown()
+        {
+            for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_SHUTDOWN).begin();
+                itr != Eluna::get()->ServerEventBindings.at(WORLD_EVENT_ON_SHUTDOWN).end(); ++itr)
+            {
+                Eluna::get()->BeginCall((*itr));
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, WORLD_EVENT_ON_SHUTDOWN);
+                Eluna::get()->ExecuteCall(1, 0);
+            }
+        }
+    };
+
+public:
+    set<LuaEventMap*> scriptsToClear; // Creature and gameobject timed events
+
+public:
+    class LuaCreatureScript : CreatureScript
+    {
+    public:
+        bool IsDatabaseBound() const { return false; }
+
+        LuaCreatureScript() : CreatureScript("SmartLuaCreatureScript") // Smart suppressing error @startup
+        {
+        }
+
+        ~LuaCreatureScript()
+        {
+        }
+
+        bool RegisterCreatureScript(uint32 id, uint32 evt, int functionRef)
+        {
+            if (!sObjectMgr->GetCreatureTemplate(id))
+            {
+                sLog->outError(LOG_FILTER_GENERAL, "Eluna Nova::Couldn't find a creature with (ID: %d)!", id);
+                return false;
+            }
+
+            get()->CreatureEventBindings->Insert(id, evt, functionRef);
+            return true;
+        }
+
+        bool RegisterCreatureGossipScript(uint32 id, uint32 evt, int functionRef)
+        {
+            if (!sObjectMgr->GetCreatureTemplate(id))
+            {
+                sLog->outError(LOG_FILTER_GENERAL, "Eluna Nova::Couldn't find a creature with (ID: %d)!", id);
+                return false;
+            }
+
+            get()->CreatureGossipBindings->Insert(id, evt, functionRef);
+            return true;
+        }
+
+        struct LuaCreatureAI : ScriptedAI, public LuaEventMap
+        {
+            LuaCreatureAI(Creature* creature) : ScriptedAI(creature), LuaEventMap()
+            {
+            }
+            ~LuaCreatureAI()
+            {
+                Eluna::get()->scriptsToClear.erase(this);
+            }
+
+            //Called at World update tick
+            void UpdateAI(uint32 diff)
+            {
+                ScriptedAI::UpdateAI(diff);
+                LuaEventsUpdate(diff);
+                LuaEventsExecute();
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_AIUPDATE);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_AIUPDATE);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, diff);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // executed when a  timed event fires
+            void OnLuaEvent(int funcRef, uint32 delay, uint32 calls)
+            {
+                Eluna::get()->BeginCall(funcRef);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, funcRef);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, delay);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, calls);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->ExecuteCall(4, 0);
+            }
+
+            //Called for reaction at enter to combat if not in combat yet (enemy can be NULL)
+            //Called at creature aggro either by MoveInLOS or Attack Start
+            void EnterCombat(Unit* target)
+            {
+                ScriptedAI::EnterCombat(target);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_ENTER_COMBAT);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_ENTER_COMBAT);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, target);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // Called at any Damage from any attacker (before damage apply)
+            void DamageTaken(Unit* attacker, uint32& damage)
+            {
+                ScriptedAI::DamageTaken(attacker, damage);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_DAMAGE_TAKEN);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_DAMAGE_TAKEN);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, attacker);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, damage);
+                Eluna::get()->ExecuteCall(4, 0);
+            }
+
+            //Called at creature death
+            void JustDied(Unit* killer)
+            {
+                ScriptedAI::JustDied(killer);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_DIED);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_DIED);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, killer);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            //Called at creature killing another unit
+            void KilledUnit(Unit* victim)
+            {
+                ScriptedAI::KilledUnit(victim);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_TARGET_DIED);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_TARGET_DIED);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, victim);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // Called when the creature summon successfully other creature
+            void JustSummoned(Creature* summon)
+            {
+                ScriptedAI::JustSummoned(summon);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_JUST_SUMMONED_CREATURE);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_JUST_SUMMONED_CREATURE);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, summon);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // Called when a summoned creature is despawned
+            void SummonedCreatureDespawn(Creature* summon)
+            {
+                ScriptedAI::SummonedCreatureDespawn(summon);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SUMMONED_CREATURE_DESPAWN);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_SUMMONED_CREATURE_DESPAWN);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, summon);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // Called when hit by a spell
+            void SpellHit(Unit* caster, SpellInfo const* spell)
+            {
+                ScriptedAI::SpellHit(caster, spell);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_HIT_BY_SPELL);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_HIT_BY_SPELL);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, caster);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, spell->Id); // Pass spell object?
+                Eluna::get()->ExecuteCall(4, 0);
+            }
+
+            // Called when spell hits a target
+            void SpellHitTarget(Unit* target, SpellInfo const* spell)
+            {
+                ScriptedAI::SpellHitTarget(target, spell);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SPELL_HIT_TARGET);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_SPELL_HIT_TARGET);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, target);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, spell->Id); // Pass spell object?
+                Eluna::get()->ExecuteCall(4, 0);
+            }
+
+            //Called at waypoint reached or PointMovement end
+            void MovementInform(uint32 type, uint32 id)
+            {
+                ScriptedAI::MovementInform(type, id);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_REACH_WP);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_REACH_WP);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, type);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, id);
+                Eluna::get()->ExecuteCall(4, 0);
+            }
+
+            // Called when AI is temporarily replaced or put back when possess is applied or removed
+            void OnPossess(bool apply)
+            {
+                ScriptedAI::OnPossess(apply);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_POSSESS);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_POSSESS);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushBoolean(Eluna::get()->LuaState, apply);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            //Called at creature reset either by death or evade
+            void Reset()
+            {
+                ScriptedAI::Reset();
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_RESET);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_RESET);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->ExecuteCall(2, 0);
+            }
+
+            // Called before EnterCombat even before the creature is in combat.
+            void AttackStart(Unit* target)
+            {
+                ScriptedAI::AttackStart(target);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_PRE_COMBAT);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_PRE_COMBAT);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, target);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // Called in Creature::Update when deathstate = DEAD. Inherited classes may maniuplate the ability to respawn based on scripted events.
+            bool CanRespawn()
+            {
+                ScriptedAI::CanRespawn();
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_CAN_RESPAWN);
+                if (!bind)
+                    return true;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_CAN_RESPAWN);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->ExecuteCall(2, 0);
+                return true;
+            }
+
+            // Called for reaction at stopping attack at no attackers or targets
+            void EnterEvadeMode()
+            {
+                ScriptedAI::EnterEvadeMode();
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_LEAVE_COMBAT);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_LEAVE_COMBAT);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->ExecuteCall(2, 0);
+            }
+
+            // Called when the creature is summoned successfully by other creature
+            void IsSummonedBy(Unit* summoner)
+            {
+                ScriptedAI::IsSummonedBy(summoner);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SUMMONED);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_SUMMONED);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, summoner);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            void SummonedCreatureDies(Creature* summon, Unit* killer)
+            {
+                ScriptedAI::SummonedCreatureDies(summon, killer);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SUMMONED_CREATURE_DIED);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_SUMMONED_CREATURE_DIED);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, summon);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, killer);
+                Eluna::get()->ExecuteCall(4, 0);
+            }
+
+            // Called when the creature is target of hostile action: swing, hostile spell landed, fear/etc)
+            void AttackedBy(Unit* attacker)
+            {
+                ScriptedAI::AttackedBy(attacker);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_ATTACKED_AT);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_ATTACKED_AT);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, attacker);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // Called when creature is spawned or respawned (for reseting variables)
+            void JustRespawned()
+            {
+                ScriptedAI::JustRespawned();
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SPAWN);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_SPAWN);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->ExecuteCall(2, 0);
+            }
+
+            void OnCharmed(bool apply)
+            {
+                ScriptedAI::OnCharmed(apply);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_CHARMED);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_CHARMED);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushBoolean(Eluna::get()->LuaState, apply);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // Called at reaching home after evade
+            void JustReachedHome()
+            {
+                ScriptedAI::JustReachedHome();
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_REACH_HOME);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_REACH_HOME);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->ExecuteCall(2, 0);
+            }
+
+            // Called at text emote receive from player
+            void ReceiveEmote(Player* player, uint32 emoteId)
+            {
+                ScriptedAI::ReceiveEmote(player, emoteId);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_RECEIVE_EMOTE);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_RECEIVE_EMOTE);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, emoteId);
+                Eluna::get()->ExecuteCall(4, 0);
+            }
+
+            // Called when owner takes damage
+            void OwnerAttackedBy(Unit* attacker)
+            {
+                ScriptedAI::OwnerAttackedBy(attacker);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_OWNER_ATTACKED_AT);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_OWNER_ATTACKED_AT);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, attacker);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // Called when owner attacks something
+            void OwnerAttacked(Unit* target)
+            {
+                ScriptedAI::OwnerAttacked(target);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_OWNER_ATTACKED);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_OWNER_ATTACKED);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, target);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // called when the corpse of this creature gets removed
+            void CorpseRemoved(uint32& respawnDelay)
+            {
+                ScriptedAI::CorpseRemoved(respawnDelay);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_CORPSE_REMOVED);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_CORPSE_REMOVED);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, respawnDelay);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            void PassengerBoarded(Unit* passenger, int8 seatId, bool apply)
+            {
+                ScriptedAI::PassengerBoarded(passenger, seatId, apply);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_PASSANGER_BOARDED);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_PASSANGER_BOARDED);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, passenger);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, seatId);
+                Eluna::get()->PushBoolean(Eluna::get()->LuaState, apply);
+                Eluna::get()->ExecuteCall(5, 0);
+            }
+
+            void OnSpellClick(Unit* clicker)
+            {
+                ScriptedAI::OnSpellClick(clicker);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_SPELL_CLICK);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_SPELL_CLICK);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, clicker);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            void MoveInLineOfSight(Unit* who)
+            {
+                ScriptedAI::MoveInLineOfSight(who);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_MOVE_IN_LOS);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_MOVE_IN_LOS);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, who);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // Called if IsVisible(Unit* who) is true at each who move, reaction at visibility zone enter
+            void MoveInLineOfSight_Safe(Unit* who)
+            {
+                ScriptedAI::MoveInLineOfSight_Safe(who);
+                int bind = Eluna::get()->CreatureEventBindings->GetBind(me->GetEntry(), CREATURE_EVENT_ON_VISIBLE_MOVE_IN_LOS);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, CREATURE_EVENT_ON_VISIBLE_MOVE_IN_LOS);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, me);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, who);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+        };
+
+        LuaCreatureAI* GetAI(Creature* creature)
+        {
+            if (!Eluna::get()->CreatureEventBindings->GetBindMap(creature->GetEntry()))
+                return NULL;
+
+            LuaCreatureAI* luaCreatureAI = new LuaCreatureAI(creature);
+            Eluna::get()->scriptsToClear.insert(luaCreatureAI);
+            return luaCreatureAI;
+        }
+    };
+
+public:
+    class LuaGameObjectScript : GameObjectScript
+    {
+    public:
+        bool IsDatabaseBound() const { return false; }
+
+        LuaGameObjectScript() : GameObjectScript("SmartLuaGameObjectScript") // Smart suppressing error @startup
+        {
+        }
+        ~LuaGameObjectScript()
+        {
+        }
+
+        bool RegisterGameObjectScript(uint32 id, uint32 _event, int functionRef)
+        {
+            if (!sObjectMgr->GetGameObjectTemplate(id))
+            {
+                sLog->outError(LOG_FILTER_GENERAL, "Eluna Nova::Couldn't find a gameobject with (ID: %u)!", id);
+                return false;
+            }
+
+            Eluna::get()->GameObjectEventBindings->Insert(id, _event, functionRef);
+            return true;
+        }
+
+        bool RegisterGameObjectGossipScript(uint32 id, uint32 _event, int functionRef)
+        {
+            if (!sObjectMgr->GetGameObjectTemplate(id))
+            {
+                sLog->outError(LOG_FILTER_GENERAL, "Eluna Nova::Couldn't find a gameobject with (ID: %u)!", id);
+                return false;
+            }
+
+            Eluna::get()->GameObjectGossipBindings->Insert(id, _event, functionRef);
+            return true;
+        }
+
+        struct LuaGameObjectAI : GameObjectAI, public LuaEventMap
+        {
+            LuaGameObjectAI(GameObject* _go) : GameObjectAI(_go), LuaEventMap()
+            {
+            }
+            ~LuaGameObjectAI()
+            {
+                Eluna::get()->scriptsToClear.erase(this);
+            }
+
+            void UpdateAI(uint32 diff)
+            {
+                LuaEventsUpdate(diff);
+                LuaEventsExecute();
+                int bind = Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_AIUPDATE);
+                if (!bind)
+                    return;
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, GAMEOBJECT_EVENT_ON_AIUPDATE);
+                Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, diff);
+                Eluna::get()->ExecuteCall(3, 0);
+            }
+
+            // executed when a timed event fires
+            void OnLuaEvent(int funcRef, uint32 delay, uint32 calls)
+            {
+                Eluna::get()->BeginCall(funcRef);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, funcRef);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, delay);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, calls);
+                Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+                Eluna::get()->ExecuteCall(4, 0);
+            }
+
+            void Reset()
+            {
+                Eluna::get()->BeginCall(Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), GAMEOBJECT_EVENT_ON_RESET));
+                Eluna::get()->PushInteger(Eluna::get()->LuaState, GAMEOBJECT_EVENT_ON_RESET);
+                Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+                Eluna::get()->ExecuteCall(2, 0);
+            }
+        };
+
+        LuaGameObjectAI* GetAI(GameObject* gameObject)
+        {
+            if (!Eluna::get()->GameObjectEventBindings->GetBindMap(gameObject->GetEntry()))
+                return NULL;
+
+            LuaGameObjectAI* luaGameObjectAI = new LuaGameObjectAI(gameObject);
+            Eluna::get()->scriptsToClear.insert(luaGameObjectAI);
+            return luaGameObjectAI;
+        }
+    };
+};
+
+#define sLuaCreatureScript ACE_Singleton<Eluna::LuaCreatureScript, ACE_Null_Mutex>::instance()
+#define sLuaGameObjectScript ACE_Singleton<Eluna::LuaGameObjectScript, ACE_Null_Mutex>::instance()
+
+class ElunaScript
+{
+public:
+    static ElunaScript* get()
+    {
+        return Eluna::Script;
+    }
+
+    ElunaScript()
+    {
+    }
+
+    ~ElunaScript()
+    {
+    }
+
+    /* Item & player Gossip */
+    void HandleGossipSelectOption(Player* player, uint64 guid, uint32 sender, uint32 action, std::string code, uint32 menuId)
+    {
+        if (!player || !player->IsInWorld() || !player->isAlive() || player->GetCharmerGUID())
+            return;
+
+        if (player->HasUnitState(UNIT_STATE_DIED))
+            player->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
+        player->PlayerTalkClass->ClearMenus();
+
+        if (IS_ITEM_GUID(guid))
+        {
+            Item* item = player->GetItemByGuid(guid);
+            if (!item)
+                return;
+
+            int bind = Eluna::get()->ItemGossipBindings->GetBind(item->GetEntry(), GOSSIP_EVENT_ON_SELECT);
+            if (bind)
+            {
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, GOSSIP_EVENT_ON_SELECT);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+                Eluna::get()->PushItem(Eluna::get()->LuaState, item);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, sender);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, action);
+                if (code.empty())
+                    lua_pushnil(Eluna::get()->LuaState);
+                else
+                    Eluna::get()->PushString(Eluna::get()->LuaState, code.c_str());
+                Eluna::get()->ExecuteCall(6, 0);
+            }
+        }
+        else if (IS_PLAYER_GUID(guid))
+        {
+            if (player->GetGUID() != guid)
+                return;
+
+            int bind = Eluna::get()->playerGossipBindings->GetBind(menuId, GOSSIP_EVENT_ON_SELECT);
+            if (bind)
+            {
+                Eluna::get()->BeginCall(bind);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, GOSSIP_EVENT_ON_SELECT);
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, player); // receiver
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, player); // sender, just not to mess up the amount of args.
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, sender);
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, action);
+                if (code.empty())
+                    lua_pushnil(Eluna::get()->LuaState);
+                else
+                    Eluna::get()->PushString(Eluna::get()->LuaState, code.c_str());
+                Eluna::get()->PushUnsigned(Eluna::get()->LuaState, menuId);
+                Eluna::get()->ExecuteCall(7, 0);
+            }
+        }
+    }
+
+    bool OnDummyEffect(uint32 eventId, Unit* caster, uint32 spellId, SpellEffIndex effIndex, Item* target)
+    {
+        int bind = Eluna::get()->ItemEventBindings->GetBind(target->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, caster);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, spellId);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, effIndex);
+        Eluna::get()->PushItem(Eluna::get()->LuaState, target);
+        Eluna::get()->ExecuteCall(5, 0);
+        return true;
+    }
+
+    bool OnQuestAccept(uint32 eventId, Player* player, Item* item, Quest const* quest)
+    {
+        int bind = Eluna::get()->ItemEventBindings->GetBind(item->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushItem(Eluna::get()->LuaState, item);
+        Eluna::get()->PushQuest(Eluna::get()->LuaState, quest);
+        Eluna::get()->ExecuteCall(4, 0);
+        return true;
+    }
+
+    bool OnItemExpire(uint32 eventId, Player* player, ItemTemplate const* proto)
+    {
+        int bind = Eluna::get()->ItemEventBindings->GetBind(proto->ItemId, eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, proto->ItemId);
+        Eluna::get()->ExecuteCall(3, 0);
+        return true;
+    }
+
+    bool OnItemUse(uint32 eventId, Player* player, Item* item, SpellCastTargets const& targets)
+    {
+        int bind1 = Eluna::get()->ItemGossipBindings->GetBind(item->GetEntry(), GOSSIP_EVENT_ON_HELLO);
+        int bind2 = Eluna::get()->ItemEventBindings->GetBind(item->GetEntry(), eventId);
+        if (!bind1 && !bind2)
+            return false;
+        if (bind1)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            Eluna::get()->BeginCall(bind1);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushItem(Eluna::get()->LuaState, item);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+        if (bind2)
+        {
+            Eluna::get()->BeginCall(bind2);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushItem(Eluna::get()->LuaState, item);
+            if (GameObject* target = targets.GetGOTarget())
+                Eluna::get()->PushGO(Eluna::get()->LuaState, target);
+            else if (Item* target = targets.GetItemTarget())
+                Eluna::get()->PushItem(Eluna::get()->LuaState, target);
+            else if (Unit* target = targets.GetUnitTarget())
+                Eluna::get()->PushUnit(Eluna::get()->LuaState, target);
+            else
+                lua_pushnil(Eluna::get()->LuaState);
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+        return true;
+    }
+
+    bool OnChat(uint32 eventId, Player* player, uint32 type, uint32 lang, string& msg)
+    {
+        bool Result = true;
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushString(Eluna::get()->LuaState, msg.c_str());
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, type);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, lang);
+            if (Eluna::get()->ExecuteCall(5, 1))
+            {
+                lua_State* L = Eluna::get()->LuaState;
+                if (!lua_isnoneornil(L, 1) && !lua_toboolean(L, 1))
+                    Result = false;
+                Eluna::get()->EndCall(1);
+            }
+        }
+        return Result;
+    }
+
+    void OnChat(uint32 eventId, Player* player, uint32 type, uint32 lang, string& msg, Player* receiver)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushString(Eluna::get()->LuaState, msg.c_str());
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, type);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, lang);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, receiver);
+            Eluna::get()->ExecuteCall(6, 0);
+        }
+    }
+
+    bool OnChat(uint32 eventId, Player* player, uint32 type, uint32 lang, string& msg, Group* group)
+    {
+        bool Result = true;
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushString(Eluna::get()->LuaState, msg.c_str());
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, type);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, lang);
+            Eluna::get()->PushGroup(Eluna::get()->LuaState, group);
+            if (Eluna::get()->ExecuteCall(6, 1))
+            {
+                lua_State* L = Eluna::get()->LuaState;
+                if (!lua_isnoneornil(L, 1) && !lua_toboolean(L, 1))
+                    Result = false;
+                Eluna::get()->EndCall(1);
+            }
+        }
+        return Result;
+    }
+
+    bool OnChat(uint32 eventId, Player* player, uint32 type, uint32 lang, string& msg, Guild* guild)
+    {
+        bool Result = true;
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushString(Eluna::get()->LuaState, msg.c_str());
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, type);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, lang);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            if (Eluna::get()->ExecuteCall(6, 1))
+            {
+                lua_State* L = Eluna::get()->LuaState;
+                if (!lua_isnoneornil(L, 1) && !lua_toboolean(L, 1))
+                    Result = false;
+                Eluna::get()->EndCall(1);
+            }
+        }
+        return Result;
+    }
+
+    bool OnChat(uint32 eventId, Player* player, uint32 type, uint32 lang, string& msg, Channel* channel)
+    {
+        bool Result = true;
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushString(Eluna::get()->LuaState, msg.c_str());
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, type);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, lang);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, channel->GetChannelId());
+            if (Eluna::get()->ExecuteCall(6, 1))
+            {
+                lua_State* L = Eluna::get()->LuaState;
+                if (!lua_isnoneornil(L, 1) && !lua_toboolean(L, 1))
+                    Result = false;
+                Eluna::get()->EndCall(1);
+            }
+        }
+        return Result;
+    }
+
+    void OnPvPKill(uint32 eventId, Player* killer, Player* victim)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, killer);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, victim);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnPlayerLevelChanged(uint32 eventId, Player* player, uint8 oldLevel)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, oldLevel);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnPlayerTalentsChanged(uint32 eventId, Player* player, uint32 points)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, points);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnCreatureKill(uint32 eventId, Player* player, Creature* creature)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnPlayerKilledByCreature(uint32 eventId, Creature* creature, Player* player)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnPlayerTalentsReset(uint32 eventId, Player* player, bool noCost)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushBoolean(Eluna::get()->LuaState, noCost);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnPlayerMoneyChanged(uint32 eventId, Player* player, int32& amount)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushInteger(Eluna::get()->LuaState, amount);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnGivePlayerXP(uint32 eventId, Player* player, uint32& amount, Unit* victim)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, amount);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, victim);
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+    }
+
+    void OnPlayerReputationChange(uint32 eventId, Player* player, uint32 factionID, int32& standing, bool incremental)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, factionID);
+            Eluna::get()->PushInteger(Eluna::get()->LuaState, standing);
+            Eluna::get()->PushBoolean(Eluna::get()->LuaState, incremental);
+            Eluna::get()->ExecuteCall(5, 0);
+        }
+    }
+
+    void OnPlayerDuelRequest(uint32 eventId, Player* target, Player* challenger)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, target);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, challenger);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnPlayerDuelStart(uint32 eventId, Player* player1, Player* player2)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player1);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player2);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnPlayerDuelEnd(uint32 eventId, Player* winner, Player* loser, DuelCompleteType type)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, winner);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, loser);
+            Eluna::get()->PushInteger(Eluna::get()->LuaState, type);
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+    }
+
+    void OnPlayerEmote(uint32 eventId, Player* player, uint32 emote)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, emote);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnPlayerTextEmote(uint32 eventId, Player* player, uint32 textEmote, uint32 emoteNum, uint64 guid)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, textEmote);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, emoteNum);
+            Eluna::get()->PushGUID(Eluna::get()->LuaState, guid);
+            Eluna::get()->ExecuteCall(5, 0);
+        }
+    }
+
+    void OnPlayerSpellCast(uint32 eventId, Player* player, Spell* spell, bool skipCheck)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushSpell(Eluna::get()->LuaState, spell);
+            Eluna::get()->PushBoolean(Eluna::get()->LuaState, skipCheck);
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+    }
+
+    void OnPlayerLogin(uint32 eventId, Player* player)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->ExecuteCall(2, 0);
+        }
+    }
+
+    void OnPlayerLogout(uint32 eventId, Player* player)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->ExecuteCall(2, 0);
+        }
+    }
+
+    void OnPlayerCreate(uint32 eventId, Player* player)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->ExecuteCall(2, 0);
+        }
+    }
+
+    void OnPlayerSave(uint32 eventId, Player* player)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->ExecuteCall(2, 0);
+        }
+    }
+
+    void OnPlayerBindToInstance(uint32 eventId, Player* player, Difficulty difficulty, uint32 mapid, bool permanent)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushInteger(Eluna::get()->LuaState, difficulty);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, mapid);
+            Eluna::get()->PushBoolean(Eluna::get()->LuaState, permanent);
+            Eluna::get()->ExecuteCall(5, 0);
+        }
+    }
+
+    void OnMapChanged(uint32 eventId, Player* player)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->ExecuteCall(2, 0);
+        }
+    }
+
+    void OnPlayerUpdateZone(uint32 eventId, Player* player, uint32 newZone, uint32 newArea)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, newZone);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, newArea);
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+    }
+
+    void OnPlayerDelete(uint32 eventId, uint64 guid)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGUID(Eluna::get()->LuaState, guid);
+            Eluna::get()->ExecuteCall(2, 0);
+        }
+    }
+
+    bool OnGossipHello(uint32 eventId, Player* player, Creature* creature)
+    {
+        int bind = Eluna::get()->CreatureGossipBindings->GetBind(creature->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+        Eluna::get()->ExecuteCall(3, 0);
+        return true;
+    }
+
+    bool OnGossipSelect(uint32 eventId, Player* player, Creature* creature, uint32 sender, uint32 actions)
+    {
+        int bind = Eluna::get()->CreatureGossipBindings->GetBind(creature->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, sender);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, actions);
+        Eluna::get()->ExecuteCall(5, 0);
+        return true;
+    }
+
+    bool OnGossipSelectCode(uint32 eventId, Player* player, Creature* creature, uint32 sender, uint32 actions, const char* code)
+    {
+        int bind = Eluna::get()->CreatureGossipBindings->GetBind(creature->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, sender);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, actions);
+        Eluna::get()->PushString(Eluna::get()->LuaState, code);
+        Eluna::get()->ExecuteCall(6, 0);
+        return true;
+    }
+
+    bool OnDummyEffect(uint32 eventId, Unit* caster, uint32 spellId, SpellEffIndex effIndex, Creature* target)
+    {
+        int bind = Eluna::get()->CreatureEventBindings->GetBind(target->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, caster);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, spellId);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, effIndex);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, target);
+        Eluna::get()->ExecuteCall(5, 0);
+        return true;
+    }
+
+    bool OnQuestAccept(uint32 eventId, Player* player, Creature* creature, Quest const* quest)
+    {
+        int bind = Eluna::get()->CreatureEventBindings->GetBind(creature->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+        Eluna::get()->PushQuest(Eluna::get()->LuaState, quest);
+        Eluna::get()->ExecuteCall(4, 0);
+        return true;
+    }
+
+    bool OnQuestSelect(uint32 eventId, Player* player, Creature* creature, Quest const* quest)
+    {
+        int bind = Eluna::get()->CreatureEventBindings->GetBind(creature->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+        Eluna::get()->PushQuest(Eluna::get()->LuaState, quest);
+        Eluna::get()->ExecuteCall(4, 0);
+        return true;
+    }
+
+    bool OnQuestReward(uint32 eventId, Player* player, Creature* creature, Quest const* quest, uint32 opt)
+    {
+        int bind = Eluna::get()->CreatureEventBindings->GetBind(creature->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+        Eluna::get()->PushQuest(Eluna::get()->LuaState, quest);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, opt);
+        Eluna::get()->ExecuteCall(5, 0);
+        return true;
+    }
+
+    bool OnQuestComplete(uint32 eventId, Player* player, Creature* creature, Quest const* quest)
+    {
+        int bind = Eluna::get()->CreatureEventBindings->GetBind(creature->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+        Eluna::get()->PushQuest(Eluna::get()->LuaState, quest);
+        Eluna::get()->ExecuteCall(4, 0);
+        return true;
+    }
+
+    uint32 GetDialogStatus(uint32 eventId, Player* player, Creature* creature)
+    {
+        int bind = Eluna::get()->CreatureEventBindings->GetBind(creature->GetEntry(), eventId);
+        if (!bind)
+            return 100;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, creature);
+        Eluna::get()->ExecuteCall(3, 0);
+        return 100;
+    }
+
+    /* GameObject Gossip */
+    bool OnGossipHello(uint32 eventId, Player* player, GameObject* gameObject)
+    {
+        int bind = Eluna::get()->GameObjectGossipBindings->GetBind(gameObject->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, gameObject);
+        Eluna::get()->ExecuteCall(3, 0);
+        return true;
+    }
+
+    bool OnGossipSelect(uint32 eventId, Player* player, GameObject* gameObject, uint32 sender, uint32 actions)
+    {
+        int bind = Eluna::get()->GameObjectGossipBindings->GetBind(gameObject->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, gameObject);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, sender);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, actions);
+        Eluna::get()->ExecuteCall(5, 0);
+        return true;
+    }
+
+    bool OnGossipSelectCode(uint32 eventId, Player* player, GameObject* gameObject, uint32 sender, uint32 actions, const char* code)
+    {
+        int bind = Eluna::get()->GameObjectGossipBindings->GetBind(gameObject->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        player->PlayerTalkClass->ClearMenus();
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, gameObject);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, sender);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, actions);
+        Eluna::get()->PushString(Eluna::get()->LuaState, code);
+        Eluna::get()->ExecuteCall(6, 0);
+        return true;
+    }
+
+    // Called when a dummy spell effect is triggered on the gameobject.
+    bool OnDummyEffect(uint32 eventId, Unit* caster, uint32 spellId, SpellEffIndex effIndex, GameObject* go)
+    {
+        int bind = Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, caster);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, spellId);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, effIndex);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+        Eluna::get()->ExecuteCall(5, 0);
+        return true;
+    }
+
+    // Called when a player accepts a quest from the gameobject.
+    bool OnQuestAccept(uint32 eventId, Player* player, GameObject* go, Quest const* quest)
+    {
+        int bind = Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+        Eluna::get()->PushQuest(Eluna::get()->LuaState, quest);
+        Eluna::get()->ExecuteCall(4, 0);
+        return true;
+    }
+
+    // Called when a player selects a quest reward.
+    bool OnQuestReward(uint32 eventId, Player* player, GameObject* go, Quest const* quest, uint32 opt)
+    {
+        int bind = Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+        Eluna::get()->PushQuest(Eluna::get()->LuaState, quest);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, opt);
+        Eluna::get()->ExecuteCall(5, 0);
+        return true;
+    }
+
+    uint32 GetDialogStatus(uint32 eventId, Player* player, GameObject* go)
+    {
+        int bind = Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), eventId);
+        if (!bind)
+            return 100;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+        Eluna::get()->ExecuteCall(3, 0);
+        return 100;
+    }
+
+    // Called when the game object is destroyed (destructible buildings only).
+    bool OnDestroyed(uint32 eventId, GameObject* go, Player* player)
+    {
+        int bind = Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->ExecuteCall(3, 0);
+        return true;
+    }
+
+    // Called when the game object is damaged (destructible buildings only).
+    bool OnFirstDamaged(uint32 eventId, GameObject* go, Player* player)
+    {
+        int bind = Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+        Eluna::get()->ExecuteCall(3, 0);
+        return true;
+    }
+
+    // Called when the game object loot state is changed.
+    bool OnLootStateChanged(uint32 eventId, GameObject* go, uint32 state, Unit* unit)
+    {
+        int bind = Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, state);
+        Eluna::get()->PushUnit(Eluna::get()->LuaState, unit);
+        Eluna::get()->ExecuteCall(4, 0);
+        return true;
+    }
+
+    // Called when the game object state is changed.
+    bool OnGameObjectStateChanged(uint32 eventId, GameObject* go, uint32 state)
+    {
+        int bind = Eluna::get()->GameObjectEventBindings->GetBind(go->GetEntry(), eventId);
+        if (!bind)
+            return false;
+        Eluna::get()->BeginCall(bind);
+        Eluna::get()->PushInteger(Eluna::get()->LuaState, eventId);
+        Eluna::get()->PushGO(Eluna::get()->LuaState, go);
+        Eluna::get()->PushUnsigned(Eluna::get()->LuaState, state);
+        Eluna::get()->ExecuteCall(3, 0);
+        return true;
+    }
+
+    void OnGuildAddMember(uint32 eventId, Guild* guild, Player* player, uint8& plRank)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, plRank);
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+    }
+
+    void OnGuildRemoveMember(uint32 eventId, Guild* guild, Player* player, bool isDisbanding, bool isKicked)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushBoolean(Eluna::get()->LuaState, isDisbanding);
+            Eluna::get()->PushBoolean(Eluna::get()->LuaState, isKicked);
+            Eluna::get()->ExecuteCall(5, 0);
+        }
+    }
+
+    void OnGuildMOTDChanged(uint32 eventId, Guild* guild, const std::string& newMotd)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushString(Eluna::get()->LuaState, newMotd.c_str());
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnGuildInfoChanged(uint32 eventId, Guild* guild, const std::string& newInfo)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushString(Eluna::get()->LuaState, newInfo.c_str());
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnGuildCreate(uint32 eventId, Guild* guild, Player* leader, const std::string& name)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, leader);
+            Eluna::get()->PushString(Eluna::get()->LuaState, name.c_str());
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+    }
+
+    void OnGuildDisband(uint32 eventId, Guild* guild)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->ExecuteCall(2, 0);
+        }
+    }
+
+    void OnGuildMemberWitdrawMoney(uint32 eventId, Guild* guild, Player* player, uint32 &amount, bool isRepair)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, amount);
+            Eluna::get()->PushBoolean(Eluna::get()->LuaState, isRepair);
+            Eluna::get()->ExecuteCall(5, 0);
+        }
+    }
+
+    void OnGuildMemberDepositMoney(uint32 eventId, Guild* guild, Player* player, uint32 &amount)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, amount);
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+    }
+
+    void OnGuildItemMove(uint32 eventId, Guild* guild, Player* player, Item* pItem, bool isSrcBank, uint8 srcContainer, uint8 srcSlotId,
+        bool isDestBank, uint8 destContainer, uint8 destSlotId)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushItem(Eluna::get()->LuaState, pItem);
+            Eluna::get()->PushBoolean(Eluna::get()->LuaState, isSrcBank);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, srcContainer);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, srcSlotId);
+            Eluna::get()->PushBoolean(Eluna::get()->LuaState, isDestBank);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, destContainer);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, destSlotId);
+            Eluna::get()->ExecuteCall(10, 0);
+        }
+    }
+
+    void OnGuildEvent(uint32 eventId, Guild* guild, uint8 eventType, uint32 playerGuid1, uint32 playerGuid2, uint8 newRank)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventType);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, playerGuid1);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, playerGuid2);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, newRank);
+            Eluna::get()->ExecuteCall(6, 0);
+        }
+    }
+
+    void OnGuildBankEvent(uint32 eventId, Guild* guild, uint8 eventType, uint8 tabId, uint32 playerGuid, uint32 itemOrMoney, uint16 itemStackCount, uint8 destTabId)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGuild(Eluna::get()->LuaState, guild);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventType);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, tabId);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, playerGuid);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, itemOrMoney);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, itemStackCount);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, destTabId);
+            Eluna::get()->ExecuteCall(8, 0);
+        }
+    }
+
+    void OnGroupAddMember(uint32 eventId, Group* group, uint64 guid)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGroup(Eluna::get()->LuaState, group);
+            Eluna::get()->PushGUID(Eluna::get()->LuaState, guid);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnGroupInviteMember(uint32 eventId, Group* group, uint64 guid)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGroup(Eluna::get()->LuaState, group);
+            Eluna::get()->PushGUID(Eluna::get()->LuaState, guid);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+    }
+
+    void OnGroupRemoveMember(uint32 eventId, Group* group, uint64 guid, RemoveMethod method, uint64 kicker, const char* reason)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGroup(Eluna::get()->LuaState, group);
+            Eluna::get()->PushGUID(Eluna::get()->LuaState, guid);
+            Eluna::get()->PushInteger(Eluna::get()->LuaState, method);
+            Eluna::get()->PushGUID(Eluna::get()->LuaState, kicker);
+            Eluna::get()->PushString(Eluna::get()->LuaState, reason);
+            Eluna::get()->ExecuteCall(6, 0);
+        }
+    }
+
+    void OnGroupChangeLeader(uint32 eventId, Group* group, uint64 newLeaderGuid, uint64 oldLeaderGuid)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGroup(Eluna::get()->LuaState, group);
+            Eluna::get()->PushGUID(Eluna::get()->LuaState, newLeaderGuid);
+            Eluna::get()->PushGUID(Eluna::get()->LuaState, oldLeaderGuid);
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+    }
+
+    void OnGroupDisband(uint32 eventId, Group* group)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushGroup(Eluna::get()->LuaState, group);
+            Eluna::get()->ExecuteCall(2, 0);
+        }
+    }
+
+    void OnWeatherChange(uint32 eventId, Weather* weather, WeatherState state, float grade)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, (weather->GetZone()));
+            Eluna::get()->PushInteger(Eluna::get()->LuaState, state);
+            Eluna::get()->PushFloat(Eluna::get()->LuaState, grade);
+            Eluna::get()->ExecuteCall(4, 0);
+        }
+    }
+
+    bool OnAreaTrigger(uint32 eventId, Player* player, AreaTriggerEntry const* trigger)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->PushUnit(Eluna::get()->LuaState, player);
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, trigger->id);
+            Eluna::get()->ExecuteCall(3, 0);
+        }
+        return false;
+    }
+
+    void OnElunaRestart(uint32 eventId)
+    {
+        for (vector<int>::iterator itr = Eluna::get()->ServerEventBindings.at(eventId).begin();
+            itr != Eluna::get()->ServerEventBindings.at(eventId).end(); ++itr)
+        {
+            Eluna::get()->BeginCall((*itr));
+            Eluna::get()->PushUnsigned(Eluna::get()->LuaState, eventId);
+            Eluna::get()->ExecuteCall(1, 0);
+        }
+    }
+};
+#endif
\ No newline at end of file
diff --git a/src/server/LuaEngine/LuaFunctions.h b/src/server/LuaEngine/LuaFunctions.h
new file mode 100644
index 0000000..82bf2f9
--- /dev/null
+++ b/src/server/LuaEngine/LuaFunctions.h
@@ -0,0 +1,507 @@
+#ifndef FUNCTION_TABLES_H
+#define FUNCTION_TABLES_H
+
+ElunaRegister<Unit> UnitMethods[] =
+{
+    // Player Methods
+    // Getters
+    {"GetSelection", &LuaUnit::GetSelection},                       // :GetSelection()
+    {"GetGMRank", &LuaUnit::GetSecurity},                           // :GetSecurity()
+    {"GetGuildID", &LuaUnit::GetGuildID},                           // :GetGuildID() - nil on no guild.
+    {"GetCoinage", &LuaUnit::GetCoinage},                           // :GetCoinage()
+    {"GetTeam", &LuaUnit::GetTeam},                                 // :GetTeam() - returns the player's team. 0 for ally, 1 for horde
+    {"GetItemCount", &LuaUnit::GetItemCount},                       // :GetItemCount(item_id)
+    {"GetGroup", &LuaUnit::GetGroup},                               // :GetGroup()
+    {"GetGuild", &LuaUnit::GetGuild},                               // :GetGuild()
+    {"GetGearLevel", &LuaUnit::GetGearLevel},                       // :GetGearLevel() -- Returns the player's average gear level
+    {"GetAccountId", &LuaUnit::GetAccountId},                       // :GetAccountId()
+    {"GetAccountName", &LuaUnit::GetAccountName},                   // :GetAccountName()
+    {"GetArenaPoints", &LuaUnit::GetArenaPoints},                   // :GetArenaPoints()
+    {"GetHonorPoints", &LuaUnit::GetHonorPoints},                   // :GetHonorPoints()
+
+    // Setters
+    {"SetCoinage", &LuaUnit::SetCoinage},                           // :SetCoinage(amount) - sets plr's coinage to this.
+    {"SetKnownTitle", &LuaUnit::SetKnownTitle},                     // :SetKnownTitle(id)
+    {"UnsetKnownTitle", &LuaUnit::UnsetKnownTitle},                 // :UnsetKnownTitle(id)
+    {"AdvanceSkillsToMax", &LuaUnit::AdvanceSkillsToMax},           // :AdvanceSkillsToMax() -- Advances all currently known skills to the currently known max level
+    {"AdvanceSkill", &LuaUnit::AdvanceSkill},                       // AdvanceSkill(skill_id, step) -- Advances skill by ID and the amount(step)
+    {"AdvanceAllSkills", &LuaUnit::AdvanceAllSkills},               // AdvanceAllSkills(value) -- Advances all current skills to your input(value)
+    {"SetBindPoint", &LuaUnit::SetBindPoint},                       // :SetBindPoint(x, y, z, map, areaid) -- sets home for hearthstone
+    {"SetBindPointAtPlayerLoc", &LuaUnit::SetBindPointAtPlayerLoc}, // :SetBindPointAtPlayerLoc() -- Set's home for hearthstone at player's location
+    {"SetArenaPoints", &LuaUnit::SetArenaPoints},                   // :SetArenaPoints(amount)
+    {"SetHonorPoints", &LuaUnit::SetHonorPoints},                   // :SetHonorPoints(amount)
+
+    // Boolean
+    {"IsInGroup", &LuaUnit::IsInGroup},                             // :IsInGroup()
+    {"IsInGuild", &LuaUnit::IsInGuild},                             // :IsInGuild()
+    {"IsGM", &LuaUnit::IsGM},                                       // :IsGM()
+    {"IsAlliance", &LuaUnit::IsAlliance},                           // :IsAlliance()
+    {"IsHorde", &LuaUnit::IsHorde},                                 // :IsHorde()
+    {"HasTitle", &LuaUnit::HasTitle},                               // :HasTitle(id)
+    {"Teleport", &LuaUnit::Teleport},                               // :Teleport(Map, X, Y, Z, O) - Teleports player to specified co-ordinates. Returns true if success and false if not.
+    {"AddItem", &LuaUnit::AddItem},                                 // :AddItem(id, amount) - Adds amount of item to player. Returns true if success and false if not.
+    {"IsInArenaTeam", &LuaUnit::IsInArenaTeam},                     // :IsInArenaTeam(type) -  type : 0 = 2v2, 1 = 3v3, 2 = 5v5
+
+    // Gossip                                                           
+    {"GossipMenuAddItem", &LuaUnit::GossipMenuAddItem},             // :GossipMenuAddItem(icon, msg, sender, intid, code, popup, money)
+    {"GossipSendMenu", &LuaUnit::GossipSendMenu},                   // :GossipSendMenu(npc_text, unit[, menu_id]) -- If unit is a player, you need to use a menu_id. menu_id is used to hook the gossip select function to the menu.
+    {"GossipComplete", &LuaUnit::GossipComplete},                   // :GossipComplete()
+    {"GossipClearMenu", &LuaUnit::GossipClearMenu},                 // :GossipClearMenu() -- Clears the gossip menu of options. Pretty much only useful with player gossip. Need to use before creating a new menu for the player
+
+    // Update
+
+    // Other
+    {"SendBroadcastMessage", &LuaUnit::SendBroadcastMessage},       // :SendBroadcastMessage(message)
+    {"SendAreaTriggerMessage", &LuaUnit::SendAreaTriggerMessage},   // :SendAreaTriggerMessage(message) -- Sends a yellow message in the middle of your screen
+    {"SendNotification", &LuaUnit::SendNotification},               // :SendNotification(message) -- Sends a red message in the middle of your screen
+    {"SendPacketToPlayer", &LuaUnit::SendPacketToPlayer},           // :SendPacketToPlayer(packet) - Sends a specified packet to the player
+    {"SendPacket", &LuaUnit::SendPacket},                           // :SendPacket(packet) -- Sends a specified packet
+    {"SendPacketToGroup", &LuaUnit::SendPacketToGroup},             // :SendPacketToGroup(packet, sendToPlayersInBattleground(bool)) - Sends a specified packet to the group with the choice (true/false) to send it to players in a battleground
+    {"SendPacketToGuild", &LuaUnit::SendPacketToGuild},             // :SendPacketToGuild(packet) - Sends a specified packet to your guild
+    {"SendPacketToRankedInGuild", &LuaUnit::SendPacketToRankedInGuild}, // :SendPacketToRankedInGuild(packet, rankId) - Sends a specified packet to your guild, specifying a rankId will only send the packet to your ranked members.
+	{"SendVendorWindow", &LuaUnit::SendVendorWindow},               // :SendVendorWindow(unit) -- Sends the unit's vendor window to the player
+	{"GiveCoinage", &LuaUnit::GiveCoinage},                         // :GiveCoinage(amount) - MODIFIES (does not set) coinage count.
+    {"RemoveCoinage", &LuaUnit::RemoveCoinage},                     // :RemoveCoinage(amount) - Removes amount of coinage from plr.
+    {"LearnSpell", &LuaUnit::LearnSpell},                           // :LearnSpell(id) - learns the given spell.
+    {"RemoveItem", &LuaUnit::RemoveItem},                           // :RemoveItem(id, amount) - Removes amount of item to player.
+    {"ResurrectPlayer", &LuaUnit::ResurrectPlayer},                 // :ResurrectPlayer([percent[, sickness(bool)]]) - Resurrects the player at percentage, player gets resurrection sickness if sickness set to true.
+    {"PlaySoundToPlayer", &LuaUnit::PlaySoundToPlayer},             // :PlaySoundToPlayer(soundId) - Plays the specified sound to the player
+
+    // Creature methods
+
+    // Getters
+    {"GetAITargets", &LuaUnit::GetAITargets},                       // :GetAITargets() - Get units in threat list
+    {"GetAITargetsCount", &LuaUnit::GetAITargetsCount},             // :GetAITargetsCount() - Get threat list size
+
+    // Other
+    {"RegisterEvent", &LuaUnit::RegisterEvent},                     // :RegisterEvent(function, delay, calls)
+    {"RemoveEventByID", &LuaUnit::RemoveEventByID},                 // :RemoveEventByID(eventID)
+    {"RemoveEvents", &LuaUnit::RemoveEvents},                       // :RemoveEvents()
+    {"Despawn", &LuaUnit::Despawn},                                 // :Despawn([despawnDelay]) - Creature despawns after given time UNDOCUMENTED
+
+    // Unit Methods
+
+    // Getters
+    {"GetName", &LuaUnit::GetName},                                 // :GetName()
+    {"GetLevel", &LuaUnit::GetLevel},                               // :GetLevel()
+    {"GetHealth", &LuaUnit::GetHealth},                             // :GetHealth()
+    {"GetDisplayID", &LuaUnit::GetDisplayID},                       // :GetDisplayID()
+    {"GetGUID", &LuaUnit::GetGUID},                                 // :GetGUID()
+    {"GetMapId", &LuaUnit::GetMapId},                               // :GetMapId()
+    {"GetX", &LuaUnit::GetX},                                       // :GetX()
+    {"GetY", &LuaUnit::GetY},                                       // :GetY()
+    {"GetZ", &LuaUnit::GetZ},                                       // :GetZ()
+    {"GetO", &LuaUnit::GetO},                                       // :GetO()
+    {"GetLocation", &LuaUnit::GetLocation},                         // :GetLocation() - returns X, Y, Z and O co-ords (in that order)
+    {"GetAreaId", &LuaUnit::GetAreaId},                             // :GetAreaId()
+    {"GetZoneId", &LuaUnit::GetZoneId},                             // :GetZoneId()
+    {"GetPower", &LuaUnit::GetPower},                               // :GetPower(index) - returns power at index. Index can be omitted.
+    {"GetMaxPower", &LuaUnit::GetMaxPower},                         // :GetMaxPower(index) - returns power at index. Index can be omitted.
+    {"GetPowerType", &LuaUnit::GetPowerType},                       // :GetPowerType() - Returns the power type.
+    {"GetMaxHealth", &LuaUnit::GetMaxHealth},                       // :GetMaxHealth()
+    {"GetHealthPct", &LuaUnit::GetHealthPct},                       // :GetHealthPct()
+    {"GetPowerPct", &LuaUnit::GetPowerPct},                         // :GetPowerPct(power_id)
+    {"GetGender", &LuaUnit::GetGender},                             // :GetGender() - returns the gender where male = 0 female = 1
+    {"GetRace", &LuaUnit::GetRace},                                 // :GetRace()
+    {"GetClass", &LuaUnit::GetClass},                               // :GetClass()
+    {"GetClassAsString", &LuaUnit::GetClassAsString},               // :GetClassAsString()
+    {"GetUnitType", &LuaUnit::GetUnitType},                         // :GetUnitType() - Returns object type, IE: Player, Creature
+    {"GetEntry", &LuaUnit::GetEntry},                               // :GetEntry() - Returns the unit's entryId
+    {"GetAura", &LuaUnit::GetAura},                                 // :GetAura(spellID) - returns aura object
+    {"GetInt32Value", &LuaUnit::GetInt32Value},                     // :GetInt32Value(index) - returns an int value from unit fields
+    {"GetUInt32Value", &LuaUnit::GetUInt32Value},                   // :GetUInt32Value(index) - returns an uint value from unit fields
+    {"GetFloatValue", &LuaUnit::GetFloatValue},                     // :GetFloatValue(index) - returns a float value from unit fields
+    {"GetByteValue", &LuaUnit::GetByteValue},                       // :GetByteValue(index, offset) - returns a byte value from unit fields
+    {"GetUInt16Value", &LuaUnit::GetUInt16Value},                   // :GetUInt16Value(index, offset) - returns a uint16 value from unit fields
+    {"GetInstanceId", &LuaUnit::GetInstanceId},                     // :GetInstanceId() - Gets the instance id of the unit
+    {"GetPhaseMask", &LuaUnit::GetPhaseMask},                       // :GetPhaseMask() - gets the phase mask of the unit
+
+    // Setters
+    {"SetLevel", &LuaUnit::SetLevel},                               // :SetLevel(amount)
+    {"SetHealth", &LuaUnit::SetHealth},                             // :SetHealth(amount)
+    {"SetMaxHealth", &LuaUnit::SetMaxHealth},                       // :SetMaxHealth(amount)
+    {"SetPower", &LuaUnit::SetPower},                               // :SetPower(index, amount)
+    {"SetMaxPower", &LuaUnit::SetMaxPower},                         // :SetMaxPower(index, amount)
+    {"SetDisplayID", &LuaUnit::SetDisplayID},                       // :SetDisplayID(id)
+    {"SetFacing", &LuaUnit::SetFacing},                             // :SetFacing(o) -- Sets the Unit facing to arg
+    {"SetDeathState", &LuaUnit::SetDeathState},                     // :SetDeathState(value) -- 0 = alive 1 = just died 2 = corpse 3 = dead
+    {"SetInt32Value", &LuaUnit::SetInt32Value},                     // :SetInt32Value(index, value) - Sets an int value for the unit
+    {"SetUInt32Value", &LuaUnit::SetUInt32Value},                   // :SetUInt32Value(index, value) - Sets an uint value for the unit
+    {"UpdateUInt32Value", &LuaUnit::UpdateUInt32Value},             // :UpdateUInt32Value(index, value) - Updates an uint value for the unit
+    {"SetFloatValue", &LuaUnit::SetFloatValue},                     // :SetFloatValue(index, value) - Sets a float value for the unit
+    {"SetByteValue", &LuaUnit::SetByteValue},                       // :SetByteValue(index, offset, value) - Sets a byte value for the unit
+    {"SetUInt16Value", &LuaUnit::SetUInt16Value},                   // :SetUInt16Value(index, offset, value) - Sets an uint16 value for the unit
+    {"SetInt16Value", &LuaUnit::SetInt16Value},                     // :SetInt16Value(index, offset, value) - Sets an int16 value for the unit
+    {"SetPhaseMask", &LuaUnit::SetPhaseMask},                       // :SetPhaseMask(Phase[, update]) - Sets the phase of the unit
+    {"SetWalk", &LuaUnit::SetWalk},                                 // :SetWalk(enable) - If false, creature runs, otherwise walks
+    {"SetSpeed", &LuaUnit::SetSpeed},                               // :SetSpeed(type, speed[, forced]) - Sets speed for the movement type (0 = walk, 1 = run ..)
+    {"SetStunned", &LuaUnit::SetStunned},                           // :SetStunned(enable) - Stuns or removes stun
+    {"SetRooted", &LuaUnit::SetRooted},                             // :SetRooted(enable) - Roots or removes root
+    {"SetConfused", &LuaUnit::SetConfused},                         // :SetConfused(enable) - Sets confused or removes confusion
+    {"SetFeared", &LuaUnit::SetFeared},                             // :SetFeared(enable) - Fears or removes fear
+
+    // Boolean
+    {"IsAlive", &LuaUnit::IsAlive},                                 // :IsAlive()
+    {"IsInWorld", &LuaUnit::IsInWorld},                             // :IsInWorld()
+    {"IsPvPFlagged", &LuaUnit::IsPvPFlagged},                       // :IsPvPFlagged()
+    {"HasQuest", &LuaUnit::HasQuest},                               // :HasQuest(id)
+    {"IsInCombat", &LuaUnit::IsInCombat},                           // :IsInCombat()
+    {"HasSpell", &LuaUnit::HasSpell},                               // :HasSpell(id)
+
+    // Other
+    {"DeMorph", &LuaUnit::DeMorph},                                 // :DeMorph() - Sets display back to native.
+    {"SendUnitWhisper", &LuaUnit::SendUnitWhisper},                 // :SendUnitWhisper(msg, unit) -- Sends a whisper to the receiver
+    {"SendUnitSay", &LuaUnit::SendUnitSay},                         // :SendUnitSay(msg, language) -- Sends a "Say" message with the specified language (all languages: 0)
+    {"SendUnitYell", &LuaUnit::SendUnitYell},                       // :SendUnitYell(msg, language) -- Sends a "Yell" message with the specified language (all languages: 0)
+    {"CastSpell", &LuaUnit::CastSpell},                             // :CastSpell(spellID) - Casts the spell on self, no manacost or cast time
+    {"CastSpellOnTarget", &LuaUnit::CastSpellOnTarget},             // :CastSpellOnTarget(spellID, unit) - Casts the spell on target, no manacost or cast time
+    {"CastSpellAoF", &LuaUnit::CastSpellAoF},                       // :CastSpellAoF(x, y, z, SpellID, triggered) - Casts the spell on coordinates, if triggered is false has manacost and cast time
+    {"FullCastSpell", &LuaUnit::FullCastSpell},                     // :FullCastSpell(spellID) - Casts the spell on self
+    {"FullCastSpellOnTarget", &LuaUnit::FullCastSpellOnTarget},     // :FullCastSpellOnTarget(spellID, unit) - Casts the spell on target
+    {"PlayDirectSound", &LuaUnit::PlayDirectSound},                 // :PlayDirectSound(soundId,  player) - Unit plays soundID to player, or everyone around if no player.
+    {"PlayDistanceSound", &LuaUnit::PlayDistanceSound},             // :PlayDistanceSound(soundId,  player) - Unit plays soundID to player, or everyone around if no player. The sound fades the further you are
+    {"PlaySoundToSet", &LuaUnit::PlayDirectSound},                  // :PlaySoundToSet(soundId, player) - Unit plays soundID to player, or everyone around if no player. (ARC compability)
+    {"Kill", &LuaUnit::Kill},                                       // :Kill(target, durabilityLoss) - Unit kills the target, if no target then kills the unit. Durabilityloss is true by default
+    {"KnockbackFrom", &LuaUnit::KnockbackFrom},                     // :KnockbackFrom(x, y, speedXY, speedZ) - Knocks the player to the opposite direction from x,y at the defined speeds
+    {"JumpTo", &LuaUnit::JumpTo},                                   // :JumpTo(WorldObj, speedZ) - Unit jumps to world object
+    {"Jump", &LuaUnit::Jump},                                       // :Jump(speedXY, speedZ[, forward]) - Unit jumps at given speeds
+    {"JumpToCoords", &LuaUnit::JumpToCoords},                       // :JumpToCoords(x, y, z, speedXY, speedZ) - Unit jumps to coordinates at given speeds
+    {"MoveTo", &LuaUnit::MovePoint},                                // :MoveTo(id, x, y, z[, generatePath]) - Unit moves to point. ID is sent to WP reach hook
+    {"MoveCharge", &LuaUnit::MoveCharge},                           // :MoveCharge(x, y, z, speed) - Charges to target location
+    {"MoveChase", &LuaUnit::MoveChase},                             // :MoveChase(target[, dist, angle]) - Chases target unit
+    {"MoveFollow", &LuaUnit::MoveFollow},                           // :MoveFollow(target, dist, angle) - Follows target unit
+    {"MoveClear", &LuaUnit::MoveClear},                             // :MoveClear() - Stops movement
+    {"MoveRandom", &LuaUnit::MoveRandom},                           // :MoveRandom() - Moves randomly inside radius
+    {"MoveRotate", &LuaUnit::MoveRotate},                           // :MoveRotate(time, left) - Turns left (true or nil) or right (false) for given time
+    {"SummonGameObject", &LuaUnit::SummonGameObject},               // :SummonGameObject(entry, x, y, z, o[, respawnDelay]) - Spawns an object to location. Returns the object or nil UNDOCUMENTED
+    {"SpawnCreature", &LuaUnit::SpawnCreature},                     // :SpawnCreature(entry, x, y, z, o[, despawnDelay]) - Spawns a creature to location that despawns after given time (0 for infinite). Returns the creature or nil UNDOCUMENTED
+
+    /* Vehicle */
+    {"AddVehiclePassenger", &LuaUnit::AddVehiclePassenger},         // :AddVehiclePassenger(unit, seatId) - Adds a passenger to the vehicle by specifying a unit and seatId
+    {"IsOnVehicle", &LuaUnit::IsOnVehicle},                         // :IsOnVehicle() - Checks if the (unit) is in a vehicle
+    {"DismissVehicle", &LuaUnit::DismissVehicle},                   // :DismissVehicle() - Dismisses the (unit)'s vehicle (Unmounts)
+    //{"EjectPassenger", &LuaUnit::EjectPassenger},                   // :EjectPassenger(unit) - Ejects a specified unit out of the vehicle   UNDOCUMENTED (UNTESTED)
+    {"RemovePassenger", &LuaUnit::RemovePassenger},                 // :RemovePassenger(unit) - Removes a specific unit from the vehicle
+    {"RemoveAllPassengers", &LuaUnit::RemoveAllPassengers},         // :RemoveAllPassengers() - Removes all the passengers from the vehicle
+    {"GetPassenger", &LuaUnit::GetPassenger},                       // :GetPassenger(seatId) - Gets a passenger by their seatId
+    {"GetNextEmptySeat", &LuaUnit::GetNextEmptySeat},               // :GetNextEmptySeat(seatId) - Gets(returns) the next empty seat
+    {"GetAvailableSeats", &LuaUnit::GetAvailableSeats},             // :GetAvailableSeats() - Returns the available seats count
+    {"GetVehicleBase", &LuaUnit::GetVehicleBase},                   // :GetVehicleBase() - Returns the unit's vehicle base
+    {"HasEmptySeat", &LuaUnit::HasEmptySeat},                       // :HasEmptySeat(seatId) - Checks if the specified seatId is empty(nobody in it)
+    { NULL, NULL },
+};
+
+ElunaRegister<GameObject> GameObjectMethods[] =
+{
+    // Getters
+    {"GetUnitType", &LuaGameObject::GetUnitType},                   // :GetUnitType() - Returns unit type Ex. GameObject UNDOCUMENTED
+    {"GetGUID", &LuaGameObject::GetGUID},                           // :GetGUID() - returns object guid UNDOCUMENTED
+    {"GetName", &LuaGameObject::GetName},                           // :GetName() - UNDOCUMENTED
+    {"GetDisplayId", &LuaGameObject::GetDisplayId},                 // :GetDisplayId() - UNDOCUMENTED
+    {"GetScale", &LuaGameObject::GetScale},                         // :GetScale() - UNDOCUMENTED
+    {"GetEntry", &LuaGameObject::GetEntry},                         // :GetEntry() - UNDOCUMENTED
+    {"GetMapId", &LuaGameObject::GetMapId},                         // :GetMapId() - UNDOCUMENTED
+    {"GetX", &LuaGameObject::GetX},                                 // :GetX() - UNDOCUMENTED
+    {"GetY", &LuaGameObject::GetY},                                 // :GetY() - UNDOCUMENTED
+    {"GetZ", &LuaGameObject::GetZ},                                 // :GetZ() - UNDOCUMENTED
+    {"GetO", &LuaGameObject::GetO},                                 // :GetO() - UNDOCUMENTED
+    {"GetLocation", &LuaGameObject::GetLocation},                   // :GetLocation() - returns X, Y, Z and O co-ords (in that order) - UNDOCUMENTED
+    {"GetAreaId", &LuaGameObject::GetAreaId},                       // :GetAreaId() - UNDOCUMENTED
+    {"GetZoneId", &LuaGameObject::GetZoneId},                       // :GetZoneId() - UNDOCUMENTED
+    {"GetInt32Value", &LuaGameObject::GetInt32Value},               // :GetInt32Value(index) - returns an int value from object fields UNDOCUMENTED
+    {"GetUInt32Value", &LuaGameObject::GetUInt32Value},             // :GetUInt32Value(index) - returns an uint value from object fields UNDOCUMENTED
+    {"GetFloatValue", &LuaGameObject::GetFloatValue},               // :GetFloatValue(index) - returns a float value from object fields UNDOCUMENTED
+    {"GetByteValue", &LuaGameObject::GetByteValue},                 // :GetByteValue(index, offset) - returns a byte value from object fields UNDOCUMENTED
+    {"GetUInt16Value", &LuaGameObject::GetUInt16Value},             // :GetUInt16Value(index, offset) - returns a uint16 value from object fields UNDOCUMENTED
+
+    // Setters
+    {"SetScale", &LuaGameObject::SetScale},                         // :SetScale(scale) - UNDOCUMENTED
+    {"SetInt32Value", &LuaGameObject::SetInt32Value},               // :SetInt32Value(index, value) - Sets an int value for the object UNDOCUMENTED
+    {"SetUInt32Value", &LuaGameObject::SetUInt32Value},             // :SetUInt32Value(index, value) - Sets an uint value for the object UNDOCUMENTED
+    {"UpdateUInt32Value", &LuaGameObject::UpdateUInt32Value},       // :UpdateUInt32Value(index, value) - Updates an uint value for the object UNDOCUMENTED
+    {"SetFloatValue", &LuaGameObject::SetFloatValue},               // :SetFloatValue(index, value) - Sets a float value for the object UNDOCUMENTED
+    {"SetByteValue", &LuaGameObject::SetByteValue},                 // :SetByteValue(index, offset, value) - Sets a byte value for the object UNDOCUMENTED
+    {"SetUInt16Value", &LuaGameObject::SetUInt16Value},             // :SetUInt16Value(index, offset, value) - Sets an uint16 value for the object UNDOCUMENTED
+    {"SetInt16Value", &LuaGameObject::SetInt16Value},               // :SetInt16Value(index, offset, value) - Sets an int16 value for the object UNDOCUMENTED
+
+    // Boolean
+    {"IsInWorld", &LuaGameObject::IsInWorld},                       // :IsInWorld() - UNDOCUMENTED
+    {"IsTransport", &LuaGameObject::IsTransport},                   // :IsTransport() - UNDOCUMENTED
+    {"IsDestructible", &LuaGameObject::IsDestructible},             // :IsDestructible() - UNDOCUMENTED
+    {"IsActive", &LuaGameObject::IsActive},                         // :IsActive() - UNDOCUMENTED
+    {"HasQuest", &LuaGameObject::HasQuest},                         // :HasQuest(questId) - UNDOCUMENTED
+
+    // Other
+    {"CastSpellOnTarget", &LuaGameObject::CastSpellOnTarget},       // :CastSpellOnTarget(target, spellId) - Casts the spell on target, no manacost or cast time - UNDOCUMENTED
+    {"Move", &LuaGameObject::Move},                                 // :Move(x, y, z, o) - Moves the GO to coordinates - UNDOCUMENTED
+    {"SpawnCreature", &LuaGameObject::SummonCreature},              // :SummonCreature(entry, x, y, z, o, despawntime) Summons a temporary creature. 0 for infinitely, otherwise despawns after despawntime (ms) - UNDOCUMENTED
+    {"RegisterEvent", &LuaGameObject::RegisterEvent},               // :RegisterEvent(function, delay, calls) - UNDOCUMENTED
+    {"RemoveEventByID", &LuaGameObject::RemoveEventByID},           // :RemoveEventByID(eventID) - UNDOCUMENTED
+    {"RemoveEvents", &LuaGameObject::RemoveEvents},                 // :RemoveEvents() - UNDOCUMENTED
+    {"Despawn", &LuaGameObject::Despawn},                           // :Despawn() - Object despawns UNDOCUMENTED
+    {"SummonGameObject", &LuaGameObject::SummonGameObject},         // :SummonGameObject(entry, x, y, z, o[, respawnDelay]) - Spawns an object to location. Returns the object or nil UNDOCUMENTED
+
+    { NULL, NULL },
+};
+
+ElunaRegister<Item> ItemMethods[] = 
+{
+    // Getters
+    {"GetUnitType", &LuaItem::GetUnitType},                                 // :GetUnitType() - Returns object type, IE: Item, Creature UNDOCUMENTED
+    {"GetGUID", &LuaItem::GetGUID},                                         // :GetGUID() - Returns object guid UNDOCUMENTED
+    {"GetOwnerGUID", &LuaItem::GetOwnerGUID},                               // :GetOwnerGUID() - Returns the owner's guid UNDOCUMENTED
+    {"GetOwner", &LuaItem::GetOwner},                                       // :GetOwner() - Returns the owner object (player) UNDOCUMENTED
+    {"GetCount", &LuaItem::GetCount},                                       // :GetCount() - Returns item stack count UNDOCUMENTED
+    {"GetMaxStackCount", &LuaItem::GetMaxStackCount},                       // :GetMaxStackCount() - Returns item max stack count RUNDOCUMENTED
+    {"GetSlot", &LuaItem::GetSlot},                                         // :GetSlot() - returns the slot the item is in UNDOCUMENTED
+    {"GetBagSlot", &LuaItem::GetBagSlot},                                   // :GetBagSlot() - returns the bagslot the item is in UNDOCUMENTED
+    {"GetEntry", &LuaItem::GetEntry},                                       // :GetEntry() - returns the item entry UNDOCUMENTED
+    {"GetInt32Value", &LuaItem::GetInt32Value},                             // :GetInt32Value(index) - returns an int value from item fields UNDOCUMENTED
+    {"GetUInt32Value", &LuaItem::GetUInt32Value},                           // :GetUInt32Value(index) - returns an uint value from item fields UNDOCUMENTED
+    {"GetFloatValue", &LuaItem::GetFloatValue},                             // :GetFloatValue(index) - returns a float value from item fields UNDOCUMENTED
+    {"GetByteValue", &LuaItem::GetByteValue},                               // :GetByteValue(index, offset) - returns a byte value from item fields UNDOCUMENTED
+    {"GetUInt16Value", &LuaItem::GetUInt16Value},                           // :GetUInt16Value(index, offset) - returns a uint16 value from item fields UNDOCUMENTED
+
+    // Setters
+    {"SetOwner", &LuaItem::SetOwner},                                       // :SetOwner(player) - Sets the owner of the item UNDOCUMENTED
+    {"SetBinding", &LuaItem::SetBinding},                                   // :SetBinding(bound) - Sets the item binding to true or false UNDOCUMENTED
+    {"SetCount", &LuaItem::SetCount},                                       // :SetCount(count) - Sets the item count UNDOCUMENTED
+    {"SetInt32Value", &LuaItem::SetInt32Value},                             // :SetInt32Value(index, value) - Sets an int value for the item UNDOCUMENTED
+    {"SetUInt32Value", &LuaItem::SetUInt32Value},                           // :SetUInt32Value(index, value) - Sets an uint value for the item UNDOCUMENTED
+    {"UpdateUInt32Value", &LuaItem::UpdateUInt32Value},                     // :UpdateUInt32Value(index, value) - Updates an uint value for the item UNDOCUMENTED
+    {"SetFloatValue", &LuaItem::SetFloatValue},                             // :SetFloatValue(index, value) - Sets a float value for the item UNDOCUMENTED
+    {"SetByteValue", &LuaItem::SetByteValue},                               // :SetByteValue(index, offset, value) - Sets a byte value for the item UNDOCUMENTED
+    {"SetUInt16Value", &LuaItem::SetUInt16Value},                           // :SetUInt16Value(index, offset, value) - Sets an uint16 value for the item UNDOCUMENTED
+    {"SetInt16Value", &LuaItem::SetInt16Value},                             // :SetInt16Value(index, offset, value) - Sets an int16 value for the item UNDOCUMENTED
+
+    // Boolean
+    {"IsSoulBound", &LuaItem::IsSoulBound},                                 // :IsSoulBound() - Returns true if the item is soulbound UNDOCUMENTED
+    {"IsBoundAccountWide", &LuaItem::IsBoundAccountWide},                   // :IsBoundAccountWide() - Returns true if the item is account bound UNDOCUMENTED
+    {"IsBoundByEnchant", &LuaItem::IsBoundByEnchant},                       // :IsBoundByEnchant() - Returns true if the item is bound with an enchant UNDOCUMENTED
+    {"IsBindedNotWith", &LuaItem::IsBindedNotWith},                         // :IsBindedNotWith(player) - Returns true if the item is not bound with player UNDOCUMENTED
+    {"IsLocked", &LuaItem::IsBindedNotWith},                                // :IsLocked() - Returns true if the item is locked UNDOCUMENTED
+    {"IsBag", &LuaItem::IsBag},                                             // :IsBag() - Returns true if the item is a bag UNDOCUMENTED
+    {"IsCurrencyToken", &LuaItem::IsCurrencyToken},                         // :IsCurrencyToken() - Returns true if the item is a currency token UNDOCUMENTED
+    {"IsNotEmptyBag", &LuaItem::IsNotEmptyBag},                             // :IsNotEmptyBag() - Returns true if the item is not an empty bag UNDOCUMENTED
+    {"IsBroken", &LuaItem::IsBroken},                                       // :IsBroken() - Returns true if the item is broken UNDOCUMENTED
+    {"CanBeTraded", &LuaItem::CanBeTraded},                                 // :CanBeTraded() - Returns true if the item can be traded UNDOCUMENTED
+    {"IsInTrade", &LuaItem::IsInTrade},                                     // :IsInTrade() - Returns true if the item is in trade UNDOCUMENTED
+    {"IsInBag", &LuaItem::IsInBag},                                         // :IsInBag() - Returns true if the item is in a bag UNDOCUMENTED
+    {"IsEquipped", &LuaItem::IsEquipped},                                   // :IsEquipped() - Returns true if the item is equipped UNDOCUMENTED
+    {"hasQuest", &LuaItem::hasQuest},                                       // :hasQuest(questId) - Returns true if the item starts the quest UNDOCUMENTED
+    {"IsPotion", &LuaItem::IsPotion},                                       // :IsPotion() - Returns true if the item is a potion UNDOCUMENTED
+    {"IsWeaponVellum", &LuaItem::IsWeaponVellum},                           // :IsWeaponVellum() - Returns true if the item is a weapon vellum UNDOCUMENTED
+    {"IsArmorVellum", &LuaItem::IsArmorVellum},                             // :IsArmorVellum() - Returns true if the item is an armor vellum UNDOCUMENTED
+    {"IsConjuredConsumable", &LuaItem::IsConjuredConsumable},               // :IsConjuredConsumable() - Returns true if the item is a conjured consumable UNDOCUMENTED
+    {"IsRefundExpired", &LuaItem::IsRefundExpired},                         // :IsRefundExpired() - Returns true if the item's refund time has expired UNDOCUMENTED
+    {"SetEnchantment", &LuaItem::SetEnchantment},                           // :SetEnchantment(enchantid) - Sets a new enchantment for the item. Returns true on success. UNDOCUMENTED
+    {"ClearEnchantment", &LuaItem::ClearEnchantment},                       // :ClearEnchantment() - Removes the enchantment from the item if one exists. Returns true on success. UNDOCUMENTED
+
+    // Other
+
+    {NULL, NULL},
+};
+
+ElunaRegister<Aura> AuraMethods[] = 
+{
+    // Getters
+    {"GetUnitType", &LuaAura::GetUnitType},                         // :GetUnitType() - Returns object type, IE: Aura, Creature  UNDOCUMENTED
+    {"GetCaster", &LuaAura::GetCaster},                             // :GetCaster() - Returns caster as object.					 UNDOCUMENTED
+    {"GetCasterGUID", &LuaAura::GetCasterGUID},                     // :GetCasterGUID() - Returns caster as GUID.				 UNDOCUMENTED
+    {"GetCasterLevel", &LuaAura::GetCasterLevel},                   // :GetCasterLevel() - Returns casters level.				 UNDOCUMENTED
+    {"GetDuration", &LuaAura::GetDuration},                         // :GetDuration() - Returns remaining duration.				 UNDOCUMENTED
+    {"GetMaxDuration", &LuaAura::GetMaxDuration},                   // :GetMaxDuration() - Returns maximum duration.		     UNDOCUMENTED
+    {"GetCharges", &LuaAura::GetCharges},                           // :GetCharges() - Returns remaining charges.                UNDOCUMENTED
+    {"GetAuraId", &LuaAura::GetAuraId},                             // :GetAuraId() - Returns aura ID.							 UNDOCUMENTED
+    {"GetStackAmount", &LuaAura::GetStackAmount},                   // :GetStackAmount() - Returns current stack amount.         UNDOCUMENTED
+    {"GetOwner", &LuaAura::GetOwner},                               // :GetOwner() - Gets the unit wearing the aura              UNDOCUMENTED
+
+    // Setters
+    {"SetDuration", &LuaAura::SetDuration},                         // :SetDuration(duration) - Sets remaining duration.         UNDOCUMENTED
+    {"SetMaxDuration", &LuaAura::SetMaxDuration},                   // :SetMaxDuration(duration) - Sets maximum duration.        UNDOCUMENTED
+    {"SetStackAmount", &LuaAura::SetStackAmount},                   // :SetStackAmount(amount) - Sets current stack amount.      UNDOCUMENTED
+
+    // Other
+    {"Remove", &LuaAura::Remove},                                   // :Remove() - Removes the aura.                             UNDOCUMENTED
+
+    {NULL, NULL},
+};
+
+ElunaRegister<Spell> SpellMethods[] =
+{
+	// Getters
+	{"GetUnitType", &LuaSpell::GetUnitType},                        // :GetUnitType() -- Returns the unit type (Spell)              UNDOCUMENTED
+	{"GetCaster", &LuaSpell::GetCaster},                            // :GetCaster()  -- Returns the spell's caster (UNIT)           UNDOCUMENTED
+	{"GetCastTime", &LuaSpell::GetCastTime},                        // :GetCastTime() -- Returns the spell cast time                UNDOCUMENTED
+	{"GetId", &LuaSpell::GetId},                                    // :GetId() -- Returns the spell's ID                           UNDOCUMENTED
+	{"GetDuration", &LuaSpell::GetDuration},                        // :GetDuration() -- Returns the spell's duration               UNDOCUMENTED
+	{"GetPowerCost", &LuaSpell::GetPowerCost},                      // :GetPowerCost() -- Returns the spell's power cost (mana, energy, rage, etc)      UNDOCUMENTED
+
+    // Other
+	{"Cancel", &LuaSpell::cancel},                                  // :Cancel() -- Cancels the spell casting                       UNDOCUMENTED
+	{"Cast", &LuaSpell::Cast},                                      // :Cast(skipCheck) -- Casts the spell (if true, removes the check for instant spells, etc)      UNDOCUMENTED
+	{"Finish", &LuaSpell::Finish},                                  // :Finish() -- Finishes the spell (SPELL_STATE_FINISH)         UNDOCUMENTED
+	{NULL, NULL},
+};
+
+ElunaRegister<Quest> QuestMethods[] =
+{
+	// Getters
+	{"GetUnitType", &LuaQuest::GetUnitType},                        // :GetUnitType() -- Returns the unit type (Quest)              UNDOCUMENTED
+	{"GetId", &LuaQuest::GetId},                                    // :GetId() -- Returns the quest's Id                           UNDOCUMENTED
+	{"GetLevel", &LuaQuest::GetLevel},                              // :GetLevel() -- Returns the quest's level                     UNDOCUMENTED
+	{"GetMaxLevel", &LuaQuest::GetMaxLevel},                        // :GetMaxLevel() -- Returns the quest's max level              UNDOCUMENTED
+	{"GetMinLevel", &LuaQuest::GetMinLevel},                        // :GetMinLevel() -- Returns the quest's min level              UNDOCUMENTED
+	{"GetNextQuestId", &LuaQuest::GetNextQuestId},                  // :GetNextQuestId() -- Returns the quest's next quest ID       UNDOCUMENTED
+	{"GetPrevQuestId", &LuaQuest::GetPrevQuestId},                  // :GetPrevQuestId() -- Returns the quest's previous quest ID   UNDOCUMENTED
+	{"GetNextQuestInChain", &LuaQuest::GetNextQuestInChain},        // :GetNexQuestInChain() -- Returns the next quest in its chain  UNDOCUMENTED
+	{"GetFlags", &LuaQuest::GetFlags},                              // :GetFlags() -- Returns the quest's flags                     UNDOCUMENTED
+	{"GetType", &LuaQuest::GetType},                                // :GetType() -- Returns the quest's type                       UNDOCUMENTED
+
+	// Boolean
+	{"HasFlag", &LuaQuest::HasFlag},                                // :HasFlag(flag) -- Returns true or false if the quest has the specified flag    UNDOCUMENTED
+	{"IsDaily", &LuaQuest::IsDaily},                                // :IsDaily() -- Returns true or false if the quest is a daily  UNDOCUMENTED
+	{"IsRepeatable", &LuaQuest::IsRepeatable},                      // :IsRepeatable() -- Returns true or false if the quest is repeatable   UNDOCUMENTED
+
+	// Setters
+	{"SetFlag", &LuaQuest::SetFlag},                                // :SetFlag(flag) -- Sets the flag of the quest by the specified flag    UNDOCUMENTED
+
+	{NULL, NULL},
+};
+
+ElunaRegister<Group> GroupMethods[] = 
+{
+    // Getters
+    {"GetMembers", &LuaGroup::GetMembers},                          // :GetMembers() - returns a table the players in this group. (Online?)
+    {"GetLeaderGUID", &LuaGroup::GetLeaderGUID},
+    {"GetLeader", &LuaGroup::GetLeader},
+    {"GetUnitType", &LuaGroup::GetUnitType},
+    {"GetGUID", &LuaGroup::GetGUID},
+    {"GetMemberGroup", &LuaGroup::GetMemberGroup},                  // :GetMemberGroup(player) - Returns the player's subgroup ID UNDOCUMENTED
+    {"GetMemberGUID", &LuaGroup::GetMemberGUID},                    // :GetMemberGUID("name") - Returns the member's GUID UNDOCUMENTED
+    {"GetMembersCount", &LuaGroup::GetMembersCount},                // :GetMembersCount() - Returns the member count of the group UNDOCUMENTED
+
+    // Setters
+    {"SetLeader", &LuaGroup::ChangeLeader},                         // :SetLeader(Player) - Sets the player as the new leader.
+    {"SetMembersGroup", &LuaGroup::ChangeMembersGroup},             // :ChangeMembersGroup(player, subGroup) - Changes the member's subgroup UNDOCUMENTED
+
+    // Boolean
+    {"IsLeader", &LuaGroup::IsLeader},                              // :IsLeader("name"/Player)
+    //{"HasRole", &LuaGroup::HasRole},                              // :HasRole("name"/Player, "role") - "tank" / "healer" / "dps"
+    {"AddInvite", &LuaGroup::AddInvite},                            // :AddInvite(player) - Adds a an invite to player. Returns true if succesful UNDOCUMENTED
+    {"RemoveMember", &LuaGroup::RemoveMember},                      // :RemoveMember(player) - Removes player from group. Returns true on success UNDOCUMENTED
+    {"Disband", &LuaGroup::Disband},                                // :Disband() - Disbands the group. UNDOCUMENTED
+    {"IsFull", &LuaGroup::IsFull},                                  // :IsFull() - Returns true if the group is full UNDOCUMENTED
+    {"IsLFGGroup", &LuaGroup::isLFGGroup},                          // :IsLFGGroup() - Returns true if the group is an LFG group UNDOCUMENTED
+    {"IsRaidGroup", &LuaGroup::isRaidGroup},                        // :IsRaidGroup() - Returns true if the group is a raid group UNDOCUMENTED
+    {"IsBGGroup", &LuaGroup::isBGGroup},                            // :IsBGGroup() - Returns true if the group is a battleground group UNDOCUMENTED
+    {"IsBFGroup", &LuaGroup::isBFGroup},                            // :IsBFGroup() - Returns true if the group is a battlefield group UNDOCUMENTED
+    {"IsMember", &LuaGroup::IsMember},                              // :IsMember(player) - Returns true if the player is a member of the group UNDOCUMENTED
+    {"IsAssistant", &LuaGroup::IsAssistant},                        // :IsAssistant(player) - returns true if the player is an assistant in the group UNDOCUMENTED
+    {"SameSubGroup", &LuaGroup::SameSubGroup},                      // :SameSubGroup(player1, player2) - Returns true if the players are in the same subgroup in the group UNDOCUMENTED
+    {"HasFreeSlotSubGroup", &LuaGroup::HasFreeSlotSubGroup},        // :HasFreeSlotSubGroup(subGroup) - Returns true if the subgroupID has free slots UNDOCUMENTED
+
+    // Other
+    {"SendPacket", &LuaGroup::SendPacket},                          // :SendPacket(packet, sendToPlayersInBattleground[, ignoreguid]) - Sends a specified packet to the group with the choice (true/false) to send it to players in a battleground. Optionally ignores given player guid. UNDOCUMENTED
+    {"ConvertToLFG", &LuaGroup::ConvertToLFG},                      // :ConvertToLFG() - Converts the group to an LFG group UNDOCUMENTED
+    {"ConvertToRaid", &LuaGroup::ConvertToRaid},                    // :ConvertToRaid() - Converts the group to a raid group UNDOCUMENTED
+
+    {NULL, NULL},
+};
+
+ElunaRegister<Guild> GuildMethods[] = 
+{
+    // Getters
+    {"GetMembers", &LuaGuild::GetMembers},                          // :GetMembers() - returns a table containing the players in this guild. (Online?)
+    {"GetUnitType", &LuaGuild::GetUnitType},                        // :GetUnitType() - Returns the unit type. Eg: Guild
+    {"GetLeaderGUID", &LuaGuild::GetLeaderGUID},                    // :GetLeaderGUID() - Returns the guild learder's guid
+    {"GetId", &LuaGuild::GetId},                                    // :GetId() - Gets the guild's ID UNDOCUMENTED
+    {"GetName", &LuaGuild::GetName},                                // :GetName() - Gets the guild name UNDOCUMENTED
+    {"GetMOTD", &LuaGuild::GetMOTD},                                // :GetMOTD() - Gets the guild MOTD string UNDOCUMENTED
+    {"GetInfo", &LuaGuild::GetInfo},                                // :GetInfo() - Gets the guild info string UNDOCUMENTED
+
+    // Setters
+    {"SetBankTabText", &LuaGuild::SetBankTabText},                  // :SetBankTabText(tabId, text) - UNDOCUMENTED
+    {"SetMemberRank", &LuaGuild::ChangeMemberRank},                 // :SetMemberRank(player, newRank) - Sets the player rank in the guild to the new rank UNDOCUMENTED
+
+    // Boolean
+
+    // Other
+    {"SendPacket", &LuaGuild::SendPacket},                          // :SendPacket(packet) - sends packet to guild. UNDOCUMENTED
+    {"SendPacketToRanked", &LuaGuild::SendPacketToRanked},          // :SendPacketToRanked(packet, rankId) - sends packet to guild, specifying a rankId will only send the packet to your ranked members. UNDOCUMENTED
+    {"Disband", &LuaGuild::Disband},                                // :Disband() - Disbands the guild UNDOCUMENTED
+    {"AddMember", &LuaGuild::AddMember},                            // :AddMember(player, rank) - adds the player to the guild. Rank is optional UNDOCUMENTED
+    {"DeleteMember", &LuaGuild::DeleteMember},                      // :DeleteMember(player, disbanding, kicked) - Deletes the player from the guild. Disbanding and kicked are optional bools. UNDOCUMENTED
+
+    {NULL, NULL},
+};
+
+ElunaRegister<QueryResult> QueryMethods[] =  // UNDOCUMENTED
+{
+    {"GetUnitType", &LuaQuery::GetUnitType},                        // :GetUnitType() - Returns object type, IE: QueryResult
+
+    {"NextRow", &LuaQuery::NextRow},                                // :NextRow() - Advances to next rown in the query. Returns true if there is a next row, otherwise false.
+    {"GetColumnCount", &LuaQuery::GetColumnCount},                  // :GetColumnCount() - Gets the column count of the query
+    {"GetRowCount", &LuaQuery::GetRowCount},                        // :GetRowCount() - Gets the row count of the query
+
+    {"GetBool", &LuaQuery::GetBool},                                // :GetBool(column) -- returns a bool from a number column (for example tinyint)
+    {"GetUInt8", &LuaQuery::GetUInt8},                              // :GetInt8(column) -- returns the value of an unsigned tinyint column
+    {"GetUInt16", &LuaQuery::GetUInt16},                            // :GetInt16(column) -- returns the value of a unsigned smallint column
+    {"GetUInt32", &LuaQuery::GetUInt32},                            // :GetInt32(column) -- returns the value of an unsigned int or mediumint column
+    //{"GetUInt64", &LuaQuery::GetUInt64},
+    {"GetInt8", &LuaQuery::GetInt8},                                // :GetInt8(column) -- returns the value of an tinyint column
+    {"GetInt16", &LuaQuery::GetInt16},                              // :GetInt16(column) -- returns the value of a smallint column
+    {"GetInt32", &LuaQuery::GetInt32},                              // :GetInt32(column) -- returns the value of an int or mediumint column
+    //{"GetInt64", &LuaQuery::GetInt64},
+    {"GetFloat", &LuaQuery::GetFloat},                              // :GetFloat(column) -- returns the value of a float column
+    {"GetDouble", &LuaQuery::GetDouble},                            // :GetDouble(column) -- returns the value of a double column
+    {"GetString", &LuaQuery::GetString},                            // :GetString(column) -- returns the value of a string column
+    {"IsNull", &LuaQuery::IsNull},                                  // :IsNull(column) -- returns true if the column is null
+
+    {NULL, NULL},
+};
+
+ElunaRegister<WorldPacket> PacketMethods[] =
+{    
+    {"GetOpcode", &LuaPacket::GetOpcode},                           //  :GetOpcode() -- Returns an opcode                    (UNDOCUMENTED)
+    {"GetSize", &LuaPacket::GetSize},                               //  :GetSize() -- Returns the packet size                 (UNDOCUMENTED)
+    {"GetUnitType", &LuaPacket::GetOpcode},                         //  :GetUnitType() -- Returns the unit type: Packet      (UNDOCUMENTED)
+
+    {"SetOpcode", &LuaPacket::SetOpcode},                           //  :SetOpcode(opcode) -- Sets the opcode by specifying an opcode            (UNDOCUMENTED)
+
+    {"ReadByte", &LuaPacket::ReadByte},                             //  :ReadByte() -- Reads an int8 value                    (UNDOCUMENTED)
+    {"ReadUByte", &LuaPacket::ReadUByte},                           //  :ReadUByte() -- Reads a uint8 value                   (UNDOCUMENTED)             
+    {"ReadShort", &LuaPacket::ReadShort},                           //  :ReadShort() -- Reads an int16 value                  (UNDOCUMENTED)
+    {"ReadUShort", &LuaPacket::ReadUShort},                         //  :ReadUShort() -- Reads a uint16 value                 (UNDOCUMENTED)
+    {"ReadString", &LuaPacket::ReadString},                         //  :ReadString()  -- Reads a string value                (UNDOCUMENTED)
+    {"ReadFloat", &LuaPacket::ReadFloat},                           //  :ReadFloat()  -- Reads a float value                  (UNDOCUMENTED)
+    {"ReadDouble", &LuaPacket::ReadDouble},                         //  :ReadDouble() -- Reads a double value                 (UNDOCUMENTED)
+    {"ReadLong", &LuaPacket::ReadLong},                             //  :ReadLong() -- Reads an int32 value                   (UNDOCUMENTED)
+    {"ReadULong", &LuaPacket::ReadULong},                           //  :ReadULong() -- Reads a uint32 value                  (UNDOCUMENTED)
+    {"ReadGUID", &LuaPacket::ReadGUID},                             //  :ReadGUID() -- Reads a uint64 GUID value              (UNDOCUMENTED)
+
+    {"WriteByte", &LuaPacket::WriteByte},                           //  :WriteByte(val)  -- Writes an int8 byte value         (UNDOCUMENTED)
+    {"WriteUByte", &LuaPacket::WriteUByte},                         //  :WriteUByte(val) -- Writes a uint8 ubyte value        (UNDOCUMENTED)
+    {"WriteShort", &LuaPacket::WriteShort},                         //  :WriteShort(val) -- Writes an int16 short value       (UNDOCUMENTED)
+    {"WriteUShort", &LuaPacket::WriteUShort},                       //  :WriteUShort(val) -- Writes a uint16 ushort value     (UNDOCUMENTED)
+    {"WriteString", &LuaPacket::WriteString},                       //  :WriteString(val) -- Writes a string value            (UNDOCUMENTED)
+    {"WriteFloat", &LuaPacket::WriteFloat},                         //  :WriteFloat(val) -- Writes a float value              (UNDOCUMENTED)
+    {"WriteDouble", &LuaPacket::WriteDouble},                       //  :WriteDouble(val) -- Writes a double value            (UNDOCUMENTED)
+    {"WriteGUID", &LuaPacket::WriteGUID},                           //  :WriteGUID(worldobject) -- Writes a uint64 guid value. WorldObject can be any unit: creature, gameobject, item.. (UNDOCUMENTED)
+    {"WriteLong", &LuaPacket::WriteLong},                           //  :WriteLong(val) -- Writes an int32 long value         (UNDOCUMENTED)
+    {"WriteULong", &LuaPacket::WriteULong},                         //  :WriteULong(val) -- Writes a uint32 ulong value       (UNDOCUMENTED)
+    {NULL, NULL},
+};
+
+template<typename T> ElunaRegister<T>* GetMethodTable() { return NULL; }
+template<> ElunaRegister<Unit>* GetMethodTable<Unit>() { return UnitMethods; }
+template<> ElunaRegister<GameObject>* GetMethodTable<GameObject>() { return GameObjectMethods; }
+template<> ElunaRegister<Group>* GetMethodTable<Group>() { return GroupMethods; }
+template<> ElunaRegister<Guild>* GetMethodTable<Guild>() { return GuildMethods; }
+template<> ElunaRegister<QueryResult>* GetMethodTable<QueryResult>() { return QueryMethods; }
+template<> ElunaRegister<Aura>* GetMethodTable<Aura>() { return AuraMethods; }
+template<> ElunaRegister<Item>* GetMethodTable<Item>() { return ItemMethods; }
+template<> ElunaRegister<WorldPacket>* GetMethodTable<WorldPacket>() { return PacketMethods; }
+template<> ElunaRegister<Spell>* GetMethodTable<Spell>() { return SpellMethods; }
+template<> ElunaRegister<Quest>* GetMethodTable<Quest>() { return QuestMethods; }
+#endif
\ No newline at end of file
diff --git a/src/server/LuaEngine/QueryMethods.h b/src/server/LuaEngine/QueryMethods.h
new file mode 100644
index 0000000..1657a4f
--- /dev/null
+++ b/src/server/LuaEngine/QueryMethods.h
@@ -0,0 +1,164 @@
+#ifndef QUERYMETHODS_H
+#define QUERYMETHODS_H
+
+class LuaQuery
+{
+public:
+
+    // QueryResult methods
+
+    static int GetUnitType(lua_State* L, QueryResult* result)
+    {
+        if (!result)
+            return 0;
+
+        Eluna::get()->PushString(L, "QueryResult");
+        return 1;
+    }
+
+    static int NextRow(lua_State* L, QueryResult* result)
+    {
+        if (!result)
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, result->get()->NextRow());
+        return 1;
+    }
+
+    static int GetColumnCount(lua_State* L, QueryResult* result)
+    {
+        if (!result)
+            Eluna::get()->PushUnsigned(L, 0);
+        else
+            Eluna::get()->PushUnsigned(L, result->get()->GetFieldCount());
+        return 1;
+    }
+
+    static int GetRowCount(lua_State* L, QueryResult* result)
+    {
+        if (!result)
+            Eluna::get()->PushUnsigned(L, 0);
+        else
+        {
+            if (result->get()->GetRowCount() > (uint32)-1)
+                Eluna::get()->PushUnsigned(L, (uint32)-1);
+            else
+                Eluna::get()->PushUnsigned(L, result->get()->GetRowCount());
+        }
+        return 1;
+    }
+
+
+    // Field methods
+
+    static int IsNull(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushBoolean(L, true);
+        else
+            Eluna::get()->PushBoolean(L, result->get()->Fetch()[col].IsNull());
+        return 1;
+    }
+
+    static int GetBool(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushBoolean(L, false);
+        else
+            Eluna::get()->PushBoolean(L, result->get()->Fetch()[col].GetBool());
+        return 1;
+    }
+
+    static int GetUInt8(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushUnsigned(L, 0);
+        else
+            Eluna::get()->PushUnsigned(L, result->get()->Fetch()[col].GetUInt8());
+        return 1;
+    }
+
+    static int GetUInt16(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushUnsigned(L, 0);
+        else
+            Eluna::get()->PushUnsigned(L, result->get()->Fetch()[col].GetUInt16());
+        return 1;
+    }
+
+    static int GetUInt32(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushUnsigned(L, 0);
+        else
+            Eluna::get()->PushUnsigned(L, result->get()->Fetch()[col].GetUInt32());
+        return 1;
+    }
+
+    static int GetInt8(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushInteger(L, 0);
+        else
+            Eluna::get()->PushInteger(L, result->get()->Fetch()[col].GetInt8());
+        return 1;
+    }
+
+    static int GetInt16(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushInteger(L, 0);
+        else
+            Eluna::get()->PushInteger(L, result->get()->Fetch()[col].GetInt16());
+        return 1;
+    }
+
+    static int GetInt32(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushInteger(L, 0);
+        else
+            Eluna::get()->PushInteger(L, result->get()->Fetch()[col].GetInt32());
+        return 1;
+    }
+
+    static int GetFloat(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushFloat(L, 0.0f);
+        else
+            Eluna::get()->PushFloat(L, result->get()->Fetch()[col].GetFloat());
+        return 1;
+    }
+
+    static int GetDouble(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushDouble(L, 0.0);
+        else
+            Eluna::get()->PushDouble(L, result->get()->Fetch()[col].GetDouble());
+        return 1;
+    }
+
+    static int GetString(lua_State* L, QueryResult* result)
+    {
+        uint32 col = luaL_checkunsigned(L, 1);
+        if (!result || !*result || col >= result->get()->GetFieldCount())
+            Eluna::get()->PushString(L, "");
+        else
+            Eluna::get()->PushString(L, result->get()->Fetch()[col].GetString().c_str());
+        return 1;
+    }
+};
+#endif
diff --git a/src/server/LuaEngine/QuestMethods.h b/src/server/LuaEngine/QuestMethods.h
new file mode 100644
index 0000000..fe39cce
--- /dev/null
+++ b/src/server/LuaEngine/QuestMethods.h
@@ -0,0 +1,149 @@
+#ifndef QUESTMETHODS_H
+#define QUESTMETHODS_H
+
+class LuaQuest
+{
+public:
+	// :GetUnitType()
+	static int GetUnitType(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        lua_pushstring(L, "Quest");
+        return 1;
+	}
+
+	// :GetId()
+	static int GetId(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, quest->GetQuestId());
+        return 1;
+	}
+
+	// :GetLevel()
+	static int GetLevel(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushInteger(L, quest->GetQuestLevel());
+        return 1;
+	}
+
+	// :GetMaxLevel()
+	static int GetMaxLevel(lua_State* L, Quest* quest)
+	{
+       if (!quest)
+           return 0;
+
+        Eluna::get()->PushUnsigned(L, quest->GetMaxLevel());
+        return 1;
+	}
+
+	// :GetMinLevel()
+	static int GetMinLevel(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, quest->GetMinLevel());
+        return 1;
+	}
+
+	// :GetNextQuestId()
+	static int GetNextQuestId(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushInteger(L, quest->GetNextQuestId());
+        return 1;
+	}
+
+	// :GetPrevQuestId()
+	static int GetPrevQuestId(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushInteger(L, quest->GetPrevQuestId());
+        return 1;
+	}
+
+	// :GetNextQuestInChain()
+	static int GetNextQuestInChain(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushInteger(L, quest->GetNextQuestInChain());
+        return 1;
+	}
+
+	// :GetFlags()
+	static int GetFlags(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, quest->GetFlags());
+        return 1;
+	}
+
+	// :GetType()
+	static int GetType(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, quest->GetType());
+        return 1;
+	}
+
+	// :HasFlag(flag)
+	static int HasFlag(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        uint32 flag = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushBoolean(L, quest->HasFlag(flag));
+        return 1;
+	}
+
+	// :IsDaily()
+	static int IsDaily(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushBoolean(L, quest->IsDaily());
+        return 1;
+	}
+
+	// :IsRepeatable()
+	static int IsRepeatable(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        Eluna::get()->PushBoolean(L, quest->IsRepeatable());
+        return 1;
+	}
+
+	// :SetFlag(flag)
+	static int SetFlag(lua_State* L, Quest* quest)
+	{
+        if (!quest)
+            return 0;
+
+        uint32 flag = luaL_checkunsigned(L, 1);
+        quest->SetFlag(flag);
+        return 0;
+	}
+};
+#endif
\ No newline at end of file
diff --git a/src/server/LuaEngine/SpellMethods.h b/src/server/LuaEngine/SpellMethods.h
new file mode 100644
index 0000000..75e6e29
--- /dev/null
+++ b/src/server/LuaEngine/SpellMethods.h
@@ -0,0 +1,98 @@
+#ifndef SPELLMETHODS_H
+#define SPELLMETHODS_H
+
+class LuaSpell
+{
+public:
+	// :GetUnitType()
+	static int GetUnitType(lua_State* L, Spell* spell)
+	{
+        if (!spell)
+            return 0;
+
+       lua_pushstring(L, "Spell");
+        return 1;
+	}
+
+    // GetCaster()
+    static int GetCaster(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        Eluna::get()->PushUnit(L, spell->GetCaster());
+        return 1;
+    }
+
+    // GetCastTime()
+    static int GetCastTime(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        Eluna::get()->PushInteger(L, spell->GetCastTime());
+        return 1;
+    }
+
+    // GetId()
+    static int GetId(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, spell->GetSpellInfo()->Id);
+        return 1;
+    }
+
+	// GetPowerCost()
+	static int GetPowerCost(lua_State* L, Spell* spell)
+	{
+		if (!spell)
+			return 0;
+
+		Eluna::get()->PushInteger(L, spell->GetPowerCost());
+		return 1;
+	}
+
+	// GetDuration()
+	static int GetDuration(lua_State* L, Spell* spell)
+	{
+        if (!spell)
+            return 0;
+
+        Eluna::get()->PushInteger(L, spell->GetSpellInfo()->GetDuration());
+        return 1;
+	}
+
+	// Cast(skipCheck)
+	static int Cast(lua_State* L, Spell* spell)
+	{
+        if (!spell)
+            return 0;
+
+        bool skipCheck = lua_toboolean(L, 1);
+        spell->cast(skipCheck);
+        return 0;
+	}
+
+    // Cancel()
+    static int cancel(lua_State* L, Spell* spell)
+    {
+        if (!spell)
+            return 0;
+
+        spell->cancel();
+        return 0;
+    }
+
+	// Finish()
+	static int Finish(lua_State* L, Spell* spell)
+	{
+        if (!spell)
+            return 0;
+
+        spell->finish();
+        return 0;
+	}
+};
+#endif
\ No newline at end of file
diff --git a/src/server/LuaEngine/UnitMethods.h b/src/server/LuaEngine/UnitMethods.h
new file mode 100644
index 0000000..b507c65
--- /dev/null
+++ b/src/server/LuaEngine/UnitMethods.h
@@ -0,0 +1,1889 @@
+#ifndef UNITMETHODS_H
+#define UNITMETHODS_H
+
+#define TO_PLAYER()  Player* player; if (!unit || !unit->IsInWorld() || !(player = unit->ToPlayer()))     { return 0; } else (void)0;
+#define TO_CREATURE()  Creature* creature; if (!unit || !unit->IsInWorld() || !(creature = unit->ToCreature())) { return 0; } else (void)0;
+#define TO_UNIT()  if (!unit || !unit->IsInWorld() || !unit->ToUnit())  { return 0; } else (void)0;
+
+
+#define TO_PLAYER_BOOL()  Player* player;  if (!unit || !unit->IsInWorld() || !(player = unit->ToPlayer()))     { Eluna::get()->PushBoolean(L, false); return 1; } else (void)0;
+#define TO_CREATURE_BOOL()  Creature* creature; if (!unit || !unit->IsInWorld() || !(creature = unit->ToCreature())) { Eluna::get()->PushBoolean(L, false); return 1; } else (void)0;
+#define TO_UNIT_BOOL() if (!unit || !unit->IsInWorld() || !unit->ToUnit()) { Eluna::get()->PushBoolean(L, false); return 1; } else (void)0;
+
+class LuaUnit
+{
+public:
+
+    //SpawnGameObject(entry, x, y, z, o[, respawnDelay])
+    static int SummonGameObject(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+        
+        uint32 entry = luaL_checkunsigned(L, 1);
+        float x = luaL_checknumber(L, 2);
+        float y = luaL_checknumber(L, 3);
+        float z = luaL_checknumber(L, 4);
+        float o = luaL_checknumber(L, 5);
+        uint32 respawnDelay = luaL_optunsigned(L, 6, 30);
+        Eluna::get()->PushGO(L, unit->SummonGameObject(entry, x, y, z, o, 0, 0, 0, 0, respawnDelay));
+        return 1;
+    }
+
+    //SpawnCreature(entry, x, y, z, o[, despawnDelay])
+    static int SpawnCreature(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 entry = luaL_checkunsigned(L, 1);
+        float x = luaL_checknumber(L, 2);
+        float y = luaL_checknumber(L, 3);
+        float z = luaL_checknumber(L, 4);
+        float o = luaL_checknumber(L, 5);
+        uint32 desp = luaL_optunsigned(L, 6, 0);
+        Eluna::get()->PushUnit(L, unit->SummonCreature(entry, x, y, z, o, desp ? TEMPSUMMON_TIMED_OR_DEAD_DESPAWN : TEMPSUMMON_MANUAL_DESPAWN, desp));
+        return 1;
+    }
+
+    //Despawn([despawnDelay])
+    static int Despawn(lua_State* L, Unit* unit)
+    {
+        TO_CREATURE();
+        
+        uint32 time = luaL_optunsigned(L, 1, 0);
+        creature->DespawnOrUnsummon(time);
+        return 0;
+    }
+
+    //GetArenaPoints()
+    static int GetArenaPoints(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushUnsigned(L, player->GetArenaPoints());
+        return 1;
+    }
+
+    //KnockbackFrom()
+    static int KnockbackFrom(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        float x = luaL_checknumber(L, 1);
+        float y = luaL_checknumber(L, 2);
+        float speedXY = luaL_checknumber(L, 3);
+        float speedZ = luaL_checknumber(L, 4);
+        unit->KnockbackFrom(x, y, speedXY, speedZ);
+        return 0;
+    }
+
+    //JumpTo(WorldObj, speedZ)
+    static int JumpTo(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        WorldObject* obj = Eluna::get()->CHECK_WORLDOBJECT(L, 1);
+        float speedZ = luaL_checknumber(L, 2);
+        if(!obj)
+            return 0;
+
+        unit->JumpTo(obj, speedZ);
+        return 0;
+    }
+
+    //Jump(speedXY, speedZ[, forward])
+    static int Jump(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        float speedXY = luaL_checknumber(L, 1);
+        float speedZ = luaL_checknumber(L, 2);
+        bool forward = luaL_optbool(L, 3, true);
+        unit->JumpTo(speedXY, speedZ, forward);
+        return 0;
+    }
+
+    //JumpToCoords(x, y, z, speedXY, speedZ)
+    static int JumpToCoords(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        float x = luaL_checknumber(L, 1);
+        float y = luaL_checknumber(L, 2);
+        float z = luaL_checknumber(L, 3);
+        float speedXY = luaL_checknumber(L, 4);
+        float speedZ = luaL_checknumber(L, 5);
+        unit->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
+        return 0;
+    }
+
+    //MoveCharge(x, y, z, speed)
+    static int MoveCharge(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        float x = luaL_checknumber(L, 1);
+        float y = luaL_checknumber(L, 2);
+        float z = luaL_checknumber(L, 3);
+        float speed = luaL_checknumber(L, 4);
+        unit->GetMotionMaster()->MoveCharge(x, y, z, speed);
+        return 0;
+    }
+
+    //MoveChase(target[, dist, angle])
+    static int MoveChase(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+        
+        Unit* target = Eluna::get()->CHECK_UNIT(L, 1);
+        float dist = luaL_optnumber(L, 2, 0.0f);
+        float angle = luaL_optnumber(L, 3, 0.0f);
+        unit->GetMotionMaster()->MoveChase(target, dist, angle);
+        return 0;
+    }
+
+    //SetStunned(apply)
+    static int SetStunned(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        bool apply = luaL_optbool(L, 1, true);
+        unit->SetControlled(apply, UNIT_STATE_STUNNED);
+        return 0;
+    }
+
+    //SetRooted(apply)
+    static int SetRooted(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        bool apply = luaL_optbool(L, 1, true);
+        unit->SetControlled(apply, UNIT_STATE_ROOT);
+        return 0;
+    }
+
+    //SetConfused(apply)
+    static int SetConfused(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        bool apply = luaL_optbool(L, 1, true);
+        unit->SetControlled(apply, UNIT_STATE_CONFUSED);
+        return 0;
+    }
+
+    //SetFeared(apply)
+    static int SetFeared(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        bool apply = luaL_optbool(L, 1, true);
+        unit->SetControlled(apply, UNIT_STATE_FLEEING);
+        return 0;
+    }
+
+    //MoveTo(id, x, y, z[, generatePath])
+    static int MovePoint(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+        
+        float id = luaL_checknumber(L, 1);
+        float x = luaL_checknumber(L, 2);
+        float y = luaL_checknumber(L, 3);
+        float z = luaL_checknumber(L, 4);
+        bool generatePath = luaL_optbool(L, 5, true);
+        unit->GetMotionMaster()->MovePoint(id, x, y, z, generatePath);
+        return 0;
+    }
+
+    //MoveFollow(target, dist, angle)
+    static int MoveFollow(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+        
+        Unit* target = Eluna::get()->CHECK_UNIT(L, 1);
+        float dist = luaL_checknumber(L, 2);
+        float angle = luaL_checknumber(L, 3);
+        unit->GetMotionMaster()->MoveFollow(target, dist, angle);
+        return 0;
+    }
+
+    //MoveClear()
+    static int MoveClear(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        unit->GetMotionMaster()->Clear();
+        return 0;
+    }
+
+    //MoveRandom(radius)
+    static int MoveRandom(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        float radius = luaL_checknumber(L, 1);
+        unit->GetMotionMaster()->MoveRandom(radius);
+        return 0;
+    }
+
+    //MoveRotate(time, left)
+    static int MoveRotate(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 time = luaL_checkunsigned(L, 1);
+        bool left = luaL_optbool(L, 2, true);
+        unit->GetMotionMaster()->MoveRotate(time, left ? ROTATE_DIRECTION_LEFT : ROTATE_DIRECTION_RIGHT);
+        return 0;
+    }
+
+    //SetWalk(enable)
+    static int SetWalk(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+        
+        bool enable = luaL_optbool(L, 1, true);
+        unit->SetWalk(enable);
+        return 0;
+    }
+
+    //SetSpeed(type, speed[, forced])
+    static int SetSpeed(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+        
+        uint32 type = luaL_checkunsigned(L, 1);
+        float rate = luaL_checknumber(L, 2);
+        bool forced = luaL_optbool(L, 3, false);
+        if(type >= MAX_MOVE_TYPE)
+            sLog->outError(LOG_FILTER_GENERAL, "Eluna::Invalid movement type (%u)  for SetSpeed", type);
+        else
+            unit->SetSpeed((UnitMoveType)type, rate, forced);
+        return 0;
+    }
+
+    //GetHonorPoints()
+    static int GetHonorPoints(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushUnsigned(L, player->GetHonorPoints());
+        return 1;
+    }
+    //GetSelection()
+    static int GetSelection(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushUnit(L, player->GetSelectedUnit());
+        return 1;
+    }
+
+    //GetSecurity
+    static int GetSecurity(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushInteger(L, player->GetSession()->GetSecurity());
+        return 1;
+    }
+
+    //GetCoinage()
+    static int GetCoinage(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushUnsigned(L, player->GetMoney());
+        return 1;
+    }
+
+    // GetDisplayID()
+    static int GetDisplayID(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->GetDisplayId());
+        return 1;
+    }
+
+    // GetName()
+    static int GetName(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+        Eluna::get()->PushString(L, unit->GetName().c_str());
+        return 1;
+    }
+
+    // GetLevel()
+    static int GetLevel(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->getLevel());
+        return 1;
+    }
+
+    // GetHealth()
+    static int GetHealth(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->GetHealth());
+        return 1;
+    }
+
+    // GetGuildId()
+    static int GetGuildID(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        if (!player->GetGuildId())
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, player->GetGuildId());
+        return 1;
+    }
+
+    // GetX()
+    static int GetX(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushFloat(L, unit->GetPositionX());
+        return 1;
+    }
+
+    // GetY()
+    static int GetY(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushFloat(L, unit->GetPositionY());
+        return 1;
+    }
+
+    // GetZ()
+    static int GetZ(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushFloat(L, unit->GetPositionZ());
+        return 1;
+    }
+
+    // GetO()
+    static int GetO(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushFloat(L, unit->GetOrientation());
+        return 1;
+    }
+
+    // GetLocation()
+    static int GetLocation(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushFloat(L, unit->GetPositionX());
+        Eluna::get()->PushFloat(L, unit->GetPositionY());
+        Eluna::get()->PushFloat(L, unit->GetPositionZ());
+        Eluna::get()->PushFloat(L, unit->GetOrientation());
+        return 4;
+    }
+
+    // GetZoneId()
+    static int GetZoneId(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->GetZoneId());
+        return 1;
+    }
+
+    //GetInstanceId()
+    static int GetInstanceId(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->GetInstanceId());
+        return 1;
+    }
+
+    //GetPhaseMask()
+    static int GetPhaseMask(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->GetPhaseMask());
+        return 1;
+    }
+
+    // GetAreaId()
+    static int GetAreaId(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->GetAreaId());
+        return 1;
+    }
+
+    // GetTeam()
+    static int GetTeam(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushInteger(L, player->GetTeamId());
+        return 1;
+    }
+
+    // GetGUID()
+    static int GetGUID(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushGUID(L, unit->GetGUID());
+        return 1;
+    }
+
+    // GetPower([powertype])
+    static int GetPower(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        int type = luaL_optint(L, 1, -1);
+        if (type == -1)
+        {
+            // We didn't specify a type, so get the default type for our class
+            switch(unit->getClass())
+            {
+            case 1:
+                type = POWER_RAGE;
+                break;
+            case 4:
+                type = POWER_ENERGY;
+                break;
+            case 6:
+                type = POWER_RUNIC_POWER;
+                break;
+            case 2:
+            case 3:
+            case 5:
+            case 7:
+            case 8:
+            case 9:
+            case 11:
+                type = POWER_MANA;
+                break;
+            default:
+                type = POWER_MANA;
+            }
+        }
+        else if (type >= POWER_ALL)
+        {
+            luaL_error(L, "Bad argument #1 to :GetPower(index) - specified out of range index (%i)", type);
+            return 0;
+        }
+
+        Eluna::get()->PushUnsigned(L, unit->GetPower((Powers) type));
+        return 1;
+    }
+
+    // GetMaxPower([index])
+    static int GetMaxPower(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        int type = luaL_optint(L, 1, -1);
+        if (type == -1)
+        {
+            // We didn't specify a type, so get the default type for our class
+            switch(unit->getClass())
+            {
+            case 1:
+                type = POWER_RAGE;
+                break;
+            case 4:
+                type = POWER_ENERGY;
+                break;
+            case 6:
+                type = POWER_RUNIC_POWER;
+                break;
+            case 2:
+            case 3:
+            case 5:
+            case 7:
+            case 8:
+            case 9:
+            case 11:
+                type = POWER_MANA;
+                break;
+            default:
+                type = POWER_MANA;
+            }
+        }
+        else if (type >= POWER_ALL)
+        {
+            luaL_error(L, "Bad argument #1 to :GetMaxPower(index) - specified out of range index.");
+            return 0;
+        }
+
+        Eluna::get()->PushUnsigned(L, unit->GetMaxPower((Powers) type));
+        return 1;
+    }
+
+    //GetPowerType()
+    static int GetPowerType(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushInteger(L, unit->getPowerType());
+        return 1;
+    }
+
+    // GetMaxHealth()
+    static int GetMaxHealth(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->GetMaxHealth());
+        return 1;
+    }
+
+    // GetHealthPct()
+    static int GetHealthPct(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushFloat(L, unit->GetHealthPct());
+        return 1;
+    }
+
+    // GetPowerPct()
+    static int GetPowerPct(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        float percent = (unit->GetPower(unit->getPowerType()) / unit->GetMaxPower(unit->getPowerType())) * 100;
+        Eluna::get()->PushFloat(L, percent);
+        return 1;
+    }
+
+    // GetGender()
+    static int GetGender(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+        Eluna::get()->PushUnsigned(L, unit->getGender());
+        return 1;
+    }
+
+    // GetRace()
+    static int GetRace(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->getRace());
+        return 1;
+    }
+
+    // GetClass() - returns numerical index of class
+    static int GetClass(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->getClass());
+        return 1;
+    }
+
+    // GetClassAsString()
+    static int GetClassAsString(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        const char* str = NULL;
+        switch(unit->getClass())
+        {
+        case 1:
+            str = "Warrior";
+            break;
+        case 2:
+            str = "Paladin";
+            break;
+        case 3:
+            str = "Hunter";
+            break;
+        case 4:
+            str = "Rogue";
+            break;
+        case 5:
+            str = "Priest";
+            break;
+        case 6:
+            str = "DeathKnight";
+            break;
+        case 7:
+            str = "Shaman";
+            break;
+        case 8:
+            str = "Mage";
+            break;
+        case 9:
+            str = "Warlock";
+            break;
+        case 11:
+            str = "Druid";
+            break;
+        default:
+            str = "NULL";
+            break;
+        }
+
+        Eluna::get()->PushString(L, str);
+        return 1;
+    }
+
+    // GetItemCount(id[, checkbank])
+    static int GetItemCount(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        int id = luaL_checknumber(L, 1);
+        bool checkinBank = luaL_checkbool(L, 2);
+        Eluna::get()->PushUnsigned(L, player->GetItemCount(id, checkinBank));
+        return 1;
+    }
+
+    // GetUnitType()
+    static int GetUnitType(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        if (unit->ToPlayer())
+            Eluna::get()->PushString(L, "Player");
+        else if (unit->ToCreature())
+            Eluna::get()->PushString(L, "Creature");
+        else
+            Eluna::get()->PushString(L, "Unknown");
+        return 1;
+    }
+
+    // GetGuild()
+    static int GetGuild(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushGuild(L, player->GetGuild());
+        return 1;
+    }
+
+    // GetGroup()
+    static int GetGroup(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushGroup(L, player->GetGroup());
+        return 1;
+    }
+
+    // GetGearLevel()
+    static int GetGearLevel(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushFloat(L, player->GetAverageItemLevel());
+        return 1;
+    }
+
+    // GetEntry()
+    static int GetEntry(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->GetEntry());
+        return 1;
+    }
+
+    // Set Methods
+
+    // SetLevel(level)
+    static int SetLevel(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 newLevel = luaL_checkunsigned(L, 1);
+        unit->SetLevel(newLevel);
+        return 0;
+    }
+
+    //SetPhaseMask(Phase, update)
+    static int SetPhaseMask(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+        uint32 phaseMask = luaL_checkunsigned(L, 1);
+        bool Update = luaL_optbool(L, 2, true);
+        unit->SetPhaseMask(phaseMask, Update);
+        return 0;
+    }
+
+    //SetArenaPoints(amount)
+    static int SetArenaPoints(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 arenaP = luaL_checkunsigned(L, 1);
+        player->SetArenaPoints(arenaP);
+        return 0;
+    }
+
+    //SetHonorPoints(amount)
+    static int SetHonorPoints(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 honorP = luaL_checkunsigned(L, 1);
+        player->SetHonorPoints(honorP);
+        return 0;
+    }
+
+    // SetHealth(amount)
+    static int SetHealth(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 amt = luaL_checkunsigned(L, 1);
+        unit->SetHealth(amt);
+        return 0;
+    }
+
+    // SetMaxHealth(amount)
+    static int SetMaxHealth(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 amt = luaL_checkunsigned(L, 1);
+        unit->SetMaxHealth(amt);
+        return 0;
+    }
+
+    // SetPower(powerType, amount)
+    static int SetPower(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        int type = luaL_checkinteger(L, 1);
+        uint32 amt = luaL_checkunsigned(L, 2);
+
+        switch(type)
+        {
+        case POWER_MANA:
+            unit->SetPower(POWER_MANA, amt);
+            break;
+        case POWER_RAGE:
+            unit->SetPower(POWER_RAGE, amt);
+            break;
+        case POWER_ENERGY:
+            unit->SetPower(POWER_ENERGY, amt);
+            break;
+        case POWER_RUNIC_POWER:
+            unit->SetPower(POWER_RUNIC_POWER, amt);
+            break;
+        default:
+            luaL_error(L, "Bad argument #1 for SetPower - Unknown power type (%i)", type);
+            break;
+        }
+        return 0;
+    }
+
+    // SetMaxPower(Type, amt)
+    static int SetMaxPower(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        int type = luaL_checkinteger(L, 1);
+        int amt = luaL_checkunsigned(L, 2);
+
+        switch(type)
+        {
+        case POWER_MANA:
+            unit->SetMaxPower(POWER_MANA, amt);
+            break;
+        case POWER_RAGE:
+            unit->SetMaxPower(POWER_RAGE, amt);
+            break;
+        case POWER_ENERGY:
+            unit->SetMaxPower(POWER_ENERGY, amt);
+            break;
+        case POWER_RUNIC_POWER:
+            unit->SetMaxPower(POWER_RUNIC_POWER, amt);
+            break;
+        default:
+            luaL_error(L, "Bad argument #1 for SetPower - Unknown power type (%i)", type);
+            break;
+        }
+        return 0;
+    }
+
+    // SetDisplayID(id)
+    static int SetDisplayID(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 model = luaL_checkunsigned(L, 1);
+        unit->SetDisplayId(model);
+        return 0;
+    }
+
+    // SetFacing(o)
+    static int SetFacing(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        float o = luaL_checknumber(L, 1);
+        unit->SetFacingTo(o);
+        return 0;
+    }
+
+    //SetDeathState(value)
+    static int SetDeathState(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint8 ds = luaL_checkunsigned(L, 1);
+        unit->setDeathState((DeathState)ds);
+        return 0;
+    }
+
+    // SetCoinage(amount)
+    static int SetCoinage(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 amt = luaL_checkunsigned(L, 1);
+        player->SetMoney(amt);
+        return 0;
+    }
+
+    //SetBindPoint(x, y, z, mapid, areaid)
+    static int SetBindPoint(lua_State * L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        float x = luaL_checknumber(L, 1);
+        float y = luaL_checknumber(L, 2);
+        float z = luaL_checknumber(L, 3);
+        uint32 mapId = luaL_checkunsigned(L, 4);
+        uint32 areaId = luaL_checkunsigned(L, 5);
+
+        WorldLocation loc(mapId, x, y, z);
+        player->SetHomebind(loc, areaId);
+        return 0;
+    }
+
+    //SetBindPointAtPlayerLoc()
+    static int SetBindPointAtPlayerLoc(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        WorldLocation loc;
+        player->GetPosition(&loc);
+        loc.m_mapId = player->GetMapId();
+        player->SetHomebind(loc, player->GetAreaId());
+        return 0;
+    }
+
+    // SetKnownTitle(id)
+    static int SetKnownTitle(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 id = luaL_checkunsigned(L, 1);
+        CharTitlesEntry const* t = sCharTitlesStore.LookupEntry(id);
+        if (t)
+            player->SetTitle(t, false);
+        return 0;
+    }
+
+    // UnsetKnownTitle(id)
+    static int UnsetKnownTitle(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 id = luaL_checkunsigned(L, 1);
+        CharTitlesEntry const* t = sCharTitlesStore.LookupEntry(id);
+        if (t)
+            player->SetTitle(t, true);
+        return 0;
+    }
+
+    // AdvanceSkillsToMax()
+    static int AdvanceSkillsToMax(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        player->UpdateSkillsToMaxSkillsForLevel();
+        return 0;
+    }
+
+    // AdvanceAllSkills(value)
+    static int AdvanceAllSkills(lua_State* L, Unit * unit)
+    {
+        TO_PLAYER();
+
+        uint32 skillsArray[] = { SKILL_BOWS, SKILL_CROSSBOWS, SKILL_DAGGERS, SKILL_DEFENSE, SKILL_UNARMED, SKILL_GUNS, SKILL_AXES, SKILL_MACES, SKILL_SWORDS, SKILL_POLEARMS,
+            SKILL_STAVES, SKILL_2H_AXES, SKILL_2H_MACES, SKILL_2H_SWORDS, SKILL_WANDS, SKILL_SHIELD, SKILL_FISHING, SKILL_MINING, SKILL_ENCHANTING, SKILL_BLACKSMITHING,
+            SKILL_ALCHEMY, SKILL_HERBALISM, SKILL_ENGINEERING, SKILL_JEWELCRAFTING, SKILL_LEATHERWORKING, SKILL_LOCKPICKING, SKILL_INSCRIPTION, SKILL_SKINNING, SKILL_TAILORING };
+        uint32 step = luaL_checkunsigned(L, 1);
+
+        if (!step)
+            return 0;
+
+        for (int i = 0; i < sizeof(skillsArray); ++i)
+        {
+            if (player->HasSkill(skillsArray[i]))
+                player->UpdateSkill(skillsArray[i], step);
+        }
+        return 0;
+    }
+
+    // AdvanceSkill(skill_id, step)
+    static int AdvanceSkill(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 _skillId = luaL_checkunsigned(L, 1);
+        uint32 _step = luaL_checkunsigned(L, 2);
+        if (_skillId && _step)
+        {
+            if (player->HasSkill(_skillId))
+                player->UpdateSkill(_skillId, _step);
+        }
+        return 0;
+    }
+
+
+    // Boolean Methods
+
+    // IsInGroup()
+    static int IsInGroup(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        Eluna::get()->PushBoolean(L, (player->GetGroup() != NULL));
+        return 1;
+    }
+
+    // IsInGuild()
+    static int IsInGuild(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        Eluna::get()->PushBoolean(L, (player->GetGuildId() != 0));
+        return 1;
+    }
+
+    // IsGM()
+    static int IsGM(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        Eluna::get()->PushBoolean(L, player->isGameMaster());
+        return 1;
+    }
+
+    // IsAlive()
+    static int IsAlive(lua_State* L, Unit* unit)
+    {
+        TO_UNIT_BOOL();
+
+        Eluna::get()->PushBoolean(L, unit->isAlive());
+        return 1;
+    }
+
+    //IsInArenaTeam(type) type : 0 = 2v2, 1 = 3v3, 2 = 5v5
+    static int IsInArenaTeam(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        uint32 type = luaL_checkunsigned(L, 1);
+        if (type < MAX_ARENA_SLOT && player->GetArenaTeamId(type))
+            Eluna::get()->PushBoolean(L, true);
+        else
+            Eluna::get()->PushBoolean(L, false);
+        return 1;
+    }
+
+    // IsInWorld()
+    static int IsInWorld(lua_State* L, Unit* unit)
+    {
+        TO_UNIT_BOOL();
+
+        Eluna::get()->PushBoolean(L, unit->IsInWorld());
+        return 1;
+    }
+
+    // IsPvPFlagged()
+    static int IsPvPFlagged(lua_State* L, Unit* unit)
+    {
+        TO_UNIT_BOOL();
+
+        Eluna::get()->PushBoolean(L, unit->IsPvP());
+        return 1;
+    }
+
+    // HasQuest(id)
+    static int HasQuest(lua_State* L, Unit* unit)
+    {
+        TO_UNIT_BOOL();
+
+        uint32 questId = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushBoolean(L, unit->hasQuest(questId));
+        return 1;
+    }
+
+    // IsHorde()
+    static int IsHorde(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        Eluna::get()->PushBoolean(L, (player->GetTeam() == HORDE));
+        return 1;
+    }
+
+    // IsAlliance()
+    static int IsAlliance(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        Eluna::get()->PushBoolean(L, (player->GetTeam() == ALLIANCE));
+        return 1;
+    }
+
+    // IsInCombat();
+    static int IsInCombat(lua_State* L, Unit* unit)
+    {
+        TO_UNIT_BOOL();
+
+        Eluna::get()->PushBoolean(L, unit->isInCombat());
+        return 1;
+    }
+
+    // HasTitle(id)
+    static int HasTitle(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        uint32 id = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushBoolean(L, player->HasTitle(id));
+        return 1;
+    }
+
+    // HasSpell(id)
+    static int HasSpell(lua_State* L, Unit* unit)
+    {
+        TO_UNIT_BOOL();
+
+        uint32 id = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushBoolean(L, unit->HasSpell(id));
+        return 1;
+    }
+
+    // Other Methods
+
+    // Teleport(mapid, x, y, z, o)
+    static int Teleport(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        uint32 mapId = luaL_checkunsigned(L, 1);
+        float X = luaL_checknumber(L, 2);
+        float Y = luaL_checknumber(L, 3);
+        float Z = luaL_checknumber(L, 4);
+        float O = luaL_checknumber(L, 5);
+        Eluna::get()->PushBoolean(L, player->TeleportTo(mapId, X, Y, Z, O));
+        return 1;
+    }
+
+    // AddItem(entry, amount)
+    static int AddItem(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        uint32 itemId = luaL_checkunsigned(L, 1);
+        uint32 itemCount = luaL_checkunsigned(L, 2);
+        Eluna::get()->PushBoolean(L, player->AddItem(itemId, itemCount));
+        return 0;
+    }
+
+    // RemoveItem(entry, amount)
+    static int RemoveItem(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 itemId = luaL_checkunsigned(L, 1);
+        uint32 itemCount = luaL_checkunsigned(L, 2);
+
+        player->DestroyItemCount(itemId, itemCount, true);
+        return 0;
+    }
+
+    // SendBroadcastMessage(msg)
+    static int SendBroadcastMessage(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        const char* message = luaL_checkstring(L, 1);
+        if (string(message).length() > 0)
+            ChatHandler(player->GetSession()).SendSysMessage(message);
+        return 0;
+    }
+
+    // SendAreaTriggerMessage(msg)
+    static int SendAreaTriggerMessage(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        const char* msg = luaL_checkstring(L, 1);
+        if (string(msg).length() > 0)
+            player->GetSession()->SendAreaTriggerMessage(msg);
+        return 0;
+    }
+
+    // SendNotification(msg)
+    static int SendNotification(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        const char* msg = luaL_checkstring(L, 1);
+        if (string(msg).length() > 0)
+            player->GetSession()->SendNotification(msg);
+        return 0;
+    }
+
+    // SendUnitWhisper(msg, receiver, bossWhisper)
+    static int SendUnitWhisper(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        const char* msg = luaL_checkstring(L, 1);
+        Unit* receiver = Eluna::get()->CHECK_UNIT(L, 2);
+        if (receiver && string(msg).length() > 0)
+            unit->MonsterWhisper(msg, receiver->GetGUID(), false);
+        return 0;
+    }
+
+    // SendUnitSay(msg, language)
+    static int SendUnitSay(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        const char* msg = luaL_checkstring(L, 1);
+        uint32 language = luaL_checknumber(L, 2);
+        if (string(msg).length() > 0)
+            unit->MonsterSay(msg, language, unit->GetGUID());
+        return 0;
+    }
+
+    // SendUnitYell(msg, language)
+    static int SendUnitYell(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        const char* msg = luaL_checkstring(L, 1);
+        uint32 language = luaL_checknumber(L, 2);
+        if (string(msg).length() > 0)
+            unit->MonsterYell(msg, language, unit->GetGUID());
+        return 0;
+    }
+
+    // SendPacketToPlayer(packet)
+    static int SendPacketToPlayer(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        WorldPacket* data = Eluna::get()->CHECK_PACKET(L, 1);
+        if (data)
+            player->GetSession()->SendPacket(data);
+        return 0;
+    }
+
+    // SendPacket(packet)
+    static int SendPacket(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        WorldPacket* data = Eluna::get()->CHECK_PACKET(L, 1);
+        if (data)
+            player->SendMessageToSet(data, false);
+        return 0;
+    }
+
+    // SendPacketToGroup(packet, sendToPlayersInBattleground)
+    static int SendPacketToGroup(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        WorldPacket* data = Eluna::get()->CHECK_PACKET(L, 1);
+        bool ignorePlayersInBg = luaL_checkbool(L, 2);
+        if (data && player->GetGroup())
+            player->GetGroup()->BroadcastPacket(data, ignorePlayersInBg, -1, player->GetGUID());
+        return 0;
+    }
+
+    // SendPacketToGuild(packet)
+    static int SendPacketToGuild(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        WorldPacket* data = Eluna::get()->CHECK_PACKET(L, 1);
+        if (data && player->GetGuild())
+            player->GetGuild()->BroadcastPacket(data);
+        return 0;
+    }
+
+    // SendPacketToRankedInGuild(packet, rankId)
+    static int SendPacketToRankedInGuild(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        WorldPacket* data = Eluna::get()->CHECK_PACKET(L, 1);
+        uint8 ranked = luaL_checkunsigned(L, 2);
+        if (data && player->GetGuild())
+            player->GetGuild()->BroadcastPacketToRank(data, ranked);
+        return 0;
+    }
+
+	// :SendVendorWindow(unit)
+	static int SendVendorWindow(lua_State* L, Unit* unit)
+	{
+		TO_PLAYER();
+
+		Unit* sendTo = Eluna::get()->CHECK_UNIT(L, 1);
+		if (!sendTo)
+			return 0;
+		player->GetSession()->SendListInventory(sendTo->GetGUID());
+		return 0;
+	}
+
+    // GiveCoinage(amount)
+    static int GiveCoinage(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        int amt = luaL_checkinteger(L, 1);
+        if (amt > 0)
+            Eluna::get()->PushBoolean(L, player->ModifyMoney(amt));
+        else
+            Eluna::get()->PushBoolean(L, false);
+        return 1;
+    }
+
+    // RemoveCoinage(amount)
+    static int RemoveCoinage(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER_BOOL();
+
+        int amt = luaL_checkinteger(L, 1);
+        if (amt > 0)
+            Eluna::get()->PushBoolean(L, player->ModifyMoney(amt));
+        else
+            Eluna::get()->PushBoolean(L, false);
+        return 1;
+    }
+
+    // LearnSpell(id)
+    static int LearnSpell(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 id = luaL_checkunsigned(L, 1);
+        player->learnSpell(id,  false);
+        return 0;
+    }
+
+    // DeMorph()
+    static int DeMorph(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        unit->DeMorph();
+        return 0;
+    }
+
+    // ResurrectPlayer(percent, sickness(bool))
+    static int ResurrectPlayer(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        float percent = luaL_optnumber(L, 1, 100.0f);
+        bool sickness = luaL_optbool(L, 2, false);
+        player->ResurrectPlayer(percent, sickness);
+        return 0;
+    }
+
+    // CastSpell(spellID) - self
+    static int CastSpell(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 spell = luaL_checkunsigned(L, 1);
+        unit->CastSpell(unit, spell, true);
+        return 0;
+    }
+
+    // CastSpellOnTarget(spellID, unit, triggered) - See if can be gameobject target
+    static int CastSpellOnTarget(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 spell = luaL_checkunsigned(L, 1);
+        Unit* target = Eluna::get()->CHECK_UNIT(L, 2);
+        bool triggered = luaL_optbool(L, 3, true);
+        if (target)
+            unit->CastSpell(target, spell, triggered);
+        return 0;
+    }
+
+    // CastSpellAoF(x, y, z, id) - to coords
+    static int CastSpellAoF(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        float _x = luaL_checknumber(L, 1);
+        float _y = luaL_checknumber(L, 2);
+        float _z = luaL_checknumber(L, 3);
+        uint32 spell = luaL_checkunsigned(L, 4);
+        unit->CastSpell(_x, _y, _z, spell, true);
+        return 0;
+    }
+
+    // FullCastSpell(spellID) - self
+    static int FullCastSpell(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 spell = luaL_checkunsigned(L, 1);
+        unit->CastSpell(unit, spell, false);
+        return 0;
+    }
+
+    // FullCastSpellOnTarget(spellID, unit) - See if can be gameobject target
+    static int FullCastSpellOnTarget(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 spell = luaL_checkunsigned(L, 1);
+        Unit* target = Eluna::get()->CHECK_UNIT(L, 2);
+        if (target)
+            unit->CastSpell(target, spell, false);
+        return 0;
+    }
+
+    // GetAccountId()
+    static int GetAccountId(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        Eluna::get()->PushUnsigned(L, player->GetSession()->GetAccountId());
+        return 1;
+    }
+
+    // GetAccountName()
+    static int GetAccountName(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        std::string accName;
+        if (sAccountMgr->GetName(player->GetSession()->GetAccountId(), accName))
+            Eluna::get()->PushString(L, accName.c_str());
+        else
+            return 0;
+        return 1;
+    }
+
+    // GetAITargets()
+    static int GetAITargets(lua_State* L, Unit* unit)
+    {
+        TO_CREATURE();
+
+        lua_newtable(L);
+        int tbl = lua_gettop(L);
+        uint32 i = 0;
+
+        ThreatContainer::StorageType const &threatList = creature->getThreatManager().getThreatList();
+        ThreatContainer::StorageType::const_iterator itr;
+        for (itr = threatList.begin(); itr != threatList.end(); ++itr)
+        {
+            Unit* target = (*itr)->getTarget();
+            if (!target)
+                continue;
+            ++i;
+            Eluna::get()->PushUnsigned(L, i);
+            Eluna::get()->PushUnit(L, target);
+            lua_settable(L, tbl);
+        }
+
+        lua_settop(L, tbl);
+        return 1;
+    }
+
+    // GetAITargetsCount()
+    static int GetAITargetsCount(lua_State* L, Unit* unit)
+    {
+        TO_CREATURE();
+
+        Eluna::get()->PushUnsigned(L, creature->getThreatManager().getThreatList().size());
+        return 1;
+    }
+
+    // GetAura(spellID)
+    static int GetAura(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 spellID = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushAura(L, unit->GetAura(spellID));
+        return 1;
+    }
+
+    // GetMapId()
+    static int GetMapId(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Eluna::get()->PushUnsigned(L, unit->GetMapId());
+        return 1;
+    }
+
+    // GossipMenuAddItem(icon, msg, Intid, code, accept_decline_message, money)
+    static int GossipMenuAddItem(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 _icon = luaL_checkunsigned(L, 1);
+        const char* msg = luaL_checkstring(L, 2);
+        uint32 _sender = luaL_checkunsigned(L, 3);
+        uint32 _intid = luaL_checkunsigned(L, 4);
+        bool _code = luaL_optbool(L, 5, false);
+        const char* _promptMsg = luaL_optstring(L, 6, "");
+        uint32 _money = luaL_optunsigned(L, 7, 0);
+        player->ADD_GOSSIP_ITEM_EXTENDED(_icon, msg, _sender, _intid, _promptMsg, _money, _code);
+        return 0;
+    }
+
+    // GossipComplete()
+    static int GossipComplete(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        player->CLOSE_GOSSIP_MENU();
+        return 0;
+    }
+
+    // GossipSendMenu(npc_text, unit)
+    static int GossipSendMenu(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 _npcText = luaL_checkunsigned(L, 1);
+        Unit* sender = Eluna::get()->CHECK_UNIT(L, 2);
+        if (sender)
+        {
+            if (sender->ToPlayer())
+            {
+                uint32 menu_id = luaL_checkunsigned(L, 3);
+                player->PlayerTalkClass->GetGossipMenu().SetMenuId(menu_id);
+            }
+            player->SEND_GOSSIP_MENU(_npcText, sender->GetGUID());
+        }
+        return 0;
+    }
+
+    // GossipClearMenu()
+    static int GossipClearMenu(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        player->PlayerTalkClass->ClearMenus();
+        return 0;
+    }
+
+    // PlaySoundToPlayer(soundId)
+    static int PlaySoundToPlayer(lua_State* L, Unit* unit)
+    {
+        TO_PLAYER();
+
+        uint32 soundId = luaL_checkunsigned(L, 1);
+        SoundEntriesEntry const* soundEntry = sSoundEntriesStore.LookupEntry(soundId);
+        if (!soundEntry)
+            return 0;
+
+        player->PlayDirectSound(soundId, player);
+        return 0;
+    }
+
+    // PlayDirectSound(soundId,  player)
+    static int PlayDirectSound(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 soundId = luaL_checkunsigned(L, 1);
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 2);
+        if (!sSoundEntriesStore.LookupEntry(soundId))
+            return 0;
+
+        if (player)
+            unit->PlayDirectSound(soundId, player);
+        else
+            unit->PlayDirectSound(soundId);
+        return 0;
+    }
+
+    // PlayDistanceSound(soundId,  player)
+    static int PlayDistanceSound(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint32 soundId = luaL_checkunsigned(L, 1);
+        Player* player = Eluna::get()->CHECK_PLAYER(L, 2);
+        if (!sSoundEntriesStore.LookupEntry(soundId))
+            return 0;
+
+        if (player)
+            unit->PlayDistanceSound(soundId, player);
+        else
+            unit->PlayDistanceSound(soundId);
+        return 0;
+    }
+
+    // Kill([target, durabilityLoss]) - Creates a timed event. Calls set to 0 will call inf returns eventID.
+    static int Kill(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Unit* target = Eluna::get()->CHECK_UNIT(L, 1);
+        bool durLoss = luaL_optbool(L, 2, true);
+        unit->Kill((target ? target : unit), durLoss);
+        return 0;
+    }
+
+    // RegisterEvent(function, delay, calls)
+    static int RegisterEvent(lua_State* L, Unit* unit)
+    {
+        TO_CREATURE();
+
+        uint32 delay = luaL_checkunsigned(L, 2);
+        uint32 repeats = luaL_checkunsigned(L, 3);
+        Eluna::LuaCreatureScript::LuaCreatureAI* luaAI = sLuaCreatureScript->GetAI(creature);
+        if (!luaAI)
+        {
+            luaL_error(L, "Creature has no registered creature events, please register one before using RegisterEvent");
+            return 0;
+        }
+        if (!strcmp(luaL_typename(L, 1), "function") || delay > 0)
+        {
+            lua_settop(L, 1);
+            int functionRef = lua_ref(L, true);
+            luaAI->LuaEventCreate(functionRef, delay, repeats);
+            Eluna::get()->PushInteger(L, functionRef);
+        }
+        else
+            return 0;
+        return 1;
+
+    }
+
+    // RemoveEventByID(eventID)
+    static int RemoveEventByID(lua_State* L, Unit* unit)
+    {
+        TO_CREATURE();
+
+        int eventID = luaL_checkinteger(L, 1);
+        Eluna::LuaCreatureScript::LuaCreatureAI* luaAI = sLuaCreatureScript->GetAI(creature);
+        if (luaAI)
+            luaAI->LuaEventCancel(eventID);
+        return 0;
+    }
+
+    // RemoveEvents()
+    static int RemoveEvents(lua_State* L, Unit* unit)
+    {
+        TO_CREATURE();
+
+        Eluna::LuaCreatureScript::LuaCreatureAI* luaAI = sLuaCreatureScript->GetAI(creature);
+        if (luaAI)
+            luaAI->LuaEventsReset();
+        return 0;
+    }
+
+    static int GetInt32Value(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushInteger(L, unit->GetInt32Value(index));
+        return 1;
+    }
+
+    static int GetUInt32Value(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushUnsigned(L, unit->GetUInt32Value(index));
+        return 1;
+    }
+
+    static int GetFloatValue(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        Eluna::get()->PushFloat(L, unit->GetFloatValue(index));
+        return 1;
+    }
+
+    static int GetByteValue(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        Eluna::get()->PushUnsigned(L, unit->GetByteValue(index, offset));
+        return 1;
+    }
+
+    static int GetUInt16Value(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        Eluna::get()->PushUnsigned(L, unit->GetUInt16Value(index, offset));
+        return 1;
+    }
+
+    static int SetInt32Value(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        int32 value = luaL_checkinteger(L, 2);
+        unit->SetInt32Value(index, value);
+        return 0;
+    }
+
+    static int SetUInt32Value(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint32 value = luaL_checkunsigned(L, 2);
+        unit->SetUInt32Value(index, value);
+        return 0;
+    }
+
+    static int UpdateUInt32Value(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint32 value = luaL_checkunsigned(L, 2);
+        unit->UpdateUInt32Value(index, value);
+        return 0;
+    }
+
+    static int SetFloatValue(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        float value = luaL_checknumber(L, 2);
+
+        unit->SetFloatValue(index, value);
+        return 0;
+    }
+
+    static int SetByteValue(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        uint8 value = luaL_checkunsigned(L, 3);
+        unit->SetByteValue(index, offset, value);
+        return 0;
+    }
+
+    static int SetUInt16Value(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        uint16 value = luaL_checkunsigned(L, 3);
+        unit->SetUInt16Value(index, offset, value);
+        return 0;
+    }
+
+    static int SetInt16Value(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        uint16 index = luaL_checkunsigned(L, 1);
+        uint8 offset = luaL_checkunsigned(L, 2);
+        int16 value = luaL_checkinteger(L, 3);
+        unit->SetInt16Value(index, offset, value);
+        return 0;
+    }
+
+    /* Vehicle */
+
+    // IsOnVehicle()
+    static int IsOnVehicle(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        if ((unit->GetVehicle()) || (unit->ToPlayer() && unit->IsVehicle()))
+            lua_pushboolean(L, 1);
+        else
+            lua_pushboolean(L, 0);
+        return 1;
+    }
+
+    // DismissVehicle()
+    static int DismissVehicle(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        if (unit->GetVehicle())
+            unit->GetVehicle()->Dismiss();
+        return 0;
+    }
+
+    // AddVehiclePassenger(unit, seatId)
+    static int AddVehiclePassenger(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Unit* passenger = Eluna::get()->CHECK_UNIT(L, 1);
+        int8 seatId = luaL_checkunsigned(L, 2);
+        Vehicle* _vehicle = unit->GetVehicle();
+        if (!_vehicle)
+            return 0;
+
+        _vehicle->AddPassenger(passenger, seatId);
+        return 0;
+    }
+
+    // EjectPassenger(unit) (GIVES LINKER ERROR)
+    /*
+    static int EjectPassenger(lua_State* L, Unit* unit) 
+    {
+    TO_UNIT();
+
+    Unit* passenger = Eluna::get()->CHECK_UNIT(L, 1);
+    Vehicle* _vehicle = unit->GetVehicle();
+    if (!_vehicle)
+    return 0;
+
+    _vehicle->EjectPassenger(passenger, unit);
+    return 0;
+    }*/
+
+    // RemovePassenger(unit)
+    static int RemovePassenger(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Unit* passenger = Eluna::get()->CHECK_UNIT(L, 1);
+        Vehicle* _vehicle = unit->GetVehicle();
+        if (!_vehicle)
+            return 0;
+
+        _vehicle->RemovePassenger(passenger);
+        return 0;
+    }
+
+    // RemoveAllPassengers()
+    static int RemoveAllPassengers(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Unit* _unit = unit->GetVehicleBase();
+        if (!_unit)
+            return 0;
+
+        _unit->GetVehicle()->RemoveAllPassengers();
+        return 0;
+    }
+
+    // GetPassenger(seatId)
+    static int GetPassenger(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        int8 seatId = luaL_checkunsigned(L, 1);
+        Unit* _unit = unit->GetVehicleBase();
+        if (!_unit)
+            return 0;
+
+        Eluna::get()->PushUnit(L, _unit->GetVehicle()->GetPassenger(seatId));
+        return 1;
+    }
+
+    // GetNextEmptySeat(seatId)
+    static int GetNextEmptySeat(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        int8 seatId = luaL_checkunsigned(L, 1);
+        Unit* _unit = unit->GetVehicleBase();
+        if (!_unit)
+            return 0;
+
+        //Eluna::get()->PushInteger(L, _unit->GetVehicle()->GetNextEmptySeat(seatId, true));
+        //return 1;
+        return 0;
+    }
+
+    // GetAvailableSeats()
+    static int GetAvailableSeats(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Unit* _unit = unit->GetVehicleBase();
+        if (!_unit)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, _unit->GetVehicle()->GetAvailableSeatCount());
+        return 1;
+    }
+
+    // GetVehicleBase()
+    static int GetVehicleBase(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        Unit* _unit = unit->GetVehicleBase();
+        if (_unit)
+            Eluna::get()->PushUnit(L, _unit);
+        else
+            lua_pushnil(L);
+        return 1;
+    }
+
+    // HasEmptySeat(seatId)
+    static int HasEmptySeat(lua_State* L, Unit* unit)
+    {
+        TO_UNIT();
+
+        int8 seatId = luaL_checkunsigned(L, 1);
+        Unit* _unit = unit->GetVehicleBase();
+        if (!_unit)
+            return 0;
+
+        Eluna::get()->PushBoolean(L, _unit->GetVehicle()->HasEmptySeat(seatId));
+        return 1;
+    }
+};
+#endif
diff --git a/src/server/LuaEngine/WorldPacketMethods.h b/src/server/LuaEngine/WorldPacketMethods.h
new file mode 100644
index 0000000..d83a4dc
--- /dev/null
+++ b/src/server/LuaEngine/WorldPacketMethods.h
@@ -0,0 +1,285 @@
+#ifndef WORLDPACKETMETHODS_H
+#define WORLDPACKETMETHODS_H
+
+class LuaPacket
+{
+public:
+    // GetUnitType()
+    static int GetUnitType(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        lua_pushstring(L, "Packet");
+        return 1;
+    }
+
+    // GetOpcode()
+    static int GetOpcode(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, packet->GetOpcode());
+        return 1;
+    }
+
+    // GetSize()
+    static int GetSize(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        Eluna::get()->PushUnsigned(L, packet->size());
+        return 1;
+    }
+
+    // SetOpcode(opcode)
+    static int SetOpcode(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint16 opcode = luaL_checkunsigned(L, 1);
+        if (opcode >= NUM_MSG_TYPES)
+            luaL_error(L, "Eluna Nova::Opcode %d is greater than the max Opcode type (%d)!", opcode, NUM_MSG_TYPES);
+        else
+            packet->SetOpcode(opcode);
+        return 0;
+    }
+
+    // ReadByte()
+    static int ReadByte(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int8 byte;
+        (*packet) >> byte;
+        Eluna::get()->PushInteger(L, byte);
+        return 1;
+    }
+
+    // ReadUByte()
+    static int ReadUByte(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint8 byte;
+        (*packet) >> byte;
+        Eluna::get()->PushUnsigned(L, byte);
+        return 1;
+    }
+
+    // ReadShort()
+    static int ReadShort(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int16 _short;
+        (*packet) >> _short;
+        Eluna::get()->PushInteger(L, _short);
+        return 1;
+    }
+
+    // ReadUShort()
+    static int ReadUShort(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint16 _ushort;
+        (*packet) >> _ushort;
+        Eluna::get()->PushUnsigned(L, _ushort);
+        return 1;
+    }
+
+    // ReadLong()
+    static int ReadLong(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int32 _long;
+        (*packet) >> _long;
+        Eluna::get()->PushInteger(L, _long);
+        return 1;
+    }
+
+    // ReadULong()
+    static int ReadULong(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint32 _ulong;
+        (*packet) >> _ulong;
+        Eluna::get()->PushUnsigned(L, _ulong);
+        return 1;
+    }
+
+    // ReadFloat()
+    static int ReadFloat(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        float _val;
+        (*packet) >> _val;
+        Eluna::get()->PushFloat(L, _val);
+        return 1;
+    }
+
+    // ReadDouble()
+    static int ReadDouble(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        double _val;
+        (*packet) >> _val;
+        Eluna::get()->PushDouble(L, _val);
+        return 1;
+    }
+
+    // ReadGUID()
+    static int ReadGUID(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint64 guid;
+        (*packet) >> guid;
+        Eluna::get()->PushGUID(L, guid);
+        return 1;
+    }
+
+    // ReadString()
+    static int ReadString(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        string _val;
+        (*packet) >> _val;
+        Eluna::get()->PushString(L, _val.c_str());
+        return 1;
+    }
+
+    // WriteGUID(WorldObject)
+    static int WriteGUID(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        WorldObject* obj = Eluna::get()->CHECK_WORLDOBJECT(L, 1);
+        if (!obj)
+            return 0;
+
+        (*packet) << obj->GetGUID();
+        return 0;
+    }
+
+    // WriteString(string)
+    static int WriteString(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        string _val = string(luaL_checkstring(L, 1));
+        (*packet) << _val;
+        return 0;
+    }
+
+    // WriteBye(byte)
+    static int WriteByte(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int8 byte = luaL_checkinteger(L, 1);
+        (*packet) << byte;
+        return 0;
+    }
+
+    // WriteUByte(byte)
+    static int WriteUByte(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint8 byte = luaL_checkunsigned(L, 1);
+        (*packet) << byte;
+        return 0;
+    }
+
+    // WriteUShort(short)
+    static int WriteUShort(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint16 _ushort = luaL_checkunsigned(L, 1);
+        (*packet) << _ushort;
+        return 0;
+    }
+
+    // WriteShort(short)
+    static int WriteShort(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int16 _short = luaL_checkinteger(L, 1);
+        (*packet) << _short;
+        return 0;
+    }
+
+    // WriteLong(long)
+    static int WriteLong(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        int32 _long = luaL_checkinteger(L, 1);
+        (*packet) << _long;
+        return 0;
+    }
+
+    // WriteULong(long)
+    static int WriteULong(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        uint32 _ulong = luaL_checkunsigned(L, 1);
+        (*packet) << _ulong;
+        return 0;
+    }
+
+    // WriteFloat(float)
+    static int WriteFloat(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        float _val = luaL_checknumber(L, 1);
+        (*packet) << _val;
+        return 0;
+    }
+
+    // WriteDouble(double)
+    static int WriteDouble(lua_State* L, WorldPacket* packet)
+    {
+        if (!packet)
+            return 0;
+
+        double _val = luaL_checknumber(L, 1);
+        (*packet) << _val;
+        return 0;
+    }
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/LuaEngine/lua.lib b/src/server/LuaEngine/lua.lib
new file mode 100644
index 0000000..824e714
Binary files /dev/null and b/src/server/LuaEngine/lua.lib differ
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index f455610..ff273d7 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -107,6 +107,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
   ${CMAKE_SOURCE_DIR}/dep/SFMT
   ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/dep/lualib
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
   ${CMAKE_SOURCE_DIR}/src/server/collision/Models
@@ -124,6 +125,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
   ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
   ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/LuaEngine
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/Accounts
   ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
@@ -204,9 +206,17 @@ include_directories(
 add_library(game STATIC
   ${game_STAT_SRCS}
   ${game_STAT_PCH_SRC}
+  ${lua_STAT_SRCS}
+  ${LuaEngine_STAT_SRCS}
 )
 
 add_dependencies(game revision.h)
+add_dependencies(game lua)
+
+target_link_libraries(game
+ lua
+ LuaEngine
+)
 
 # Generate precompiled header
 if (USE_COREPCH)
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index efb3a3b..0b08a1a 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -39,6 +39,7 @@
 #include "Util.h"
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
+#include "LuaEngine.h"
 
 void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 {
@@ -251,6 +252,9 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
             }
 
+            if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_CHAT, sender, type, lang, msg))
+                return;
+
             if (type == CHAT_MSG_SAY)
                 sender->Say(msg, lang);
             else if (type == CHAT_MSG_EMOTE)
@@ -318,6 +322,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_GROUP_CHAT, sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, uint8(type), lang, NULL, 0, msg.c_str(), NULL);
@@ -330,6 +336,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 if (Guild* guild = sGuildMgr->GetGuildById(GetPlayer()->GetGuildId()))
                 {
                     sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, guild);
+                    if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_GUILD_CHAT, sender, type, lang, msg, guild))
+                        return;
 
                     guild->BroadcastToGuild(this, false, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
                 }
@@ -342,6 +350,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 if (Guild* guild = sGuildMgr->GetGuildById(GetPlayer()->GetGuildId()))
                 {
                     sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, guild);
+                    if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_GUILD_CHAT, sender, type, lang, msg, guild))
+                        return;
 
                     guild->BroadcastToGuild(this, true, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
                 }
@@ -359,6 +369,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             }
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_GROUP_CHAT, sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_RAID, lang, "", 0, msg.c_str(), NULL);
@@ -376,6 +388,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             }
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_GROUP_CHAT, sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_RAID_LEADER, lang, "", 0, msg.c_str(), NULL);
@@ -388,6 +402,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_GROUP_CHAT, sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             //in battleground, raid warning is sent only to players in battleground - code is ok
@@ -402,6 +418,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_GROUP_CHAT, sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_BATTLEGROUND, lang, "", 0, msg.c_str(), NULL);
@@ -415,6 +433,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
+            if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_GROUP_CHAT, sender, type, lang, msg, group))
+                return;
 
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, CHAT_MSG_BATTLEGROUND_LEADER, lang, "", 0, msg.c_str(), NULL);
@@ -436,6 +456,9 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 if (Channel* chn = cMgr->GetChannel(channel, _player))
                 {
                     sScriptMgr->OnPlayerChat(_player, type, lang, msg, chn);
+                    if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_CHANNEL_CHAT, sender, type, lang, msg, chn))
+                        return;
+
                     chn->Say(_player->GetGUID(), msg.c_str(), lang);
                 }
             }
@@ -462,6 +485,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 }
 
                 sScriptMgr->OnPlayerChat(_player, type, lang, msg);
+                if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_CHAT, sender, type, lang, msg))
+                    return;
             }
             break;
         }
@@ -485,6 +510,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             }
 
             sScriptMgr->OnPlayerChat(_player, type, lang, msg);
+            if(!Eluna::getScript()->OnChat(PLAYER_EVENT_ON_CHAT, sender, type, lang, msg))
+                return;
             break;
         }
         default:
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index 3cd9372..02e7fdc 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -55,6 +55,7 @@
 #include "BattlegroundMgr.h"
 #include "Battlefield.h"
 #include "BattlefieldMgr.h"
+#include "LuaEngine.h"
 
 void WorldSession::HandleRepopRequestOpcode(WorldPacket& recvData)
 {
@@ -100,6 +101,12 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
     if (_player->PlayerTalkClass->IsGossipOptionCoded(gossipListId))
         recvData >> code;
 
+    if (IS_ITEM_GUID(guid) || IS_PLAYER_GUID(guid))
+    {
+        Eluna::getScript()->HandleGossipSelectOption(GetPlayer(), guid, GetPlayer()->PlayerTalkClass->GetGossipOptionSender(gossipListId), GetPlayer()->PlayerTalkClass->GetGossipOptionAction(gossipListId), code, menuId);
+        return;
+    }
+
     Creature* unit = NULL;
     GameObject* go = NULL;
     if (IS_CRE_OR_VEH_GUID(guid))
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index 32fe5d2..788f24d 100644
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -32,6 +32,7 @@
 #include "CreatureAI.h"
 #include "Player.h"
 #include "WorldPacket.h"
+#include "LuaEngine.h"
 
 // This is the global static registry of scripts.
 template<class TScript>
@@ -176,6 +177,7 @@ void ScriptMgr::Initialize()
     uint32 oldMSTime = getMSTime();
 
     LoadDatabase();
+	Eluna::Init();
 
     sLog->outInfo(LOG_FILTER_SERVER_LOADING, "Loading C++ scripts");
 
@@ -582,6 +584,8 @@ void ScriptMgr::OnPlayerEnterMap(Map* map, Player* player)
 
     FOREACH_SCRIPT(PlayerScript)->OnMapChanged(player);
 
+    Eluna::getScript()->OnMapChanged(PLAYER_EVENT_ON_MAP_CHANGE, player);
+
     SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnPlayerEnter(map, player);
     SCR_MAP_END;
@@ -646,6 +650,10 @@ bool ScriptMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effInd
     ASSERT(caster);
     ASSERT(target);
 
+
+	if (Eluna::getScript()->OnDummyEffect(ITEM_EVENT_ON_DUMMY_EFFECT, caster, spellId, effIndex, target))
+		return true;
+
     GET_SCRIPT_RET(ItemScript, target->GetScriptId(), tmpscript, false);
     return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);
 }
@@ -656,6 +664,10 @@ bool ScriptMgr::OnQuestAccept(Player* player, Item* item, Quest const* quest)
     ASSERT(item);
     ASSERT(quest);
 
+
+	if (Eluna::getScript()->OnQuestAccept(ITEM_EVENT_ON_QUEST_ACCEPT, player, item, quest))
+		return true;
+
     GET_SCRIPT_RET(ItemScript, item->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestAccept(player, item, quest);
@@ -666,6 +678,10 @@ bool ScriptMgr::OnItemUse(Player* player, Item* item, SpellCastTargets const& ta
     ASSERT(player);
     ASSERT(item);
 
+
+	if (Eluna::getScript()->OnItemUse(ITEM_EVENT_ON_USE, player, item, targets))
+		return true;
+
     GET_SCRIPT_RET(ItemScript, item->GetScriptId(), tmpscript, false);
     return tmpscript->OnUse(player, item, targets);
 }
@@ -675,6 +691,10 @@ bool ScriptMgr::OnItemExpire(Player* player, ItemTemplate const* proto)
     ASSERT(player);
     ASSERT(proto);
 
+
+	if (Eluna::getScript()->OnItemExpire(ITEM_EVENT_ON_EXPIRE, player, proto))
+		return true;
+
     GET_SCRIPT_RET(ItemScript, proto->ScriptId, tmpscript, false);
     return tmpscript->OnExpire(player, proto);
 }
@@ -684,6 +704,10 @@ bool ScriptMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effInd
     ASSERT(caster);
     ASSERT(target);
 
+
+	if(Eluna::getScript()->OnDummyEffect(CREATURE_EVENT_ON_DUMMY_EFFECT, caster, spellId, effIndex, target))
+		return true;
+
     GET_SCRIPT_RET(CreatureScript, target->GetScriptId(), tmpscript, false);
     return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);
 }
@@ -693,6 +717,10 @@ bool ScriptMgr::OnGossipHello(Player* player, Creature* creature)
     ASSERT(player);
     ASSERT(creature);
 
+
+	if(Eluna::getScript()->OnGossipHello(GOSSIP_EVENT_ON_HELLO, player, creature))
+		return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnGossipHello(player, creature);
@@ -703,6 +731,10 @@ bool ScriptMgr::OnGossipSelect(Player* player, Creature* creature, uint32 sender
     ASSERT(player);
     ASSERT(creature);
 
+    
+	if (Eluna::getScript()->OnGossipSelect(GOSSIP_EVENT_ON_SELECT, player, creature, sender, action))
+		return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     return tmpscript->OnGossipSelect(player, creature, sender, action);
 }
@@ -713,6 +745,10 @@ bool ScriptMgr::OnGossipSelectCode(Player* player, Creature* creature, uint32 se
     ASSERT(creature);
     ASSERT(code);
 
+    
+	if(Eluna::getScript()->OnGossipSelectCode(GOSSIP_EVENT_ON_SELECT, player, creature, sender, action, code))
+		return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     return tmpscript->OnGossipSelectCode(player, creature, sender, action, code);
 }
@@ -723,6 +759,10 @@ bool ScriptMgr::OnQuestAccept(Player* player, Creature* creature, Quest const* q
     ASSERT(creature);
     ASSERT(quest);
 
+
+	if (Eluna::getScript()->OnQuestAccept(CREATURE_EVENT_ON_QUEST_ACCEPT, player, creature, quest))
+		return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestAccept(player, creature, quest);
@@ -734,6 +774,10 @@ bool ScriptMgr::OnQuestSelect(Player* player, Creature* creature, Quest const* q
     ASSERT(creature);
     ASSERT(quest);
 
+
+	if (Eluna::getScript()->OnQuestSelect(CREATURE_EVENT_ON_QUEST_SELECT, player, creature, quest))
+		return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestSelect(player, creature, quest);
@@ -745,6 +789,10 @@ bool ScriptMgr::OnQuestComplete(Player* player, Creature* creature, Quest const*
     ASSERT(creature);
     ASSERT(quest);
 
+
+	if (Eluna::getScript()->OnQuestComplete(CREATURE_EVENT_ON_QUEST_COMPLETE, player, creature, quest))
+		return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestComplete(player, creature, quest);
@@ -756,6 +804,10 @@ bool ScriptMgr::OnQuestReward(Player* player, Creature* creature, Quest const* q
     ASSERT(creature);
     ASSERT(quest);
 
+
+	if (Eluna::getScript()->OnQuestReward(CREATURE_EVENT_ON_QUEST_REWARD, player, creature, quest, opt))
+		return true;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestReward(player, creature, quest, opt);
@@ -766,6 +818,9 @@ uint32 ScriptMgr::GetDialogStatus(Player* player, Creature* creature)
     ASSERT(player);
     ASSERT(creature);
 
+
+	Eluna::getScript()->GetDialogStatus(CREATURE_EVENT_ON_DIALOG_STATUS, player, creature);
+
     // TODO: 100 is a funny magic number to have hanging around here...
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, 100);
     player->PlayerTalkClass->ClearMenus();
@@ -776,6 +831,10 @@ CreatureAI* ScriptMgr::GetCreatureAI(Creature* creature)
 {
     ASSERT(creature);
 
+
+    if(CreatureAI* AI = sLuaCreatureScript->GetAI(creature))
+        return AI;
+
     GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, NULL);
     return tmpscript->GetAI(creature);
 }
@@ -784,6 +843,10 @@ GameObjectAI* ScriptMgr::GetGameObjectAI(GameObject* gameobject)
 {
     ASSERT(gameobject);
 
+
+    if(GameObjectAI* AI = sLuaGameObjectScript->GetAI(gameobject))
+        return AI;
+
     GET_SCRIPT_RET(GameObjectScript, gameobject->GetScriptId(), tmpscript, NULL);
     return tmpscript->GetAI(gameobject);
 }
@@ -801,6 +864,10 @@ bool ScriptMgr::OnGossipHello(Player* player, GameObject* go)
     ASSERT(player);
     ASSERT(go);
 
+
+	if (Eluna::getScript()->OnGossipHello(GOSSIP_EVENT_ON_HELLO, player, go))
+		return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnGossipHello(player, go);
@@ -811,6 +878,10 @@ bool ScriptMgr::OnGossipSelect(Player* player, GameObject* go, uint32 sender, ui
     ASSERT(player);
     ASSERT(go);
 
+
+	if (Eluna::getScript()->OnGossipSelect(GOSSIP_EVENT_ON_SELECT, player, go, sender, action))
+		return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     return tmpscript->OnGossipSelect(player, go, sender, action);
 }
@@ -821,6 +892,10 @@ bool ScriptMgr::OnGossipSelectCode(Player* player, GameObject* go, uint32 sender
     ASSERT(go);
     ASSERT(code);
 
+
+	if (Eluna::getScript()->OnGossipSelectCode(GOSSIP_EVENT_ON_SELECT, player, go, sender, action, code))
+		return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     return tmpscript->OnGossipSelectCode(player, go, sender, action, code);
 }
@@ -831,6 +906,10 @@ bool ScriptMgr::OnQuestAccept(Player* player, GameObject* go, Quest const* quest
     ASSERT(go);
     ASSERT(quest);
 
+
+	if (Eluna::getScript()->OnQuestAccept(GAMEOBJECT_EVENT_ON_QUEST_ACCEPT, player, go, quest))
+		return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestAccept(player, go, quest);
@@ -842,6 +921,10 @@ bool ScriptMgr::OnQuestReward(Player* player, GameObject* go, Quest const* quest
     ASSERT(go);
     ASSERT(quest);
 
+
+	if (Eluna::getScript()->OnQuestReward(GAMEOBJECT_EVENT_ON_QUEST_REWARD, player, go, quest, opt))
+		return true;
+
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, false);
     player->PlayerTalkClass->ClearMenus();
     return tmpscript->OnQuestReward(player, go, quest, opt);
@@ -852,6 +935,9 @@ uint32 ScriptMgr::GetDialogStatus(Player* player, GameObject* go)
     ASSERT(player);
     ASSERT(go);
 
+
+	Eluna::getScript()->GetDialogStatus(GAMEOBJECT_EVENT_ON_DIALOG_STATUS, player, go);
+
     // TODO: 100 is a funny magic number to have hanging around here...
     GET_SCRIPT_RET(GameObjectScript, go->GetScriptId(), tmpscript, 100);
     player->PlayerTalkClass->ClearMenus();
@@ -862,6 +948,9 @@ void ScriptMgr::OnGameObjectDestroyed(GameObject* go, Player* player)
 {
     ASSERT(go);
 
+
+	Eluna::getScript()->OnDestroyed(GAMEOBJECT_EVENT_ON_DESTROYED, go, player);
+
     GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);
     tmpscript->OnDestroyed(go, player);
 }
@@ -870,6 +959,9 @@ void ScriptMgr::OnGameObjectDamaged(GameObject* go, Player* player)
 {
     ASSERT(go);
 
+
+    Eluna::getScript()->OnFirstDamaged(GAMEOBJECT_EVENT_ON_DAMAGED, go, player);
+
     GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);
     tmpscript->OnDamaged(go, player);
 }
@@ -878,6 +970,9 @@ void ScriptMgr::OnGameObjectLootStateChanged(GameObject* go, uint32 state, Unit*
 {
     ASSERT(go);
 
+
+	Eluna::getScript()->OnLootStateChanged(GAMEOBJECT_EVENT_ON_LOOT_STATE_CHANGE, go, state, unit);
+
     GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);
     tmpscript->OnLootStateChanged(go, state, unit);
 }
@@ -886,6 +981,9 @@ void ScriptMgr::OnGameObjectStateChanged(GameObject* go, uint32 state)
 {
     ASSERT(go);
 
+
+	Eluna::getScript()->OnGameObjectStateChanged(GAMEOBJECT_EVENT_ON_GO_STATE_CHANGED, go, state);
+
     GET_SCRIPT(GameObjectScript, go->GetScriptId(), tmpscript);
     tmpscript->OnGameObjectStateChanged(go, state);
 }
@@ -903,6 +1001,10 @@ bool ScriptMgr::OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effInd
     ASSERT(caster);
     ASSERT(target);
 
+
+	if (Eluna::getScript()->OnDummyEffect(GAMEOBJECT_EVENT_ON_DUMMY_EFFECT, caster, spellId, effIndex, target))
+		return true;
+
     GET_SCRIPT_RET(GameObjectScript, target->GetScriptId(), tmpscript, false);
     return tmpscript->OnDummyEffect(caster, spellId, effIndex, target);
 }
@@ -912,6 +1014,10 @@ bool ScriptMgr::OnAreaTrigger(Player* player, AreaTriggerEntry const* trigger)
     ASSERT(player);
     ASSERT(trigger);
 
+
+    if(Eluna::getScript()->OnAreaTrigger(TRIGGER_EVENT_ON_TRIGGER, player, trigger))
+        return true;
+
     GET_SCRIPT_RET(AreaTriggerScript, sObjectMgr->GetAreaTriggerScriptId(trigger->id), tmpscript, false);
     return tmpscript->OnTrigger(player, trigger);
 }
@@ -945,6 +1051,9 @@ void ScriptMgr::OnWeatherChange(Weather* weather, WeatherState state, float grad
 {
     ASSERT(weather);
 
+
+	Eluna::getScript()->OnWeatherChange(WEATHER_EVENT_ON_CHANGE, weather, state, grade);
+
     GET_SCRIPT(WeatherScript, weather->GetScriptId(), tmpscript);
     tmpscript->OnChange(weather, state, grade);
 }
@@ -1126,61 +1235,85 @@ bool ScriptMgr::OnCriteriaCheck(uint32 scriptId, Player* source, Unit* target)
 void ScriptMgr::OnPVPKill(Player* killer, Player* killed)
 {
     FOREACH_SCRIPT(PlayerScript)->OnPVPKill(killer, killed);
+
+	Eluna::getScript()->OnPvPKill(PLAYER_EVENT_ON_KILL_PLAYER, killer, killed);
 }
 
 void ScriptMgr::OnCreatureKill(Player* killer, Creature* killed)
 {
     FOREACH_SCRIPT(PlayerScript)->OnCreatureKill(killer, killed);
+
+    Eluna::getScript()->OnCreatureKill(PLAYER_EVENT_ON_KILL_CREATURE, killer, killed);
 }
 
 void ScriptMgr::OnPlayerKilledByCreature(Creature* killer, Player* killed)
 {
     FOREACH_SCRIPT(PlayerScript)->OnPlayerKilledByCreature(killer, killed);
+
+    Eluna::getScript()->OnPlayerKilledByCreature(PLAYER_EVENT_ON_KILLED_BY_CREATURE, killer, killed);
 }
 
 void ScriptMgr::OnPlayerLevelChanged(Player* player, uint8 oldLevel)
 {
     FOREACH_SCRIPT(PlayerScript)->OnLevelChanged(player, oldLevel);
+
+	Eluna::getScript()->OnPlayerLevelChanged(PLAYER_EVENT_ON_LEVEL_CHANGE, player, oldLevel);
 }
 
 void ScriptMgr::OnPlayerFreeTalentPointsChanged(Player* player, uint32 points)
 {
     FOREACH_SCRIPT(PlayerScript)->OnFreeTalentPointsChanged(player, points);
+
+	Eluna::getScript()->OnPlayerTalentsChanged(PLAYER_EVENT_ON_TALENTS_CHANGE, player, points);
 }
 
 void ScriptMgr::OnPlayerTalentsReset(Player* player, bool noCost)
 {
     FOREACH_SCRIPT(PlayerScript)->OnTalentsReset(player, noCost);
+
+    Eluna::getScript()->OnPlayerTalentsReset(PLAYER_EVENT_ON_TALENTS_RESET, player, noCost);
 }
 
 void ScriptMgr::OnPlayerMoneyChanged(Player* player, int32& amount)
 {
     FOREACH_SCRIPT(PlayerScript)->OnMoneyChanged(player, amount);
+
+    Eluna::getScript()->OnPlayerMoneyChanged(PLAYER_EVENT_ON_MONEY_CHANGE, player, amount);
 }
 
 void ScriptMgr::OnGivePlayerXP(Player* player, uint32& amount, Unit* victim)
 {
     FOREACH_SCRIPT(PlayerScript)->OnGiveXP(player, amount, victim);
+
+    Eluna::getScript()->OnGivePlayerXP(PLAYER_EVENT_ON_GIVE_XP, player, amount, victim);
 }
 
 void ScriptMgr::OnPlayerReputationChange(Player* player, uint32 factionID, int32& standing, bool incremental)
 {
     FOREACH_SCRIPT(PlayerScript)->OnReputationChange(player, factionID, standing, incremental);
+
+    Eluna::getScript()->OnPlayerReputationChange(PLAYER_EVENT_ON_REPUTATION_CHANGE, player, factionID, standing, incremental);
 }
 
 void ScriptMgr::OnPlayerDuelRequest(Player* target, Player* challenger)
 {
     FOREACH_SCRIPT(PlayerScript)->OnDuelRequest(target, challenger);
+
+    Eluna::getScript()->OnPlayerDuelRequest(PLAYER_EVENT_ON_DUEL_REQUEST, target, challenger);
 }
 
 void ScriptMgr::OnPlayerDuelStart(Player* player1, Player* player2)
 {
     FOREACH_SCRIPT(PlayerScript)->OnDuelStart(player1, player2);
+
+    Eluna::getScript()->OnPlayerDuelStart(PLAYER_EVENT_ON_DUEL_START, player1, player2);
 }
 
 void ScriptMgr::OnPlayerDuelEnd(Player* winner, Player* loser, DuelCompleteType type)
 {
     FOREACH_SCRIPT(PlayerScript)->OnDuelEnd(winner, loser, type);
+
+    Eluna::getScript()->OnPlayerDuelEnd(PLAYER_EVENT_ON_DUEL_END, winner, loser, type);
 }
 
 void ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg)
@@ -1191,6 +1324,8 @@ void ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::stri
 void ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg, Player* receiver)
 {
     FOREACH_SCRIPT(PlayerScript)->OnChat(player, type, lang, msg, receiver);
+
+	Eluna::getScript()->OnChat(PLAYER_EVENT_ON_WHISPER, player, type, lang, msg, receiver);
 }
 
 void ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::string& msg, Group* group)
@@ -1211,108 +1346,150 @@ void ScriptMgr::OnPlayerChat(Player* player, uint32 type, uint32 lang, std::stri
 void ScriptMgr::OnPlayerEmote(Player* player, uint32 emote)
 {
     FOREACH_SCRIPT(PlayerScript)->OnEmote(player, emote);
+
+    Eluna::getScript()->OnPlayerEmote(PLAYER_EVENT_ON_EMOTE, player, emote);
 }
 
 void ScriptMgr::OnPlayerTextEmote(Player* player, uint32 textEmote, uint32 emoteNum, uint64 guid)
 {
     FOREACH_SCRIPT(PlayerScript)->OnTextEmote(player, textEmote, emoteNum, guid);
+
+    Eluna::getScript()->OnPlayerTextEmote(PLAYER_EVENT_ON_TEXT_EMOTE, player, textEmote, emoteNum, guid);
 }
 
 void ScriptMgr::OnPlayerSpellCast(Player* player, Spell* spell, bool skipCheck)
 {
     FOREACH_SCRIPT(PlayerScript)->OnSpellCast(player, spell, skipCheck);
+
+    Eluna::getScript()->OnPlayerSpellCast(PLAYER_EVENT_ON_SPELL_CAST, player, spell, skipCheck);
 }
 
 void ScriptMgr::OnPlayerLogin(Player* player)
 {
     FOREACH_SCRIPT(PlayerScript)->OnLogin(player);
+
+    Eluna::getScript()->OnPlayerLogin(PLAYER_EVENT_ON_LOGIN, player);
 }
 
 void ScriptMgr::OnPlayerLogout(Player* player)
 {
     FOREACH_SCRIPT(PlayerScript)->OnLogout(player);
+
+    Eluna::getScript()->OnPlayerLogout(PLAYER_EVENT_ON_LOGOUT, player);
 }
 
 void ScriptMgr::OnPlayerCreate(Player* player)
 {
     FOREACH_SCRIPT(PlayerScript)->OnCreate(player);
+
+    Eluna::getScript()->OnPlayerCreate(PLAYER_EVENT_ON_CHARACTER_CREATE, player);
 }
 
 void ScriptMgr::OnPlayerDelete(uint64 guid)
 {
     FOREACH_SCRIPT(PlayerScript)->OnDelete(guid);
+
+    Eluna::getScript()->OnPlayerDelete(PLAYER_EVENT_ON_CHARACTER_DELETE, guid);
 }
 
 void ScriptMgr::OnPlayerSave(Player* player)
 {
     FOREACH_SCRIPT(PlayerScript)->OnSave(player);
+
+    Eluna::getScript()->OnPlayerSave(PLAYER_EVENT_ON_SAVE, player);
 }
 
 void ScriptMgr::OnPlayerBindToInstance(Player* player, Difficulty difficulty, uint32 mapid, bool permanent)
 {
     FOREACH_SCRIPT(PlayerScript)->OnBindToInstance(player, difficulty, mapid, permanent);
+
+    Eluna::getScript()->OnPlayerBindToInstance(PLAYER_EVENT_ON_BIND_TO_INSTANCE, player, difficulty, mapid, permanent);
 }
 
 void ScriptMgr::OnPlayerUpdateZone(Player* player, uint32 newZone, uint32 newArea)
 {
     FOREACH_SCRIPT(PlayerScript)->OnUpdateZone(player, newZone, newArea);
+
+    Eluna::getScript()->OnPlayerUpdateZone(PLAYER_EVENT_ON_UPDATE_ZONE, player, newZone, newArea);
 }
 
 // Guild
 void ScriptMgr::OnGuildAddMember(Guild* guild, Player* player, uint8& plRank)
 {
     FOREACH_SCRIPT(GuildScript)->OnAddMember(guild, player, plRank);
+
+    //Eluna::getScript()->OnGuildAddMember(GUILD_EVENT_ON_ADD_MEMBER, guild, player, plRank);
 }
 
 void ScriptMgr::OnGuildRemoveMember(Guild* guild, Player* player, bool isDisbanding, bool isKicked)
 {
     FOREACH_SCRIPT(GuildScript)->OnRemoveMember(guild, player, isDisbanding, isKicked);
+
+    //Eluna::getScript()->OnGuildRemoveMember(GUILD_EVENT_ON_REMOVE_MEMBER, guild, player, isDisbanding, isKicked);
 }
 
 void ScriptMgr::OnGuildMOTDChanged(Guild* guild, const std::string& newMotd)
 {
     FOREACH_SCRIPT(GuildScript)->OnMOTDChanged(guild, newMotd);
+
+    //Eluna::getScript()->OnGuildMOTDChanged(GUILD_EVENT_ON_MOTD_CHANGE, guild, newMotd);
 }
 
 void ScriptMgr::OnGuildInfoChanged(Guild* guild, const std::string& newInfo)
 {
     FOREACH_SCRIPT(GuildScript)->OnInfoChanged(guild, newInfo);
+
+    //Eluna::getScript()->OnGuildInfoChanged(GUILD_EVENT_ON_INFO_CHANGE, guild, newInfo);
 }
 
 void ScriptMgr::OnGuildCreate(Guild* guild, Player* leader, const std::string& name)
 {
     FOREACH_SCRIPT(GuildScript)->OnCreate(guild, leader, name);
+
+    //Eluna::getScript()->OnGuildCreate(GUILD_EVENT_ON_CREATE, guild, leader, name);
 }
 
 void ScriptMgr::OnGuildDisband(Guild* guild)
 {
     FOREACH_SCRIPT(GuildScript)->OnDisband(guild);
+
+    //Eluna::getScript()->OnGuildDisband(GUILD_EVENT_ON_DISBAND, guild);
 }
 
 void ScriptMgr::OnGuildMemberWitdrawMoney(Guild* guild, Player* player, uint32 &amount, bool isRepair)
 {
     FOREACH_SCRIPT(GuildScript)->OnMemberWitdrawMoney(guild, player, amount, isRepair);
+
+    //Eluna::getScript()->OnGuildMemberWitdrawMoney(GUILD_EVENT_ON_MONEY_WITHDRAW, guild, player, amount, isRepair);
 }
 
 void ScriptMgr::OnGuildMemberDepositMoney(Guild* guild, Player* player, uint32 &amount)
 {
     FOREACH_SCRIPT(GuildScript)->OnMemberDepositMoney(guild, player, amount);
+
+    //Eluna::getScript()->OnGuildMemberDepositMoney(GUILD_EVENT_ON_MONEY_DEPOSIT, guild, player, amount);
 }
 
 void ScriptMgr::OnGuildItemMove(Guild* guild, Player* player, Item* pItem, bool isSrcBank, uint8 srcContainer, uint8 srcSlotId,
             bool isDestBank, uint8 destContainer, uint8 destSlotId)
 {
     FOREACH_SCRIPT(GuildScript)->OnItemMove(guild, player, pItem, isSrcBank, srcContainer, srcSlotId, isDestBank, destContainer, destSlotId);
+
+    //Eluna::getScript()->OnGuildItemMove(GUILD_EVENT_ON_ITEM_MOVE, guild, player, pItem, isSrcBank, srcContainer, srcSlotId, isDestBank, destContainer, destSlotId);
 }
 
 void ScriptMgr::OnGuildEvent(Guild* guild, uint8 eventType, uint32 playerGuid1, uint32 playerGuid2, uint8 newRank)
 {
     FOREACH_SCRIPT(GuildScript)->OnEvent(guild, eventType, playerGuid1, playerGuid2, newRank);
+
+    //Eluna::getScript()->OnGuildEvent(GUILD_EVENT_ON_EVENT, guild, eventType, playerGuid1, playerGuid2, newRank);
 }
 
 void ScriptMgr::OnGuildBankEvent(Guild* guild, uint8 eventType, uint8 tabId, uint32 playerGuid, uint32 itemOrMoney, uint16 itemStackCount, uint8 destTabId)
 {
     FOREACH_SCRIPT(GuildScript)->OnBankEvent(guild, eventType, tabId, playerGuid, itemOrMoney, itemStackCount, destTabId);
+
+    //Eluna::getScript()->OnGuildBankEvent(GUILD_EVENT_ON_BANK_EVENT, guild, eventType, tabId, playerGuid, itemOrMoney, itemStackCount, destTabId);
 }
 
 // Group
@@ -1320,30 +1497,40 @@ void ScriptMgr::OnGroupAddMember(Group* group, uint64 guid)
 {
     ASSERT(group);
     FOREACH_SCRIPT(GroupScript)->OnAddMember(group, guid);
+
+    Eluna::getScript()->OnGroupAddMember(GROUP_EVENT_ON_MEMBER_ADD, group, guid);
 }
 
 void ScriptMgr::OnGroupInviteMember(Group* group, uint64 guid)
 {
     ASSERT(group);
     FOREACH_SCRIPT(GroupScript)->OnInviteMember(group, guid);
+
+    Eluna::getScript()->OnGroupInviteMember(GROUP_EVENT_ON_MEMBER_INVITE, group, guid);
 }
 
 void ScriptMgr::OnGroupRemoveMember(Group* group, uint64 guid, RemoveMethod method, uint64 kicker, const char* reason)
 {
     ASSERT(group);
     FOREACH_SCRIPT(GroupScript)->OnRemoveMember(group, guid, method, kicker, reason);
+
+    Eluna::getScript()->OnGroupRemoveMember(GROUP_EVENT_ON_MEMBER_REMOVE, group, guid, method, kicker, reason);
 }
 
 void ScriptMgr::OnGroupChangeLeader(Group* group, uint64 newLeaderGuid, uint64 oldLeaderGuid)
 {
     ASSERT(group);
     FOREACH_SCRIPT(GroupScript)->OnChangeLeader(group, newLeaderGuid, oldLeaderGuid);
+
+    Eluna::getScript()->OnGroupChangeLeader(GROUP_EVENT_ON_LEADER_CHANGE, group, newLeaderGuid, oldLeaderGuid);
 }
 
 void ScriptMgr::OnGroupDisband(Group* group)
 {
     ASSERT(group);
     FOREACH_SCRIPT(GroupScript)->OnDisband(group);
+
+    Eluna::getScript()->OnGroupDisband(GROUP_EVENT_ON_DISBAND, group);
 }
 
 // Unit
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index cf46180..d505589 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -65,6 +65,8 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
   ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/LuaEngine
+  ${CMAKE_SOURCE_DIR}/dep/lualib
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Database
   ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
diff --git a/src/server/scripts/Commands/cs_rbac.cpp b/src/server/scripts/Commands/cs_rbac.cpp
index 604218c..e1041b8 100644
--- a/src/server/scripts/Commands/cs_rbac.cpp
+++ b/src/server/scripts/Commands/cs_rbac.cpp
@@ -777,4 +777,4 @@ class rbac_commandscript : public CommandScript
 void AddSC_rbac_commandscript()
 {
     new rbac_commandscript();
-}
+}
diff --git a/src/server/scripts/Commands/cs_reload.cpp b/src/server/scripts/Commands/cs_reload.cpp
index 7aee113..8385286 100644
--- a/src/server/scripts/Commands/cs_reload.cpp
+++ b/src/server/scripts/Commands/cs_reload.cpp
@@ -41,6 +41,7 @@
 #include "TicketMgr.h"
 #include "WardenCheckMgr.h"
 #include "WaypointManager.h"
+#include "LuaEngine.h"
 
 class reload_commandscript : public CommandScript
 {
@@ -159,6 +160,7 @@ class reload_commandscript : public CommandScript
             { "waypoint_data",                SEC_ADMINISTRATOR, true,  &HandleReloadWpCommand,                         "", NULL },
             { "vehicle_accessory",            SEC_ADMINISTRATOR, true,  &HandleReloadVehicleAccessoryCommand,           "", NULL },
             { "vehicle_template_accessory",   SEC_ADMINISTRATOR, true,  &HandleReloadVehicleTemplateAccessoryCommand,   "", NULL },
+			{ "eluna",                        SEC_ADMINISTRATOR, true,  &HandleReloadElunaLuaEngine,                    "", NULL },
             { NULL,                           0,                 false, NULL,                                           "", NULL }
         };
         static ChatCommand commandTable[] =
@@ -1245,6 +1247,13 @@ class reload_commandscript : public CommandScript
         return true;
     }
 
+	static bool HandleReloadElunaLuaEngine(ChatHandler* handler, const char* /*args*/)
+	{
+        Eluna::get()->Restart();
+        handler->SendSysMessage("Reloaded Eluna Nova Engine");
+        return true;
+	}
+
     static bool HandleReloadRBACCommand(ChatHandler* handler, const char* /*args*/)
     {
         sLog->outInfo(LOG_FILTER_GENERAL, "Reloading RBAC tables...");
